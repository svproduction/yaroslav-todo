// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"kI3VP":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "31648ca538661719";
"use strict";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>ðŸ’¡ ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"7BQdY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _modalGroup = require("./script/modalGroup");
var _modalGroupDefault = parcelHelpers.interopDefault(_modalGroup);
var _modalTask = require("./script/modalTask");
var _modalTaskDefault = parcelHelpers.interopDefault(_modalTask);
var _createGroup = require("./script/createGroup");
var _selector = require("./script/selector");
var _createTasks = require("./script/createTasks");
_selector.group.addEventListener('click', _modalGroupDefault.default);
_selector.task.addEventListener('click', _modalTaskDefault.default);
_selector.btnCreateGroup.addEventListener('click', _createGroup.createGroup);
_createGroup.showGroup();
_selector.btnCreateTask.addEventListener('click', _createTasks.createTask);
_createTasks.showTasks();

},{"./script/modalGroup":"c0mjK","./script/modalTask":"4vgkK","./script/createGroup":"92WVk","./script/selector":"cjxTH","./script/createTasks":"kpwva","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c0mjK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _selector = require("./selector");
const groupModalView = (e1)=>{
    e1.preventDefault();
    if (e1.target == _selector.group) {
        _selector.modalGroup.style.display = "block";
        window.addEventListener('click', (e)=>{
            if (e.target == _selector.modalGroup || e.target == _selector.groupCloseBtn) _selector.modalGroup.style.display = "none";
        });
    }
};
exports.default = groupModalView;

},{"./selector":"cjxTH","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cjxTH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "group", ()=>group
);
parcelHelpers.export(exports, "modalGroup", ()=>modalGroup
);
parcelHelpers.export(exports, "groupCloseBtn", ()=>groupCloseBtn
);
parcelHelpers.export(exports, "task", ()=>task
);
parcelHelpers.export(exports, "modalTask", ()=>modalTask
);
parcelHelpers.export(exports, "taskCloseBtn", ()=>taskCloseBtn
);
parcelHelpers.export(exports, "btnCreateGroup", ()=>btnCreateGroup
);
parcelHelpers.export(exports, "colorValue", ()=>colorValue
);
parcelHelpers.export(exports, "groupName", ()=>groupName
);
parcelHelpers.export(exports, "groupTitle", ()=>groupTitle
);
parcelHelpers.export(exports, "groupLegend", ()=>groupLegend
);
parcelHelpers.export(exports, "groupLegendValue", ()=>groupLegendValue
);
parcelHelpers.export(exports, "groupItem", ()=>groupItem
);
parcelHelpers.export(exports, "btnCreateTask", ()=>btnCreateTask
);
parcelHelpers.export(exports, "taskName", ()=>taskName
);
const group = document.querySelector('.constructor__group'), modalGroup = document.querySelector('.modal-group'), groupCloseBtn = document.querySelector('.group-btn'), task = document.querySelector('.constructor__task'), modalTask = document.querySelector('.modal-task'), taskCloseBtn = document.querySelector('.task-btn'), btnCreateGroup = document.querySelector('.create-group'), colorValue = document.querySelector('#color'), groupName = document.querySelector('#group-name'), groupTitle = document.querySelector('.group__title'), groupLegend = document.querySelector('.group__legend'), groupLegendValue = document.querySelector('legend'), groupItem = document.querySelector('.group__item'), btnCreateTask = document.querySelector('.create__task'), taskName = document.querySelector('.modal-task__value');

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"4vgkK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _selector = require("./selector");
const taskModalView = (e1)=>{
    e1.preventDefault();
    if (e1.target == _selector.task) {
        _selector.modalTask.style.display = 'block';
        window.addEventListener('click', (e)=>{
            if (e.target == _selector.modalTask || e.target == _selector.taskCloseBtn) _selector.modalTask.style.display = "none";
        });
    }
};
exports.default = taskModalView;

},{"./selector":"cjxTH","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"92WVk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createGroup", ()=>createGroup
);
parcelHelpers.export(exports, "showGroup", ()=>showGroup
);
var _prettier = require("prettier");
var _selector = require("./selector");
let groupObj, localItems = JSON.parse(localStorage.getItem('local')) || {
};
const createGroup = function(e) {
    e.preventDefault();
    if (_selector.groupName.value === '') return alert('Please, write group name');
    groupObj = {
        name: _selector.groupName.value,
        color: _selector.colorValue.value,
        tasks: []
    };
    showGroup(groupObj);
    renderNewGroup();
};
const renderNewGroup = ()=>{
    addToLocalStorage(groupObj);
    _selector.colorValue.value = '#000000';
    _selector.groupName.value = '';
    _selector.modalGroup.style.display = 'none';
};
const addToLocalStorage = (groupObj1)=>{
    let groupList = document.querySelectorAll('.group-list'), groupIndex = null;
    groupList.forEach((el, ind)=>{
        if (el.value === groupObj1.name) groupIndex = ind;
    });
    if (groupIndex != null) localItems[`${groupIndex}`] = groupObj1;
    localStorage.setItem('local', JSON.stringify(localItems));
};
const showGroup = (groupObj2 = null)=>{
    const modalSelect = document.querySelector('.modal-task__select');
    let groupsList = Object.keys(localItems).map(function(key) {
        return localItems[key];
    }) || [], selectGroup, groupBlock = '';
    if (groupObj2) groupsList.push(groupObj2);
    for(let index1 in groupsList)groupBlock += `
    <div class="group__items">
      <div class="group__name">
        <fieldset style="background-color:${groupsList[index1].color}" class="group__legend legend">
          <legend >Group</legend>
            <h2 class="group__title">${groupsList[index1].name}</h2>
        </fieldset>
      </div>
     <button class="delete group__delete"><i class="far fa-trash-alt"></i></button>
    </div>
    `;
    _selector.groupItem.innerHTML = groupBlock;
    groupsList.forEach((element, index)=>{
        selectGroup += `<option class = 'group-list' data-id =${index}>${element.name}</option>`;
    });
    modalSelect.innerHTML = selectGroup;
};

},{"prettier":"bNFxi","./selector":"cjxTH","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bNFxi":[function(require,module,exports) {
var global = arguments[3];
!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).prettier = t();
}(this, function() {
    "use strict";
    var e7 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {
    };
    function t3(e) {
        return e && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }
    var n2 = {
        version: "2.5.1"
    }, r1 = {
    }, o1 = {
    };
    !function(e8) {
        function t4() {
        }
        function n3(e9, t, n4, r, o) {
            for(var i = 0, u = t.length, s = 0, a = 0; i < u; i++){
                var c = t[i];
                if (c.removed) {
                    if (c.value = e9.join(r.slice(a, a + c.count)), a += c.count, i && t[i - 1].added) {
                        var l = t[i - 1];
                        t[i - 1] = t[i], t[i] = l;
                    }
                } else {
                    if (!c.added && o) {
                        var p = n4.slice(s, s + c.count);
                        p = p.map(function(e, t) {
                            var n = r[a + t];
                            return n.length > e.length ? n : e;
                        }), c.value = e9.join(p);
                    } else c.value = e9.join(n4.slice(s, s + c.count));
                    s += c.count, c.added || (a += c.count);
                }
            }
            var f = t[u - 1];
            return u > 1 && "string" == typeof f.value && (f.added || f.removed) && e9.equals("", f.value) && (t[u - 2].value += f.value, t.pop()), t;
        }
        function r2(e) {
            return {
                newPos: e.newPos,
                components: e.components.slice(0)
            };
        }
        Object.defineProperty(e8, "__esModule", {
            value: !0
        }), e8.default = t4, t4.prototype = {
            diff: function(e10, t) {
                var o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                }, i2 = o2.callback;
                "function" == typeof o2 && (i2 = o2, o2 = {
                }), this.options = o2;
                var u = this;
                function s(e) {
                    return i2 ? (setTimeout(function() {
                        i2(void 0, e);
                    }, 0), !0) : e;
                }
                e10 = this.castInput(e10), t = this.castInput(t), e10 = this.removeEmpty(this.tokenize(e10));
                var a = (t = this.removeEmpty(this.tokenize(t))).length, c = e10.length, l = 1, p2 = a + c, f = [
                    {
                        newPos: -1,
                        components: []
                    }
                ], d2 = this.extractCommon(f[0], t, e10, 0);
                if (f[0].newPos + 1 >= a && d2 + 1 >= c) return s([
                    {
                        value: this.join(t),
                        count: t.length
                    }
                ]);
                function h2() {
                    for(var o = -1 * l; o <= l; o += 2){
                        var i = void 0, p = f[o - 1], d = f[o + 1], h = (d ? d.newPos : 0) - o;
                        p && (f[o - 1] = void 0);
                        var g = p && p.newPos + 1 < a, m = d && 0 <= h && h < c;
                        if (g || m) {
                            if (!g || m && p.newPos < d.newPos ? (i = r2(d), u.pushComponent(i.components, void 0, !0)) : ((i = p).newPos++, u.pushComponent(i.components, !0, void 0)), h = u.extractCommon(i, t, e10, o), i.newPos + 1 >= a && h + 1 >= c) return s(n3(u, i.components, t, e10, u.useLongestToken));
                            f[o] = i;
                        } else f[o] = void 0;
                    }
                    l++;
                }
                if (i2) !function e() {
                    setTimeout(function() {
                        if (l > p2) return i2();
                        h2() || e();
                    }, 0);
                }();
                else for(; l <= p2;){
                    var g2 = h2();
                    if (g2) return g2;
                }
            },
            pushComponent: function(e, t, n) {
                var r = e[e.length - 1];
                r && r.added === t && r.removed === n ? e[e.length - 1] = {
                    count: r.count + 1,
                    added: t,
                    removed: n
                } : e.push({
                    count: 1,
                    added: t,
                    removed: n
                });
            },
            extractCommon: function(e, t, n, r) {
                for(var o = t.length, i = n.length, u = e.newPos, s = u - r, a = 0; u + 1 < o && s + 1 < i && this.equals(t[u + 1], n[s + 1]);)u++, s++, a++;
                return a && e.components.push({
                    count: a
                }), e.newPos = u, s;
            },
            equals: function(e, t) {
                return this.options.comparator ? this.options.comparator(e, t) : e === t || this.options.ignoreCase && e.toLowerCase() === t.toLowerCase();
            },
            removeEmpty: function(e) {
                for(var t = [], n = 0; n < e.length; n++)e[n] && t.push(e[n]);
                return t;
            },
            castInput: function(e) {
                return e;
            },
            tokenize: function(e) {
                return e.split("");
            },
            join: function(e) {
                return e.join("");
            }
        };
    }(o1);
    var i1, u1 = {
    };
    Object.defineProperty(u1, "__esModule", {
        value: !0
    }), u1.diffChars = function(e, t, n) {
        return s1.diff(e, t, n);
    }, u1.characterDiff = void 0;
    var s1 = new ((i1 = o1) && i1.__esModule ? i1 : {
        default: i1
    }).default;
    u1.characterDiff = s1;
    var a1 = {
    }, c1 = {
    };
    Object.defineProperty(c1, "__esModule", {
        value: !0
    }), c1.generateOptions = function(e, t) {
        if ("function" == typeof e) t.callback = e;
        else if (e) for(var n in e)e.hasOwnProperty(n) && (t[n] = e[n]);
        return t;
    }, Object.defineProperty(a1, "__esModule", {
        value: !0
    }), a1.diffWords = function(e, t, n) {
        return n = (0, p1.generateOptions)(n, {
            ignoreWhitespace: !0
        }), h1.diff(e, t, n);
    }, a1.diffWordsWithSpace = function(e, t, n) {
        return h1.diff(e, t, n);
    }, a1.wordDiff = void 0;
    var l1 = function(e) {
        return e && e.__esModule ? e : {
            default: e
        };
    }(o1), p1 = c1;
    var f1 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, d1 = /\S/, h1 = new l1.default;
    a1.wordDiff = h1, h1.equals = function(e, t) {
        return this.options.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e === t || this.options.ignoreWhitespace && !d1.test(e) && !d1.test(t);
    }, h1.tokenize = function(e) {
        for(var t = e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n = 0; n < t.length - 1; n++)!t[n + 1] && t[n + 2] && f1.test(t[n]) && f1.test(t[n + 2]) && (t[n] += t[n + 2], t.splice(n + 1, 2), n--);
        return t;
    };
    var g1 = {
    };
    Object.defineProperty(g1, "__esModule", {
        value: !0
    }), g1.diffLines = function(e, t, n) {
        return D1.diff(e, t, n);
    }, g1.diffTrimmedLines = function(e, t, n) {
        var r = (0, y1.generateOptions)(n, {
            ignoreWhitespace: !0
        });
        return D1.diff(e, t, r);
    }, g1.lineDiff = void 0;
    var m1 = function(e) {
        return e && e.__esModule ? e : {
            default: e
        };
    }(o1), y1 = c1;
    var D1 = new m1.default;
    g1.lineDiff = D1, D1.tokenize = function(e) {
        var t = [], n = e.split(/(\n|\r\n)/);
        n[n.length - 1] || n.pop();
        for(var r = 0; r < n.length; r++){
            var o = n[r];
            r % 2 && !this.options.newlineIsToken ? t[t.length - 1] += o : (this.options.ignoreWhitespace && (o = o.trim()), t.push(o));
        }
        return t;
    };
    var E1 = {
    };
    Object.defineProperty(E1, "__esModule", {
        value: !0
    }), E1.diffSentences = function(e, t, n) {
        return b1.diff(e, t, n);
    }, E1.sentenceDiff = void 0;
    var C1 = function(e) {
        return e && e.__esModule ? e : {
            default: e
        };
    }(o1);
    var b1 = new C1.default;
    E1.sentenceDiff = b1, b1.tokenize = function(e) {
        return e.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    var v1 = {
    };
    Object.defineProperty(v1, "__esModule", {
        value: !0
    }), v1.diffCss = function(e, t, n) {
        return F1.diff(e, t, n);
    }, v1.cssDiff = void 0;
    var A1 = function(e) {
        return e && e.__esModule ? e : {
            default: e
        };
    }(o1);
    var F1 = new A1.default;
    v1.cssDiff = F1, F1.tokenize = function(e) {
        return e.split(/([{}:;,]|\s+)/);
    };
    var x1 = function(e) {
        return e && e.Math == Math && e;
    }, S1 = x1("object" == typeof globalThis && globalThis) || x1("object" == typeof window && window) || x1("object" == typeof self && self) || x1("object" == typeof e7 && e7) || function() {
        return this;
    }() || Function("return this")(), w1 = {
    }, T1 = function(e) {
        try {
            return !!e();
        } catch (e11) {
            return !0;
        }
    }, B1 = !T1(function() {
        return 7 != Object.defineProperty({
        }, 1, {
            get: function() {
                return 7;
            }
        })[1];
    }), N1 = Function.prototype.call, k = N1.bind ? N1.bind(N1) : function() {
        return N1.apply(N1, arguments);
    }, P = {
    }, O = {
    }.propertyIsEnumerable, I = Object.getOwnPropertyDescriptor, L = I && !O.call({
        1: 2
    }, 1);
    P.f = L ? function(e) {
        var t = I(this, e);
        return !!t && t.enumerable;
    } : O;
    var j, _, M = function(e, t) {
        return {
            enumerable: !(1 & e),
            configurable: !(2 & e),
            writable: !(4 & e),
            value: t
        };
    }, R = Function.prototype, V = R.bind, $ = R.call, W = V && V.bind($), q = V ? function(e) {
        return e && W($, e);
    } : function(e) {
        return e && function() {
            return $.apply(e, arguments);
        };
    }, U = q, z = U({
    }.toString), G = U("".slice), H = function(e) {
        return G(z(e), 8, -1);
    }, J = q, X = T1, Y = H, K = S1.Object, Q = J("".split), Z = X(function() {
        return !K("z").propertyIsEnumerable(0);
    }) ? function(e) {
        return "String" == Y(e) ? Q(e, "") : K(e);
    } : K, ee = S1.TypeError, te = function(e) {
        if (null == e) throw ee("Can't call method on " + e);
        return e;
    }, ne = Z, re = te, oe = function(e) {
        return ne(re(e));
    }, ie = function(e) {
        return "function" == typeof e;
    }, ue = ie, se = function(e) {
        return "object" == typeof e ? null !== e : ue(e);
    }, ae = S1, ce = ie, le = function(e) {
        return ce(e) ? e : void 0;
    }, pe = function(e, t) {
        return arguments.length < 2 ? le(ae[e]) : ae[e] && ae[e][t];
    }, fe = q({
    }.isPrototypeOf), de = pe("navigator", "userAgent") || "", he = S1, ge = de, me = he.process, ye = he.Deno, De = me && me.versions || ye && ye.version, Ee = De && De.v8;
    Ee && (_ = (j = Ee.split("."))[0] > 0 && j[0] < 4 ? 1 : +(j[0] + j[1])), !_ && ge && (!(j = ge.match(/Edge\/(\d+)/)) || j[1] >= 74) && (j = ge.match(/Chrome\/(\d+)/)) && (_ = +j[1]);
    var Ce = _, be = Ce, ve = T1, Ae = !!Object.getOwnPropertySymbols && !ve(function() {
        var e = Symbol();
        return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && be && be < 41;
    }), Fe = Ae && !Symbol.sham && "symbol" == typeof Symbol.iterator, xe = pe, Se = ie, we = fe, Te = Fe, Be = S1.Object, Ne = Te ? function(e) {
        return "symbol" == typeof e;
    } : function(e) {
        var t = xe("Symbol");
        return Se(t) && we(t.prototype, Be(e));
    }, ke = S1.String, Pe = function(e) {
        try {
            return ke(e);
        } catch (e12) {
            return "Object";
        }
    }, Oe = ie, Ie = Pe, Le = S1.TypeError, je = function(e) {
        if (Oe(e)) return e;
        throw Le(Ie(e) + " is not a function");
    }, _e = je, Me = function(e, t) {
        var n = e[t];
        return null == n ? void 0 : _e(n);
    }, Re = k, Ve = ie, $e = se, We = S1.TypeError, qe = {
        exports: {
        }
    }, Ue = S1, ze = Object.defineProperty, Ge = function(e, t) {
        try {
            ze(Ue, e, {
                value: t,
                configurable: !0,
                writable: !0
            });
        } catch (n) {
            Ue[e] = t;
        }
        return t;
    }, He = Ge, Je = "__core-js_shared__", Xe = S1[Je] || He(Je, {
    }), Ye = Xe;
    (qe.exports = function(e, t) {
        return Ye[e] || (Ye[e] = void 0 !== t ? t : {
        });
    })("versions", []).push({
        version: "3.19.1",
        mode: "global",
        copyright: "\xa9 2021 Denis Pushkarev (zloirock.ru)"
    });
    var Ke = te, Qe = S1.Object, Ze = function(e) {
        return Qe(Ke(e));
    }, et = Ze, tt = q({
    }.hasOwnProperty), nt = Object.hasOwn || function(e, t) {
        return tt(et(e), t);
    }, rt = q, ot = 0, it = Math.random(), ut = rt(1..toString), st = function(e) {
        return "Symbol(" + (void 0 === e ? "" : e) + ")_" + ut(++ot + it, 36);
    }, at = S1, ct = qe.exports, lt = nt, pt = st, ft = Ae, dt = Fe, ht = ct("wks"), gt = at.Symbol, mt = gt && gt.for, yt = dt ? gt : gt && gt.withoutSetter || pt, Dt = function(e) {
        if (!lt(ht, e) || !ft && "string" != typeof ht[e]) {
            var t = "Symbol." + e;
            ft && lt(gt, e) ? ht[e] = gt[e] : ht[e] = dt && mt ? mt(t) : yt(t);
        }
        return ht[e];
    }, Et = k, Ct = se, bt = Ne, vt = Me, At = function(e, t) {
        var n, r;
        if ("string" === t && Ve(n = e.toString) && !$e(r = Re(n, e))) return r;
        if (Ve(n = e.valueOf) && !$e(r = Re(n, e))) return r;
        if ("string" !== t && Ve(n = e.toString) && !$e(r = Re(n, e))) return r;
        throw We("Can't convert object to primitive value");
    }, Ft = Dt, xt = S1.TypeError, St = Ft("toPrimitive"), wt = function(e, t) {
        if (!Ct(e) || bt(e)) return e;
        var n, r = vt(e, St);
        if (r) {
            if (void 0 === t && (t = "default"), n = Et(r, e, t), !Ct(n) || bt(n)) return n;
            throw xt("Can't convert object to primitive value");
        }
        return void 0 === t && (t = "number"), At(e, t);
    }, Tt = Ne, Bt = function(e) {
        var t = wt(e, "string");
        return Tt(t) ? t : t + "";
    }, Nt = se, kt = S1.document, Pt = Nt(kt) && Nt(kt.createElement), Ot = function(e) {
        return Pt ? kt.createElement(e) : {
        };
    }, It = Ot, Lt = !B1 && !T1(function() {
        return 7 != Object.defineProperty(It("div"), "a", {
            get: function() {
                return 7;
            }
        }).a;
    }), jt = B1, _t = k, Mt = P, Rt = M, Vt = oe, $t = Bt, Wt = nt, qt = Lt, Ut = Object.getOwnPropertyDescriptor;
    w1.f = jt ? Ut : function(e, t) {
        if (e = Vt(e), t = $t(t), qt) try {
            return Ut(e, t);
        } catch (e13) {
        }
        if (Wt(e, t)) return Rt(!_t(Mt.f, e, t), e[t]);
    };
    var zt = {
    }, Gt = S1, Ht = se, Jt = Gt.String, Xt = Gt.TypeError, Yt = function(e) {
        if (Ht(e)) return e;
        throw Xt(Jt(e) + " is not an object");
    }, Kt = B1, Qt = Lt, Zt = Yt, en = Bt, tn = S1.TypeError, nn = Object.defineProperty;
    zt.f = Kt ? nn : function(e, t, n) {
        if (Zt(e), t = en(t), Zt(n), Qt) try {
            return nn(e, t, n);
        } catch (e14) {
        }
        if ("get" in n || "set" in n) throw tn("Accessors not supported");
        return "value" in n && (e[t] = n.value), e;
    };
    var rn = zt, on = M, un = B1 ? function(e, t, n) {
        return rn.f(e, t, on(1, n));
    } : function(e, t, n) {
        return e[t] = n, e;
    }, sn = {
        exports: {
        }
    }, an = ie, cn = Xe, ln = q(Function.toString);
    an(cn.inspectSource) || (cn.inspectSource = function(e) {
        return ln(e);
    });
    var pn, fn, dn, hn = cn.inspectSource, gn = ie, mn = hn, yn = S1.WeakMap, Dn = gn(yn) && /native code/.test(mn(yn)), En = qe.exports, Cn = st, bn = En("keys"), vn = function(e) {
        return bn[e] || (bn[e] = Cn(e));
    }, An = {
    }, Fn = Dn, xn = S1, Sn = q, wn = se, Tn = un, Bn = nt, Nn = Xe, kn = vn, Pn = An, On = "Object already initialized", In = xn.TypeError, Ln = xn.WeakMap;
    if (Fn || Nn.state) {
        var jn = Nn.state || (Nn.state = new Ln), _n = Sn(jn.get), Mn = Sn(jn.has), Rn = Sn(jn.set);
        pn = function(e, t) {
            if (Mn(jn, e)) throw new In(On);
            return t.facade = e, Rn(jn, e, t), t;
        }, fn = function(e) {
            return _n(jn, e) || {
            };
        }, dn = function(e) {
            return Mn(jn, e);
        };
    } else {
        var Vn = kn("state");
        Pn[Vn] = !0, pn = function(e, t) {
            if (Bn(e, Vn)) throw new In(On);
            return t.facade = e, Tn(e, Vn, t), t;
        }, fn = function(e) {
            return Bn(e, Vn) ? e[Vn] : {
            };
        }, dn = function(e) {
            return Bn(e, Vn);
        };
    }
    var $n = {
        set: pn,
        get: fn,
        has: dn,
        enforce: function(e) {
            return dn(e) ? fn(e) : pn(e, {
            });
        },
        getterFor: function(e) {
            return function(t) {
                var n;
                if (!wn(t) || (n = fn(t)).type !== e) throw In("Incompatible receiver, " + e + " required");
                return n;
            };
        }
    }, Wn = B1, qn = nt, Un = Function.prototype, zn = Wn && Object.getOwnPropertyDescriptor, Gn = qn(Un, "name"), Hn = Gn && "something" === (function() {
    }).name, Jn = Gn && (!Wn || Wn && zn(Un, "name").configurable), Xn = S1, Yn = ie, Kn = nt, Qn = un, Zn = Ge, er = hn, tr = {
        EXISTS: Gn,
        PROPER: Hn,
        CONFIGURABLE: Jn
    }.CONFIGURABLE, nr = $n.get, rr = $n.enforce, or = String(String).split("String");
    (sn.exports = function(e, t, n, r) {
        var o, i = !!r && !!r.unsafe, u = !!r && !!r.enumerable, s = !!r && !!r.noTargetGet, a = r && void 0 !== r.name ? r.name : t;
        Yn(n) && ("Symbol(" === String(a).slice(0, 7) && (a = "[" + String(a).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Kn(n, "name") || tr && n.name !== a) && Qn(n, "name", a), (o = rr(n)).source || (o.source = or.join("string" == typeof a ? a : ""))), e !== Xn ? (i ? !s && e[t] && (u = !0) : delete e[t], u ? e[t] = n : Qn(e, t, n)) : u ? e[t] = n : Zn(t, n);
    })(Function.prototype, "toString", function() {
        return Yn(this) && nr(this).source || er(this);
    });
    var ir = {
    }, ur = Math.ceil, sr = Math.floor, ar = function(e) {
        var t = +e;
        return t != t || 0 === t ? 0 : (t > 0 ? sr : ur)(t);
    }, cr = ar, lr = Math.max, pr = Math.min, fr = ar, dr = Math.min, hr = function(e) {
        return e > 0 ? dr(fr(e), 9007199254740991) : 0;
    }, gr = function(e) {
        return hr(e.length);
    }, mr = oe, yr = function(e, t) {
        var n = cr(e);
        return n < 0 ? lr(n + t, 0) : pr(n, t);
    }, Dr = gr, Er = function(e) {
        return function(t, n, r) {
            var o, i = mr(t), u = Dr(i), s = yr(r, u);
            if (e && n != n) {
                for(; u > s;)if ((o = i[s++]) != o) return !0;
            } else for(; u > s; s++)if ((e || s in i) && i[s] === n) return e || s || 0;
            return !e && -1;
        };
    }, Cr = {
        includes: Er(!0),
        indexOf: Er(!1)
    }, br = nt, vr = oe, Ar = Cr.indexOf, Fr = An, xr = q([].push), Sr = function(e, t) {
        var n, r = vr(e), o = 0, i = [];
        for(n in r)!br(Fr, n) && br(r, n) && xr(i, n);
        for(; t.length > o;)br(r, n = t[o++]) && (~Ar(i, n) || xr(i, n));
        return i;
    }, wr = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
    ], Tr = Sr, Br = wr.concat("length", "prototype");
    ir.f = Object.getOwnPropertyNames || function(e) {
        return Tr(e, Br);
    };
    var Nr = {
    };
    Nr.f = Object.getOwnPropertySymbols;
    var kr = pe, Pr = ir, Or = Nr, Ir = Yt, Lr = q([].concat), jr = kr("Reflect", "ownKeys") || function(e) {
        var t = Pr.f(Ir(e)), n = Or.f;
        return n ? Lr(t, n(e)) : t;
    }, _r = nt, Mr = jr, Rr = w1, Vr = zt, $r = T1, Wr = ie, qr = /#|\.prototype\./, Ur = function(e, t) {
        var n = Gr[zr(e)];
        return n == Jr || n != Hr && (Wr(t) ? $r(t) : !!t);
    }, zr = Ur.normalize = function(e) {
        return String(e).replace(qr, ".").toLowerCase();
    }, Gr = Ur.data = {
    }, Hr = Ur.NATIVE = "N", Jr = Ur.POLYFILL = "P", Xr = Ur, Yr = S1, Kr = w1.f, Qr = un, Zr = sn.exports, eo = Ge, to = function(e, t) {
        for(var n = Mr(t), r = Vr.f, o = Rr.f, i = 0; i < n.length; i++){
            var u = n[i];
            _r(e, u) || r(e, u, o(t, u));
        }
    }, no = Xr, ro = function(e, t) {
        var n, r, o, i, u, s = e.target, a = e.global, c = e.stat;
        if (n = a ? Yr : c ? Yr[s] || eo(s, {
        }) : (Yr[s] || {
        }).prototype) for(r in t){
            if (i = t[r], o = e.noTargetGet ? (u = Kr(n, r)) && u.value : n[r], !no(a ? r : s + (c ? "." : "#") + r, e.forced) && void 0 !== o) {
                if (typeof i == typeof o) continue;
                to(i, o);
            }
            (e.sham || o && o.sham) && Qr(i, "sham", !0), Zr(n, r, i, e);
        }
    }, oo = {
    };
    oo[Dt("toStringTag")] = "z";
    var io = S1, uo = "[object z]" === String(oo), so = ie, ao = H, co = Dt("toStringTag"), lo = io.Object, po = "Arguments" == ao(function() {
        return arguments;
    }()), fo = uo ? ao : function(e15) {
        var t, n, r;
        return void 0 === e15 ? "Undefined" : null === e15 ? "Null" : "string" == typeof (n = function(e, t) {
            try {
                return e[t];
            } catch (e16) {
            }
        }(t = lo(e15), co)) ? n : po ? ao(t) : "Object" == (r = ao(t)) && so(t.callee) ? "Arguments" : r;
    }, ho = fo, go = S1.String, mo = q([].slice), yo = Math.floor, Do = function(e, t) {
        var n = e.length, r = yo(n / 2);
        return n < 8 ? Eo(e, t) : Co(e, Do(mo(e, 0, r), t), Do(mo(e, r), t), t);
    }, Eo = function(e, t) {
        for(var n, r, o = e.length, i = 1; i < o;){
            for(r = i, n = e[i]; r && t(e[r - 1], n) > 0;)e[r] = e[--r];
            r !== i++ && (e[r] = n);
        }
        return e;
    }, Co = function(e, t, n, r) {
        for(var o = t.length, i = n.length, u = 0, s = 0; u < o || s < i;)e[u + s] = u < o && s < i ? r(t[u], n[s]) <= 0 ? t[u++] : n[s++] : u < o ? t[u++] : n[s++];
        return e;
    }, bo = Do, vo = T1, Ao = de.match(/firefox\/(\d+)/i), Fo = !!Ao && +Ao[1], xo = /MSIE|Trident/.test(de), So = de.match(/AppleWebKit\/(\d+)\./), wo = !!So && +So[1], To = ro, Bo = q, No = je, ko = Ze, Po = gr, Oo = function(e) {
        if ("Symbol" === ho(e)) throw TypeError("Cannot convert a Symbol value to a string");
        return go(e);
    }, Io = T1, Lo = bo, jo = function(e, t) {
        var n = [][e];
        return !!n && vo(function() {
            n.call(null, t || function() {
                throw 1;
            }, 1);
        });
    }, _o = Fo, Mo = xo, Ro = Ce, Vo = wo, $o = [], Wo = Bo($o.sort), qo = Bo($o.push), Uo = Io(function() {
        $o.sort(void 0);
    }), zo = Io(function() {
        $o.sort(null);
    }), Go = jo("sort"), Ho = !Io(function() {
        if (Ro) return Ro < 70;
        if (!(_o && _o > 3)) {
            if (Mo) return !0;
            if (Vo) return Vo < 603;
            var e17, t5, n, r, o = "";
            for(e17 = 65; e17 < 76; e17++){
                switch(t5 = String.fromCharCode(e17), e17){
                    case 66:
                    case 69:
                    case 70:
                    case 72:
                        n = 3;
                        break;
                    case 68:
                    case 71:
                        n = 4;
                        break;
                    default:
                        n = 2;
                }
                for(r = 0; r < 47; r++)$o.push({
                    k: t5 + r,
                    v: n
                });
            }
            for($o.sort(function(e, t) {
                return t.v - e.v;
            }), r = 0; r < $o.length; r++)t5 = $o[r].k.charAt(0), o.charAt(o.length - 1) !== t5 && (o += t5);
            return "DGBEFHACIJK" !== o;
        }
    });
    To({
        target: "Array",
        proto: !0,
        forced: Uo || !zo || !Go || !Ho
    }, {
        sort: function(e19) {
            void 0 !== e19 && No(e19);
            var t7 = ko(this);
            if (Ho) return void 0 === e19 ? Wo(t7) : Wo(t7, e19);
            var n5, r, o = [], i = Po(t7);
            for(r = 0; r < i; r++)r in t7 && qo(o, t7[r]);
            for(Lo(o, function(e) {
                return function(t, n) {
                    return void 0 === n ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, n) || 0 : Oo(t) > Oo(n) ? 1 : -1;
                };
            }(e19)), n5 = o.length, r = 0; r < n5;)t7[r] = o[r++];
            for(; r < i;)delete t7[r++];
            return t7;
        }
    });
    var Jo = {
    };
    Object.defineProperty(Jo, "__esModule", {
        value: !0
    }), Jo.diffJson = function(e, t, n) {
        return Zo.diff(e, t, n);
    }, Jo.canonicalize = ei, Jo.jsonDiff = void 0;
    var Xo = function(e) {
        return e && e.__esModule ? e : {
            default: e
        };
    }(o1), Yo = g1;
    function Ko(e20) {
        return Ko = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e;
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        }, Ko(e20);
    }
    var Qo = Object.prototype.toString, Zo = new Xo.default;
    function ei(e, t, n, r, o) {
        var i, u;
        for(t = t || [], n = n || [], r && (e = r(o, e)), i = 0; i < t.length; i += 1)if (t[i] === e) return n[i];
        if ("[object Array]" === Qo.call(e)) {
            for(t.push(e), u = new Array(e.length), n.push(u), i = 0; i < e.length; i += 1)u[i] = ei(e[i], t, n, r, o);
            return t.pop(), n.pop(), u;
        }
        if (e && e.toJSON && (e = e.toJSON()), "object" === Ko(e) && null !== e) {
            t.push(e), u = {
            }, n.push(u);
            var s, a = [];
            for(s in e)e.hasOwnProperty(s) && a.push(s);
            for(a.sort(), i = 0; i < a.length; i += 1)u[s = a[i]] = ei(e[s], t, n, r, s);
            t.pop(), n.pop();
        } else u = e;
        return u;
    }
    Jo.jsonDiff = Zo, Zo.useLongestToken = !0, Zo.tokenize = Yo.lineDiff.tokenize, Zo.castInput = function(e) {
        var t8 = this.options, n = t8.undefinedReplacement, r = t8.stringifyReplacer, o = void 0 === r ? function(e, t) {
            return void 0 === t ? n : t;
        } : r;
        return "string" == typeof e ? e : JSON.stringify(ei(e, null, null, o), o, "  ");
    }, Zo.equals = function(e, t) {
        return Xo.default.prototype.equals.call(Zo, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"));
    };
    var ti = {
    };
    Object.defineProperty(ti, "__esModule", {
        value: !0
    }), ti.diffArrays = function(e, t, n) {
        return ri.diff(e, t, n);
    }, ti.arrayDiff = void 0;
    var ni = function(e) {
        return e && e.__esModule ? e : {
            default: e
        };
    }(o1);
    var ri = new ni.default;
    ti.arrayDiff = ri, ri.tokenize = function(e) {
        return e.slice();
    }, ri.join = ri.removeEmpty = function(e) {
        return e;
    };
    var oi = {
    }, ii = {
    };
    Object.defineProperty(ii, "__esModule", {
        value: !0
    }), ii.parsePatch = function(e21) {
        var t9 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
        }, n = e21.split(/\r\n|[\n\v\f\r\x85]/), r3 = e21.match(/\r\n|[\n\v\f\r\x85]/g) || [], o3 = [], i = 0;
        function u2() {
            var e = {
            };
            for(o3.push(e); i < n.length;){
                var r = n[i];
                if (/^(\-\-\-|\+\+\+|@@)\s/.test(r)) break;
                var u = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r);
                u && (e.index = u[1]), i++;
            }
            for(s2(e), s2(e), e.hunks = []; i < n.length;){
                var c = n[i];
                if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c)) break;
                if (/^@@/.test(c)) e.hunks.push(a2());
                else {
                    if (c && t9.strict) throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(c));
                    i++;
                }
            }
        }
        function s2(e) {
            var t = /^(---|\+\+\+)\s+(.*)$/.exec(n[i]);
            if (t) {
                var r = "---" === t[1] ? "old" : "new", o = t[2].split("\t", 2), u = o[0].replace(/\\\\/g, "\\");
                /^".*"$/.test(u) && (u = u.substr(1, u.length - 2)), e[r + "FileName"] = u, e[r + "Header"] = (o[1] || "").trim(), i++;
            }
        }
        function a2() {
            var e = i, o = n[i++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), u = {
                oldStart: +o[1],
                oldLines: void 0 === o[2] ? 1 : +o[2],
                newStart: +o[3],
                newLines: void 0 === o[4] ? 1 : +o[4],
                lines: [],
                linedelimiters: []
            };
            0 === u.oldLines && (u.oldStart += 1), 0 === u.newLines && (u.newStart += 1);
            for(var s = 0, a = 0; i < n.length && !(0 === n[i].indexOf("--- ") && i + 2 < n.length && 0 === n[i + 1].indexOf("+++ ") && 0 === n[i + 2].indexOf("@@")); i++){
                var c = 0 == n[i].length && i != n.length - 1 ? " " : n[i][0];
                if ("+" !== c && "-" !== c && " " !== c && "\\" !== c) break;
                u.lines.push(n[i]), u.linedelimiters.push(r3[i] || "\n"), "+" === c ? s++ : "-" === c ? a++ : " " === c && (s++, a++);
            }
            if (s || 1 !== u.newLines || (u.newLines = 0), a || 1 !== u.oldLines || (u.oldLines = 0), t9.strict) {
                if (s !== u.newLines) throw new Error("Added line count did not match for hunk at line " + (e + 1));
                if (a !== u.oldLines) throw new Error("Removed line count did not match for hunk at line " + (e + 1));
            }
            return u;
        }
        for(; i < n.length;)u2();
        return o3;
    };
    var ui = {
    };
    !function(e22) {
        Object.defineProperty(e22, "__esModule", {
            value: !0
        }), e22.default = function(e, t, n) {
            var r = !0, o = !1, i = !1, u = 1;
            return function s() {
                if (r && !i) {
                    if (o ? u++ : r = !1, e + u <= n) return u;
                    i = !0;
                }
                if (!o) return i || (r = !0), t <= e - u ? -u++ : (o = !0, s());
            };
        };
    }(ui), Object.defineProperty(oi, "__esModule", {
        value: !0
    }), oi.applyPatch = ci, oi.applyPatches = function(e23, t) {
        "string" == typeof e23 && (e23 = (0, si.parsePatch)(e23));
        var n6 = 0;
        !function r() {
            var o = e23[n6++];
            if (!o) return t.complete();
            t.loadFile(o, function(e24, n) {
                if (e24) return t.complete(e24);
                var i = ci(n, o, t);
                t.patched(o, i, function(e) {
                    if (e) return t.complete(e);
                    r();
                });
            });
        }();
    };
    var si = ii, ai = function(e) {
        return e && e.__esModule ? e : {
            default: e
        };
    }(ui);
    function ci(e25, t10) {
        var n7 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
        };
        if ("string" == typeof t10 && (t10 = (0, si.parsePatch)(t10)), Array.isArray(t10)) {
            if (t10.length > 1) throw new Error("applyPatch only works with a single input.");
            t10 = t10[0];
        }
        var r4, o4, i = e25.split(/\r\n|[\n\v\f\r\x85]/), u3 = e25.match(/\r\n|[\n\v\f\r\x85]/g) || [], s = t10.hunks, a = n7.compareLine || function(e, t, n, r) {
            return t === r;
        }, c = 0, l = n7.fuzzFactor || 0, p = 0, f = 0;
        function d(e, t) {
            for(var n = 0; n < e.lines.length; n++){
                var r = e.lines[n], o = r.length > 0 ? r[0] : " ", u = r.length > 0 ? r.substr(1) : r;
                if (" " === o || "-" === o) {
                    if (!a(t + 1, i[t], o, u) && ++c > l) return !1;
                    t++;
                }
            }
            return !0;
        }
        for(var h = 0; h < s.length; h++){
            for(var g = s[h], m = i.length - g.oldLines, y = 0, D = f + g.oldStart - 1, E = (0, ai.default)(D, p, m); void 0 !== y; y = E())if (d(g, D + y)) {
                g.offset = f += y;
                break;
            }
            if (void 0 === y) return !1;
            p = g.offset + g.oldStart + g.oldLines;
        }
        for(var C = 0, b = 0; b < s.length; b++){
            var v = s[b], A = v.oldStart + v.offset + C - 1;
            C += v.newLines - v.oldLines;
            for(var F = 0; F < v.lines.length; F++){
                var x = v.lines[F], S = x.length > 0 ? x[0] : " ", w = x.length > 0 ? x.substr(1) : x, T = v.linedelimiters[F];
                if (" " === S) A++;
                else if ("-" === S) i.splice(A, 1), u3.splice(A, 1);
                else if ("+" === S) i.splice(A, 0, w), u3.splice(A, 0, T), A++;
                else if ("\\" === S) {
                    var B = v.lines[F - 1] ? v.lines[F - 1][0] : null;
                    "+" === B ? r4 = !0 : "-" === B && (o4 = !0);
                }
            }
        }
        if (r4) for(; !i[i.length - 1];)i.pop(), u3.pop();
        else o4 && (i.push(""), u3.push("\n"));
        for(var N = 0; N < i.length - 1; N++)i[N] = i[N] + u3[N];
        return i.join("");
    }
    var li = {
    }, pi = {
    };
    Object.defineProperty(pi, "__esModule", {
        value: !0
    }), pi.structuredPatch = gi, pi.formatPatch = mi, pi.createTwoFilesPatch = yi, pi.createPatch = function(e, t, n, r, o, i) {
        return yi(e, e, t, n, r, o, i);
    };
    var fi = g1;
    function di(e26) {
        return (function(e) {
            if (Array.isArray(e)) return hi(e);
        })(e26) || (function(e) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);
        })(e26) || (function(e, t) {
            if (!e) return;
            if ("string" == typeof e) return hi(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            "Object" === n && e.constructor && (n = e.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(e);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hi(e, t);
        })(e26) || (function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        })();
    }
    function hi(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for(var n = 0, r = new Array(t); n < t; n++)r[n] = e[n];
        return r;
    }
    function gi(e27, t11, n, r, o5, i3, u) {
        u || (u = {
        }), void 0 === u.context && (u.context = 4);
        var s = (0, fi.diffLines)(n, r, u);
        function a(e28) {
            return e28.map(function(e) {
                return " " + e;
            });
        }
        s.push({
            value: "",
            lines: []
        });
        for(var c = [], l = 0, p = 0, f = [], d = 1, h = 1, g3 = function(e29) {
            var t = s[e29], o = t.lines || t.value.replace(/\n$/, "").split("\n");
            if (t.lines = o, t.added || t.removed) {
                var i;
                if (!l) {
                    var g = s[e29 - 1];
                    l = d, p = h, g && (f = u.context > 0 ? a(g.lines.slice(-u.context)) : [], l -= f.length, p -= f.length);
                }
                (i = f).push.apply(i, di(o.map(function(e) {
                    return (t.added ? "+" : "-") + e;
                }))), t.added ? h += o.length : d += o.length;
            } else {
                if (l) {
                    if (o.length <= 2 * u.context && e29 < s.length - 2) {
                        var m;
                        (m = f).push.apply(m, di(a(o)));
                    } else {
                        var y, D = Math.min(o.length, u.context);
                        (y = f).push.apply(y, di(a(o.slice(0, D))));
                        var E = {
                            oldStart: l,
                            oldLines: d - l + D,
                            newStart: p,
                            newLines: h - p + D,
                            lines: f
                        };
                        if (e29 >= s.length - 2 && o.length <= u.context) {
                            var C = /\n$/.test(n), b = /\n$/.test(r), v = 0 == o.length && f.length > E.oldLines;
                            !C && v && n.length > 0 && f.splice(E.oldLines, 0, "\\ No newline at end of file"), (C || v) && b || f.push("\\ No newline at end of file");
                        }
                        c.push(E), l = 0, p = 0, f = [];
                    }
                }
                d += o.length, h += o.length;
            }
        }, m2 = 0; m2 < s.length; m2++)g3(m2);
        return {
            oldFileName: e27,
            newFileName: t11,
            oldHeader: o5,
            newHeader: i3,
            hunks: c
        };
    }
    function mi(e) {
        var t = [];
        e.oldFileName == e.newFileName && t.push("Index: " + e.oldFileName), t.push("==================================================================="), t.push("--- " + e.oldFileName + (void 0 === e.oldHeader ? "" : "\t" + e.oldHeader)), t.push("+++ " + e.newFileName + (void 0 === e.newHeader ? "" : "\t" + e.newHeader));
        for(var n = 0; n < e.hunks.length; n++){
            var r = e.hunks[n];
            0 === r.oldLines && (r.oldStart -= 1), 0 === r.newLines && (r.newStart -= 1), t.push("@@ -" + r.oldStart + "," + r.oldLines + " +" + r.newStart + "," + r.newLines + " @@"), t.push.apply(t, r.lines);
        }
        return t.join("\n") + "\n";
    }
    function yi(e, t, n, r, o, i, u) {
        return mi(gi(e, t, n, r, o, i, u));
    }
    var Di = {
    };
    function Ei(e, t) {
        if (t.length > e.length) return !1;
        for(var n = 0; n < t.length; n++)if (t[n] !== e[n]) return !1;
        return !0;
    }
    Object.defineProperty(Di, "__esModule", {
        value: !0
    }), Di.arrayEqual = function(e, t) {
        if (e.length !== t.length) return !1;
        return Ei(e, t);
    }, Di.arrayStartsWith = Ei, Object.defineProperty(li, "__esModule", {
        value: !0
    }), li.calcLineCount = xi, li.merge = function(e, t, n) {
        e = Si(e, n), t = Si(t, n);
        var r = {
        };
        (e.index || t.index) && (r.index = e.index || t.index);
        (e.newFileName || t.newFileName) && (wi(e) ? wi(t) ? (r.oldFileName = Ti(r, e.oldFileName, t.oldFileName), r.newFileName = Ti(r, e.newFileName, t.newFileName), r.oldHeader = Ti(r, e.oldHeader, t.oldHeader), r.newHeader = Ti(r, e.newHeader, t.newHeader)) : (r.oldFileName = e.oldFileName, r.newFileName = e.newFileName, r.oldHeader = e.oldHeader, r.newHeader = e.newHeader) : (r.oldFileName = t.oldFileName || e.oldFileName, r.newFileName = t.newFileName || e.newFileName, r.oldHeader = t.oldHeader || e.oldHeader, r.newHeader = t.newHeader || e.newHeader));
        r.hunks = [];
        var o = 0, i = 0, u = 0, s = 0;
        for(; o < e.hunks.length || i < t.hunks.length;){
            var a = e.hunks[o] || {
                oldStart: 1 / 0
            }, c = t.hunks[i] || {
                oldStart: 1 / 0
            };
            if (Bi(a, c)) r.hunks.push(Ni(a, u)), o++, s += a.newLines - a.oldLines;
            else if (Bi(c, a)) r.hunks.push(Ni(c, s)), i++, u += c.newLines - c.oldLines;
            else {
                var l = {
                    oldStart: Math.min(a.oldStart, c.oldStart),
                    oldLines: 0,
                    newStart: Math.min(a.newStart + u, c.oldStart + s),
                    newLines: 0,
                    lines: []
                };
                ki(l, a.oldStart, a.lines, c.oldStart, c.lines), i++, o++, r.hunks.push(l);
            }
        }
        return r;
    };
    var Ci = pi, bi = ii, vi = Di;
    function Ai(e30) {
        return (function(e) {
            if (Array.isArray(e)) return Fi(e);
        })(e30) || (function(e) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);
        })(e30) || (function(e, t) {
            if (!e) return;
            if ("string" == typeof e) return Fi(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            "Object" === n && e.constructor && (n = e.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(e);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Fi(e, t);
        })(e30) || (function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        })();
    }
    function Fi(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for(var n = 0, r = new Array(t); n < t; n++)r[n] = e[n];
        return r;
    }
    function xi(e) {
        var t = Vi(e.lines), n = t.oldLines, r = t.newLines;
        void 0 !== n ? e.oldLines = n : delete e.oldLines, void 0 !== r ? e.newLines = r : delete e.newLines;
    }
    function Si(e, t) {
        if ("string" == typeof e) {
            if (/^@@/m.test(e) || /^Index:/m.test(e)) return (0, bi.parsePatch)(e)[0];
            if (!t) throw new Error("Must provide a base reference or pass in a patch");
            return (0, Ci.structuredPatch)(void 0, void 0, t, e);
        }
        return e;
    }
    function wi(e) {
        return e.newFileName && e.newFileName !== e.oldFileName;
    }
    function Ti(e, t, n) {
        return t === n ? t : (e.conflict = !0, {
            mine: t,
            theirs: n
        });
    }
    function Bi(e, t) {
        return e.oldStart < t.oldStart && e.oldStart + e.oldLines < t.oldStart;
    }
    function Ni(e, t) {
        return {
            oldStart: e.oldStart,
            oldLines: e.oldLines,
            newStart: e.newStart + t,
            newLines: e.newLines,
            lines: e.lines
        };
    }
    function ki(e, t, n, r, o) {
        var i = {
            offset: t,
            lines: n,
            index: 0
        }, u = {
            offset: r,
            lines: o,
            index: 0
        };
        for(Li(e, i, u), Li(e, u, i); i.index < i.lines.length && u.index < u.lines.length;){
            var s = i.lines[i.index], a = u.lines[u.index];
            if ("-" !== s[0] && "+" !== s[0] || "-" !== a[0] && "+" !== a[0]) {
                if ("+" === s[0] && " " === a[0]) {
                    var c;
                    (c = e.lines).push.apply(c, Ai(_i(i)));
                } else if ("+" === a[0] && " " === s[0]) {
                    var l;
                    (l = e.lines).push.apply(l, Ai(_i(u)));
                } else "-" === s[0] && " " === a[0] ? Oi(e, i, u) : "-" === a[0] && " " === s[0] ? Oi(e, u, i, !0) : s === a ? (e.lines.push(s), i.index++, u.index++) : Ii(e, _i(i), _i(u));
            } else Pi(e, i, u);
        }
        ji(e, i), ji(e, u), xi(e);
    }
    function Pi(e, t, n) {
        var r = _i(t), o = _i(n);
        if (Mi(r) && Mi(o)) {
            var i, u;
            if ((0, vi.arrayStartsWith)(r, o) && Ri(n, r, r.length - o.length)) return void (i = e.lines).push.apply(i, Ai(r));
            if ((0, vi.arrayStartsWith)(o, r) && Ri(t, o, o.length - r.length)) return void (u = e.lines).push.apply(u, Ai(o));
        } else if ((0, vi.arrayEqual)(r, o)) {
            var s;
            return void (s = e.lines).push.apply(s, Ai(r));
        }
        Ii(e, r, o);
    }
    function Oi(e31, t12, n8, r5) {
        var o6, i4 = _i(t12), u4 = function(e, t) {
            var n = [], r = [], o = 0, i = !1, u = !1;
            for(; o < t.length && e.index < e.lines.length;){
                var s = e.lines[e.index], a = t[o];
                if ("+" === a[0]) break;
                if (i = i || " " !== s[0], r.push(a), o++, "+" === s[0]) for(u = !0; "+" === s[0];)n.push(s), s = e.lines[++e.index];
                a.substr(1) === s.substr(1) ? (n.push(s), e.index++) : u = !0;
            }
            "+" === (t[o] || "")[0] && i && (u = !0);
            if (u) return n;
            for(; o < t.length;)r.push(t[o++]);
            return {
                merged: r,
                changes: n
            };
        }(n8, i4);
        u4.merged ? (o6 = e31.lines).push.apply(o6, Ai(u4.merged)) : Ii(e31, r5 ? u4 : i4, r5 ? i4 : u4);
    }
    function Ii(e, t, n) {
        e.conflict = !0, e.lines.push({
            conflict: !0,
            mine: t,
            theirs: n
        });
    }
    function Li(e, t, n) {
        for(; t.offset < n.offset && t.index < t.lines.length;){
            var r = t.lines[t.index++];
            e.lines.push(r), t.offset++;
        }
    }
    function ji(e, t) {
        for(; t.index < t.lines.length;){
            var n = t.lines[t.index++];
            e.lines.push(n);
        }
    }
    function _i(e) {
        for(var t = [], n = e.lines[e.index][0]; e.index < e.lines.length;){
            var r = e.lines[e.index];
            if ("-" === n && "+" === r[0] && (n = "+"), n !== r[0]) break;
            t.push(r), e.index++;
        }
        return t;
    }
    function Mi(e32) {
        return e32.reduce(function(e, t) {
            return e && "-" === t[0];
        }, !0);
    }
    function Ri(e, t, n) {
        for(var r = 0; r < n; r++){
            var o = t[t.length - n + r].substr(1);
            if (e.lines[e.index + r] !== " " + o) return !1;
        }
        return e.index += n, !0;
    }
    function Vi(e33) {
        var t = 0, n = 0;
        return e33.forEach(function(e) {
            if ("string" != typeof e) {
                var r = Vi(e.mine), o = Vi(e.theirs);
                void 0 !== t && (r.oldLines === o.oldLines ? t += r.oldLines : t = void 0), void 0 !== n && (r.newLines === o.newLines ? n += r.newLines : n = void 0);
            } else void 0 === n || "+" !== e[0] && " " !== e[0] || n++, void 0 === t || "-" !== e[0] && " " !== e[0] || t++;
        }), {
            oldLines: t,
            newLines: n
        };
    }
    var $i = {
    };
    Object.defineProperty($i, "__esModule", {
        value: !0
    }), $i.convertChangesToDMP = function(e) {
        for(var t, n, r = [], o = 0; o < e.length; o++)t = e[o], n = t.added ? 1 : t.removed ? -1 : 0, r.push([
            n,
            t.value
        ]);
        return r;
    };
    var Wi = {
    };
    function qi(e) {
        var t = e;
        return t = (t = (t = (t = t.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
    }
    function Ui(e) {
        return {
            type: "concat",
            parts: e
        };
    }
    function zi(e) {
        return {
            type: "indent",
            contents: e
        };
    }
    function Gi(e, t) {
        return {
            type: "align",
            contents: t,
            n: e
        };
    }
    function Hi(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
        };
        return {
            type: "group",
            id: t.id,
            contents: e,
            break: Boolean(t.shouldBreak),
            expandedStates: t.expandedStates
        };
    }
    Object.defineProperty(Wi, "__esModule", {
        value: !0
    }), Wi.convertChangesToXML = function(e) {
        for(var t = [], n = 0; n < e.length; n++){
            var r = e[n];
            r.added ? t.push("<ins>") : r.removed && t.push("<del>"), t.push(qi(r.value)), r.added ? t.push("</ins>") : r.removed && t.push("</del>");
        }
        return t.join("");
    }, (function(e34) {
        Object.defineProperty(e34, "__esModule", {
            value: !0
        }), Object.defineProperty(e34, "Diff", {
            enumerable: !0,
            get: function() {
                return t.default;
            }
        }), Object.defineProperty(e34, "diffChars", {
            enumerable: !0,
            get: function() {
                return n.diffChars;
            }
        }), Object.defineProperty(e34, "diffWords", {
            enumerable: !0,
            get: function() {
                return r.diffWords;
            }
        }), Object.defineProperty(e34, "diffWordsWithSpace", {
            enumerable: !0,
            get: function() {
                return r.diffWordsWithSpace;
            }
        }), Object.defineProperty(e34, "diffLines", {
            enumerable: !0,
            get: function() {
                return i.diffLines;
            }
        }), Object.defineProperty(e34, "diffTrimmedLines", {
            enumerable: !0,
            get: function() {
                return i.diffTrimmedLines;
            }
        }), Object.defineProperty(e34, "diffSentences", {
            enumerable: !0,
            get: function() {
                return s.diffSentences;
            }
        }), Object.defineProperty(e34, "diffCss", {
            enumerable: !0,
            get: function() {
                return c.diffCss;
            }
        }), Object.defineProperty(e34, "diffJson", {
            enumerable: !0,
            get: function() {
                return l.diffJson;
            }
        }), Object.defineProperty(e34, "canonicalize", {
            enumerable: !0,
            get: function() {
                return l.canonicalize;
            }
        }), Object.defineProperty(e34, "diffArrays", {
            enumerable: !0,
            get: function() {
                return p.diffArrays;
            }
        }), Object.defineProperty(e34, "applyPatch", {
            enumerable: !0,
            get: function() {
                return f.applyPatch;
            }
        }), Object.defineProperty(e34, "applyPatches", {
            enumerable: !0,
            get: function() {
                return f.applyPatches;
            }
        }), Object.defineProperty(e34, "parsePatch", {
            enumerable: !0,
            get: function() {
                return d.parsePatch;
            }
        }), Object.defineProperty(e34, "merge", {
            enumerable: !0,
            get: function() {
                return h.merge;
            }
        }), Object.defineProperty(e34, "structuredPatch", {
            enumerable: !0,
            get: function() {
                return m.structuredPatch;
            }
        }), Object.defineProperty(e34, "createTwoFilesPatch", {
            enumerable: !0,
            get: function() {
                return m.createTwoFilesPatch;
            }
        }), Object.defineProperty(e34, "createPatch", {
            enumerable: !0,
            get: function() {
                return m.createPatch;
            }
        }), Object.defineProperty(e34, "convertChangesToDMP", {
            enumerable: !0,
            get: function() {
                return y.convertChangesToDMP;
            }
        }), Object.defineProperty(e34, "convertChangesToXML", {
            enumerable: !0,
            get: function() {
                return D.convertChangesToXML;
            }
        });
        var t = function(e) {
            return e && e.__esModule ? e : {
                default: e
            };
        }(o1), n = u1, r = a1, i = g1, s = E1, c = v1, l = Jo, p = ti, f = oi, d = ii, h = li, m = pi, y = $i, D = Wi;
    })(r1);
    const Ji = {
        type: "break-parent"
    }, Xi = {
        type: "line",
        hard: !0
    }, Yi = {
        type: "line",
        hard: !0,
        literal: !0
    }, Ki = Ui([
        Xi,
        Ji
    ]), Qi = Ui([
        Yi,
        Ji
    ]);
    var Zi = {
        concat: Ui,
        join: function(e, t) {
            const n = [];
            for(let r = 0; r < t.length; r++)0 !== r && n.push(e), n.push(t[r]);
            return Ui(n);
        },
        line: {
            type: "line"
        },
        softline: {
            type: "line",
            soft: !0
        },
        hardline: Ki,
        literalline: Qi,
        group: Hi,
        conditionalGroup: function(e, t) {
            return Hi(e[0], Object.assign(Object.assign({
            }, t), {
            }, {
                expandedStates: e
            }));
        },
        fill: function(e) {
            return {
                type: "fill",
                parts: e
            };
        },
        lineSuffix: function(e) {
            return {
                type: "line-suffix",
                contents: e
            };
        },
        lineSuffixBoundary: {
            type: "line-suffix-boundary"
        },
        cursor: {
            type: "cursor",
            placeholder: Symbol("cursor")
        },
        breakParent: Ji,
        ifBreak: function(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
            };
            return {
                type: "if-break",
                breakContents: e,
                flatContents: t,
                groupId: n.groupId
            };
        },
        trim: {
            type: "trim"
        },
        indent: zi,
        indentIfBreak: function(e, t) {
            return {
                type: "indent-if-break",
                contents: e,
                groupId: t.groupId,
                negate: t.negate
            };
        },
        align: Gi,
        addAlignmentToDoc: function(e, t, n) {
            let r = e;
            if (t > 0) {
                for(let e = 0; e < Math.floor(t / n); ++e)r = zi(r);
                r = Gi(t % n, r), r = Gi(Number.NEGATIVE_INFINITY, r);
            }
            return r;
        },
        markAsRoot: function(e) {
            return Gi({
                type: "root"
            }, e);
        },
        dedentToRoot: function(e) {
            return Gi(Number.NEGATIVE_INFINITY, e);
        },
        dedent: function(e) {
            return Gi(-1, e);
        },
        hardlineWithoutBreakParent: Xi,
        literallineWithoutBreakParent: Yi,
        label: function(e, t) {
            return {
                type: "label",
                label: e,
                contents: t
            };
        }
    }, eu = {
        exports: {
        }
    };
    const tu = function() {
        let { onlyFirst: e = !1  } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
        };
        const t = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(t, e ? void 0 : "g");
    };
    var nu = {
        exports: {
        }
    };
    const ru = (e)=>!Number.isNaN(e) && e >= 4352 && (e <= 4447 || 9001 === e || 9002 === e || 11904 <= e && e <= 12871 && 12351 !== e || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141)
    ;
    nu.exports = ru, nu.exports.default = ru;
    const ou = (e)=>"string" == typeof e ? e.replace(tu(), "") : e
    , iu = nu.exports, uu = function() {
        return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    }, su = (e)=>{
        if ("string" != typeof e || 0 === e.length) return 0;
        if (0 === (e = ou(e)).length) return 0;
        e = e.replace(uu(), "  ");
        let t = 0;
        for(let n = 0; n < e.length; n++){
            const r = e.codePointAt(n);
            r <= 31 || r >= 127 && r <= 159 || r >= 768 && r <= 879 || (r > 65535 && n++, t += iu(r) ? 2 : 1);
        }
        return t;
    };
    eu.exports = su, eu.exports.default = su;
    var au = (e)=>e[e.length - 1]
    ;
    function cu(e35, t13) {
        if (null == e35) return {
        };
        var n9, r6, o7 = function(e, t) {
            if (null == e) return {
            };
            var n, r, o = {
            }, i = Object.keys(e);
            for(r = 0; r < i.length; r++)n = i[r], t.indexOf(n) >= 0 || (o[n] = e[n]);
            return o;
        }(e35, t13);
        if (Object.getOwnPropertySymbols) {
            var i5 = Object.getOwnPropertySymbols(e35);
            for(r6 = 0; r6 < i5.length; r6++)n9 = i5[r6], t13.indexOf(n9) >= 0 || Object.prototype.propertyIsEnumerable.call(e35, n9) && (o7[n9] = e35[n9]);
        }
        return o7;
    }
    function lu(e, t) {
        return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
            raw: {
                value: Object.freeze(t)
            }
        }));
    }
    var pu = H, fu = Array.isArray || function(e) {
        return "Array" == pu(e);
    }, du = je, hu = q(q.bind), gu = function(e, t) {
        return du(e), void 0 === t ? e : hu ? hu(e, t) : function() {
            return e.apply(t, arguments);
        };
    }, mu = fu, yu = gr, Du = gu, Eu = S1.TypeError, Cu = function(e, t, n, r, o, i, u, s) {
        for(var a, c, l = o, p = 0, f = !!u && Du(u, s); p < r;){
            if (p in n) {
                if (a = f ? f(n[p], p, t) : n[p], i > 0 && mu(a)) c = yu(a), l = Cu(e, t, a, c, l, i - 1) - 1;
                else {
                    if (l >= 9007199254740991) throw Eu("Exceed the acceptable array length");
                    e[l] = a;
                }
                l++;
            }
            p++;
        }
        return l;
    }, bu = Cu, vu = q, Au = T1, Fu = ie, xu = fo, Su = hn, wu = function() {
    }, Tu = [], Bu = pe("Reflect", "construct"), Nu = /^\s*(?:class|function)\b/, ku = vu(Nu.exec), Pu = !Nu.exec(wu), Ou = function(e) {
        if (!Fu(e)) return !1;
        try {
            return Bu(wu, Tu, e), !0;
        } catch (e36) {
            return !1;
        }
    }, Iu = !Bu || Au(function() {
        var e;
        return Ou(Ou.call) || !Ou(Object) || !Ou(function() {
            e = !0;
        }) || e;
    }) ? function(e) {
        if (!Fu(e)) return !1;
        switch(xu(e)){
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
                return !1;
        }
        return Pu || !!ku(Nu, Su(e));
    } : Ou, Lu = S1, ju = fu, _u = Iu, Mu = se, Ru = Dt("species"), Vu = Lu.Array, $u = function(e) {
        var t;
        return ju(e) && (t = e.constructor, (_u(t) && (t === Vu || ju(t.prototype)) || Mu(t) && null === (t = t[Ru])) && (t = void 0)), void 0 === t ? Vu : t;
    }, Wu = function(e, t) {
        return new ($u(e))(0 === t ? 0 : t);
    }, qu = bu, Uu = je, zu = Ze, Gu = gr, Hu = Wu;
    ro({
        target: "Array",
        proto: !0
    }, {
        flatMap: function(e) {
            var t, n = zu(this), r = Gu(n);
            return Uu(e), (t = Hu(n, 0)).length = qu(t, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), t;
        }
    });
    var Ju = {
    }, Xu = Ju, Yu = Dt("iterator"), Ku = Array.prototype, Qu = fo, Zu = Me, es = Ju, ts = Dt("iterator"), ns = function(e) {
        if (null != e) return Zu(e, ts) || Zu(e, "@@iterator") || es[Qu(e)];
    }, rs = k, os = je, is = Yt, us = Pe, ss = ns, as = S1.TypeError, cs = k, ls = Yt, ps = Me, fs = gu, ds = k, hs = Yt, gs = Pe, ms = function(e) {
        return void 0 !== e && (Xu.Array === e || Ku[Yu] === e);
    }, ys = gr, Ds = fe, Es = function(e, t) {
        var n = arguments.length < 2 ? ss(e) : t;
        if (os(n)) return is(rs(n, e));
        throw as(us(e) + " is not iterable");
    }, Cs = ns, bs = function(e, t, n) {
        var r, o;
        ls(e);
        try {
            if (!(r = ps(e, "return"))) {
                if ("throw" === t) throw n;
                return n;
            }
            r = cs(r, e);
        } catch (e37) {
            o = !0, r = e37;
        }
        if ("throw" === t) throw n;
        if (o) throw r;
        return ls(r), n;
    }, vs = S1.TypeError, As = function(e, t) {
        this.stopped = e, this.result = t;
    }, Fs = As.prototype, xs = Bt, Ss = zt, ws = M, Ts = function(e38, t, n) {
        var r, o, i, u, s, a, c, l = n && n.that, p = !(!n || !n.AS_ENTRIES), f = !(!n || !n.IS_ITERATOR), d = !(!n || !n.INTERRUPTED), h = fs(t, l), g = function(e) {
            return r && bs(r, "normal", e), new As(!0, e);
        }, m = function(e) {
            return p ? (hs(e), d ? h(e[0], e[1], g) : h(e[0], e[1])) : d ? h(e, g) : h(e);
        };
        if (f) r = e38;
        else {
            if (!(o = Cs(e38))) throw vs(gs(e38) + " is not iterable");
            if (ms(o)) {
                for(i = 0, u = ys(e38); u > i; i++)if ((s = m(e38[i])) && Ds(Fs, s)) return s;
                return new As(!1);
            }
            r = Es(e38, o);
        }
        for(a = r.next; !(c = ds(a, r)).done;){
            try {
                s = m(c.value);
            } catch (e) {
                bs(r, "throw", e);
            }
            if ("object" == typeof s && s && Ds(Fs, s)) return s;
        }
        return new As(!1);
    }, Bs = function(e, t, n) {
        var r = xs(t);
        r in e ? Ss.f(e, r, ws(0, n)) : e[r] = n;
    };
    ro({
        target: "Object",
        stat: !0
    }, {
        fromEntries: function(e39) {
            var t = {
            };
            return Ts(e39, function(e, n) {
                Bs(t, e, n);
            }, {
                AS_ENTRIES: !0
            }), t;
        }
    });
    var Ns = void 0 !== Ns ? Ns : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {
    };
    function ks() {
        throw new Error("setTimeout has not been defined");
    }
    function Ps() {
        throw new Error("clearTimeout has not been defined");
    }
    var Os = ks, Is = Ps;
    function Ls(e) {
        if (Os === setTimeout) return setTimeout(e, 0);
        if ((Os === ks || !Os) && setTimeout) return Os = setTimeout, setTimeout(e, 0);
        try {
            return Os(e, 0);
        } catch (t) {
            try {
                return Os.call(null, e, 0);
            } catch (t) {
                return Os.call(this, e, 0);
            }
        }
    }
    "function" == typeof Ns.setTimeout && (Os = setTimeout), "function" == typeof Ns.clearTimeout && (Is = clearTimeout);
    var js, _s = [], Ms = !1, Rs = -1;
    function Vs() {
        Ms && js && (Ms = !1, js.length ? _s = js.concat(_s) : Rs = -1, _s.length && $s());
    }
    function $s() {
        if (!Ms) {
            var e40 = Ls(Vs);
            Ms = !0;
            for(var t = _s.length; t;){
                for(js = _s, _s = []; ++Rs < t;)js && js[Rs].run();
                Rs = -1, t = _s.length;
            }
            js = null, Ms = !1, (function(e) {
                if (Is === clearTimeout) return clearTimeout(e);
                if ((Is === Ps || !Is) && clearTimeout) return Is = clearTimeout, clearTimeout(e);
                try {
                    Is(e);
                } catch (t) {
                    try {
                        return Is.call(null, e);
                    } catch (t) {
                        return Is.call(this, e);
                    }
                }
            })(e40);
        }
    }
    function Ws(e, t) {
        this.fun = e, this.array = t;
    }
    Ws.prototype.run = function() {
        this.fun.apply(null, this.array);
    };
    function qs() {
    }
    var Us = qs, zs = qs, Gs = qs, Hs = qs, Js = qs, Xs = qs, Ys = qs;
    var Ks = Ns.performance || {
    }, Qs = Ks.now || Ks.mozNow || Ks.msNow || Ks.oNow || Ks.webkitNow || function() {
        return (new Date).getTime();
    };
    var Zs = new Date;
    var ea = {
        nextTick: function(e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1) for(var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n];
            _s.push(new Ws(e, t)), 1 !== _s.length || Ms || Ls($s);
        },
        title: "browser",
        browser: !0,
        env: {
        },
        argv: [],
        version: "",
        versions: {
        },
        on: Us,
        addListener: zs,
        once: Gs,
        off: Hs,
        removeListener: Js,
        removeAllListeners: Xs,
        emit: Ys,
        binding: function(e) {
            throw new Error("process.binding is not supported");
        },
        cwd: function() {
            return "/";
        },
        chdir: function(e) {
            throw new Error("process.chdir is not supported");
        },
        umask: function() {
            return 0;
        },
        hrtime: function(e) {
            var t = 0.001 * Qs.call(Ks), n = Math.floor(t), r = Math.floor(t % 1 * 1000000000);
            return e && (n -= e[0], (r -= e[1]) < 0 && (n--, r += 1000000000)), [
                n,
                r
            ];
        },
        platform: "browser",
        release: {
        },
        config: {
        },
        uptime: function() {
            return (new Date - Zs) / 1000;
        }
    }, ta = ea;
    const na = "object" == typeof ta && ta.env && ta.env.NODE_DEBUG && /\bsemver\b/i.test(ta.env.NODE_DEBUG) ? function() {
        for(var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n];
        return console.error("SEMVER", ...t);
    } : ()=>{
    };
    var ra = na;
    var oa = {
        SEMVER_SPEC_VERSION: "2.0.0",
        MAX_LENGTH: 256,
        MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
        MAX_SAFE_COMPONENT_LENGTH: 16
    }, ia = {
        exports: {
        }
    };
    !function(e, t14) {
        const { MAX_SAFE_COMPONENT_LENGTH: n10  } = oa, r = ra, o = (t14 = e.exports = {
        }).re = [], i = t14.src = [], u = t14.t = {
        };
        let s = 0;
        const a3 = (e, t, n)=>{
            const a = s++;
            r(a, t), u[e] = a, i[a] = t, o[a] = new RegExp(t, n ? "g" : void 0);
        };
        a3("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a3("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a3("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a3("MAINVERSION", "(".concat(i[u.NUMERICIDENTIFIER], ")\\.") + "(".concat(i[u.NUMERICIDENTIFIER], ")\\.") + "(".concat(i[u.NUMERICIDENTIFIER], ")")), a3("MAINVERSIONLOOSE", "(".concat(i[u.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i[u.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i[u.NUMERICIDENTIFIERLOOSE], ")")), a3("PRERELEASEIDENTIFIER", "(?:".concat(i[u.NUMERICIDENTIFIER], "|").concat(i[u.NONNUMERICIDENTIFIER], ")")), a3("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(i[u.NUMERICIDENTIFIERLOOSE], "|").concat(i[u.NONNUMERICIDENTIFIER], ")")), a3("PRERELEASE", "(?:-(".concat(i[u.PRERELEASEIDENTIFIER], "(?:\\.").concat(i[u.PRERELEASEIDENTIFIER], ")*))")), a3("PRERELEASELOOSE", "(?:-?(".concat(i[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(i[u.PRERELEASEIDENTIFIERLOOSE], ")*))")), a3("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a3("BUILD", "(?:\\+(".concat(i[u.BUILDIDENTIFIER], "(?:\\.").concat(i[u.BUILDIDENTIFIER], ")*))")), a3("FULLPLAIN", "v?".concat(i[u.MAINVERSION]).concat(i[u.PRERELEASE], "?").concat(i[u.BUILD], "?")), a3("FULL", "^".concat(i[u.FULLPLAIN], "$")), a3("LOOSEPLAIN", "[v=\\s]*".concat(i[u.MAINVERSIONLOOSE]).concat(i[u.PRERELEASELOOSE], "?").concat(i[u.BUILD], "?")), a3("LOOSE", "^".concat(i[u.LOOSEPLAIN], "$")), a3("GTLT", "((?:<|>)?=?)"), a3("XRANGEIDENTIFIERLOOSE", "".concat(i[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), a3("XRANGEIDENTIFIER", "".concat(i[u.NUMERICIDENTIFIER], "|x|X|\\*")), a3("XRANGEPLAIN", "[v=\\s]*(".concat(i[u.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i[u.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i[u.XRANGEIDENTIFIER], ")") + "(?:".concat(i[u.PRERELEASE], ")?").concat(i[u.BUILD], "?") + ")?)?"), a3("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(i[u.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i[u.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i[u.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(i[u.PRERELEASELOOSE], ")?").concat(i[u.BUILD], "?") + ")?)?"), a3("XRANGE", "^".concat(i[u.GTLT], "\\s*").concat(i[u.XRANGEPLAIN], "$")), a3("XRANGELOOSE", "^".concat(i[u.GTLT], "\\s*").concat(i[u.XRANGEPLAINLOOSE], "$")), a3("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n10, "})") + "(?:\\.(\\d{1,".concat(n10, "}))?") + "(?:\\.(\\d{1,".concat(n10, "}))?") + "(?:$|[^\\d])"), a3("COERCERTL", i[u.COERCE], !0), a3("LONETILDE", "(?:~>?)"), a3("TILDETRIM", "(\\s*)".concat(i[u.LONETILDE], "\\s+"), !0), t14.tildeTrimReplace = "$1~", a3("TILDE", "^".concat(i[u.LONETILDE]).concat(i[u.XRANGEPLAIN], "$")), a3("TILDELOOSE", "^".concat(i[u.LONETILDE]).concat(i[u.XRANGEPLAINLOOSE], "$")), a3("LONECARET", "(?:\\^)"), a3("CARETTRIM", "(\\s*)".concat(i[u.LONECARET], "\\s+"), !0), t14.caretTrimReplace = "$1^", a3("CARET", "^".concat(i[u.LONECARET]).concat(i[u.XRANGEPLAIN], "$")), a3("CARETLOOSE", "^".concat(i[u.LONECARET]).concat(i[u.XRANGEPLAINLOOSE], "$")), a3("COMPARATORLOOSE", "^".concat(i[u.GTLT], "\\s*(").concat(i[u.LOOSEPLAIN], ")$|^$")), a3("COMPARATOR", "^".concat(i[u.GTLT], "\\s*(").concat(i[u.FULLPLAIN], ")$|^$")), a3("COMPARATORTRIM", "(\\s*)".concat(i[u.GTLT], "\\s*(").concat(i[u.LOOSEPLAIN], "|").concat(i[u.XRANGEPLAIN], ")"), !0), t14.comparatorTrimReplace = "$1$2$3", a3("HYPHENRANGE", "^\\s*(".concat(i[u.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(i[u.XRANGEPLAIN], ")") + "\\s*$"), a3("HYPHENRANGELOOSE", "^\\s*(".concat(i[u.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(i[u.XRANGEPLAINLOOSE], ")") + "\\s*$"), a3("STAR", "(<|>)?=?\\s*\\*"), a3("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a3("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    }(ia, ia.exports);
    const ua = [
        "includePrerelease",
        "loose",
        "rtl"
    ];
    var sa = (e42)=>e42 ? "object" != typeof e42 ? {
            loose: !0
        } : ua.filter((t)=>e42[t]
        ).reduce((e, t)=>(e[t] = !0, e)
        , {
        }) : {
        }
    ;
    const aa = /^[0-9]+$/, ca = (e, t)=>{
        const n = aa.test(e), r = aa.test(t);
        return n && r && (e = +e, t = +t), e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;
    };
    var la = {
        compareIdentifiers: ca,
        rcompareIdentifiers: (e, t)=>ca(t, e)
    };
    const pa = ra, { MAX_LENGTH: fa , MAX_SAFE_INTEGER: da  } = oa, { re: ha , t: ga  } = ia.exports, ma = sa, { compareIdentifiers: ya  } = la;
    class Da {
        constructor(e43, t15){
            if (t15 = ma(t15), e43 instanceof Da) {
                if (e43.loose === !!t15.loose && e43.includePrerelease === !!t15.includePrerelease) return e43;
                e43 = e43.version;
            } else if ("string" != typeof e43) throw new TypeError("Invalid Version: ".concat(e43));
            if (e43.length > fa) throw new TypeError("version is longer than ".concat(fa, " characters"));
            pa("SemVer", e43, t15), this.options = t15, this.loose = !!t15.loose, this.includePrerelease = !!t15.includePrerelease;
            const n = e43.trim().match(t15.loose ? ha[ga.LOOSE] : ha[ga.FULL]);
            if (!n) throw new TypeError("Invalid Version: ".concat(e43));
            if (this.raw = e43, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > da || this.major < 0) throw new TypeError("Invalid major version");
            if (this.minor > da || this.minor < 0) throw new TypeError("Invalid minor version");
            if (this.patch > da || this.patch < 0) throw new TypeError("Invalid patch version");
            n[4] ? this.prerelease = n[4].split(".").map((e)=>{
                if (/^[0-9]+$/.test(e)) {
                    const t = +e;
                    if (t >= 0 && t < da) return t;
                }
                return e;
            }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
        }
        format() {
            return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
        }
        toString() {
            return this.version;
        }
        compare(e) {
            if (pa("SemVer.compare", this.version, this.options, e), !(e instanceof Da)) {
                if ("string" == typeof e && e === this.version) return 0;
                e = new Da(e, this.options);
            }
            return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
        }
        compareMain(e) {
            return e instanceof Da || (e = new Da(e, this.options)), ya(this.major, e.major) || ya(this.minor, e.minor) || ya(this.patch, e.patch);
        }
        comparePre(e) {
            if (e instanceof Da || (e = new Da(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
            if (!this.prerelease.length && e.prerelease.length) return 1;
            if (!this.prerelease.length && !e.prerelease.length) return 0;
            let t = 0;
            do {
                const n = this.prerelease[t], r = e.prerelease[t];
                if (pa("prerelease compare", t, n, r), void 0 === n && void 0 === r) return 0;
                if (void 0 === r) return 1;
                if (void 0 === n) return -1;
                if (n !== r) return ya(n, r);
            }while (++t)
        }
        compareBuild(e) {
            e instanceof Da || (e = new Da(e, this.options));
            let t = 0;
            do {
                const n = this.build[t], r = e.build[t];
                if (pa("prerelease compare", t, n, r), void 0 === n && void 0 === r) return 0;
                if (void 0 === r) return 1;
                if (void 0 === n) return -1;
                if (n !== r) return ya(n, r);
            }while (++t)
        }
        inc(e, t) {
            switch(e){
                case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                    break;
                case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                    break;
                case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                    break;
                case "prerelease":
                    0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                    break;
                case "major":
                    0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                case "minor":
                    0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                case "patch":
                    0 === this.prerelease.length && this.patch++, this.prerelease = [];
                    break;
                case "pre":
                    if (0 === this.prerelease.length) this.prerelease = [
                        0
                    ];
                    else {
                        let e = this.prerelease.length;
                        for(; --e >= 0;)"number" == typeof this.prerelease[e] && (this.prerelease[e]++, e = -2);
                        -1 === e && this.prerelease.push(0);
                    }
                    t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [
                        t,
                        0
                    ]) : this.prerelease = [
                        t,
                        0
                    ]);
                    break;
                default:
                    throw new Error("invalid increment argument: ".concat(e));
            }
            return this.format(), this.raw = this.version, this;
        }
    }
    const Ea = Da;
    var Ca = (e, t, n)=>new Ea(e, n).compare(new Ea(t, n))
    ;
    const ba = Ca;
    var va = (e, t, n)=>ba(e, t, n) < 0
    ;
    const Aa = Ca;
    var Fa, xa, Sa, wa, Ta, Ba, Na = (e, t, n)=>Aa(e, t, n) >= 0
    , ka = {
        exports: {
        }
    };
    !function(e44, t16) {
        function n11() {
            for(var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t];
        }
        function r7() {
            return "undefined" != typeof WeakMap ? new WeakMap : {
                add: n11,
                delete: n11,
                get: n11,
                set: n11,
                has: function(e) {
                    return !1;
                }
            };
        }
        Object.defineProperty(t16, "__esModule", {
            value: !0
        }), t16.outdent = void 0;
        var o8 = Object.prototype.hasOwnProperty, i6 = function(e, t) {
            return o8.call(e, t);
        };
        function u5(e, t) {
            for(var n in t)i6(t, n) && (e[n] = t[n]);
            return e;
        }
        var s3 = /^[ \t]*(?:\r\n|\r|\n)/, a4 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p3 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function f2(e45, t17, n) {
            var r = 0, o = e45[0].match(l2);
            o && (r = o[1].length);
            var i = new RegExp("(\\r\\n|\\r|\\n).{0," + r + "}", "g");
            t17 && (e45 = e45.slice(1));
            var u = n.newline, c = n.trimLeadingNewline, p = n.trimTrailingNewline, f = "string" == typeof u, d = e45.length;
            return e45.map(function(e, t) {
                return e = e.replace(i, "$1"), 0 === t && c && (e = e.replace(s3, "")), t === d - 1 && p && (e = e.replace(a4, "")), f && (e = e.replace(/\r\n|\n|\r/g, function(e) {
                    return u;
                })), e;
            });
        }
        function d3(e, t) {
            for(var n = "", r = 0, o = e.length; r < o; r++)n += e[r], r < o - 1 && (n += t[r]);
            return n;
        }
        function h(e) {
            return i6(e, "raw") && i6(e, "length");
        }
        var g = function e46(t) {
            var n = r7(), o = r7(), i7 = u5(function r(i) {
                for(var s = [], a = 1; a < arguments.length; a++)s[a - 1] = arguments[a];
                if (h(i)) {
                    var l = i, m = (s[0] === r || s[0] === g) && p3.test(l[0]) && c2.test(l[1]), y = m ? o : n, D = y.get(l);
                    if (D || (D = f2(l, m, t), y.set(l, D)), 0 === s.length) return D[0];
                    var E = d3(D, m ? s.slice(1) : s);
                    return E;
                }
                return e46(u5(u5({
                }, t), i || {
                }));
            }, {
                string: function(e) {
                    return f2([
                        e
                    ], !1, t)[0];
                }
            });
            return i7;
        }({
            trimLeadingNewline: !0,
            trimTrailingNewline: !0
        });
        t16.outdent = g, t16.default = g;
        try {
            e44.exports = g, Object.defineProperty(g, "__esModule", {
                value: !0
            }), g.default = g, g.outdent = g;
        } catch (e) {
        }
    }(ka, ka.exports);
    const { outdent: Pa  } = ka.exports, Oa = "Config", Ia = "Editor", La = "Other", ja = "Global", _a = "Special", Ma = {
        cursorOffset: {
            since: "1.4.0",
            category: _a,
            type: "int",
            default: -1,
            range: {
                start: -1,
                end: Number.POSITIVE_INFINITY,
                step: 1
            },
            description: Pa(Fa || (Fa = lu([
                "\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "
            ]))),
            cliCategory: Ia
        },
        endOfLine: {
            since: "1.15.0",
            category: ja,
            type: "choice",
            default: [
                {
                    since: "1.15.0",
                    value: "auto"
                },
                {
                    since: "2.0.0",
                    value: "lf"
                }
            ],
            description: "Which end of line characters to apply.",
            choices: [
                {
                    value: "lf",
                    description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
                },
                {
                    value: "crlf",
                    description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
                },
                {
                    value: "cr",
                    description: "Carriage Return character only (\\r), used very rarely"
                },
                {
                    value: "auto",
                    description: Pa(xa || (xa = lu([
                        "\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "
                    ])))
                }
            ]
        },
        filepath: {
            since: "1.4.0",
            category: _a,
            type: "path",
            description: "Specify the input filepath. This will be used to do parser inference.",
            cliName: "stdin-filepath",
            cliCategory: La,
            cliDescription: "Path to the file to pretend that stdin comes from."
        },
        insertPragma: {
            since: "1.8.0",
            category: _a,
            type: "boolean",
            default: !1,
            description: "Insert @format pragma into file's first docblock comment.",
            cliCategory: La
        },
        parser: {
            since: "0.0.10",
            category: ja,
            type: "choice",
            default: [
                {
                    since: "0.0.10",
                    value: "babylon"
                },
                {
                    since: "1.13.0",
                    value: void 0
                }
            ],
            description: "Which parser to use.",
            exception: (e)=>"string" == typeof e || "function" == typeof e
            ,
            choices: [
                {
                    value: "flow",
                    description: "Flow"
                },
                {
                    value: "babel",
                    since: "1.16.0",
                    description: "JavaScript"
                },
                {
                    value: "babel-flow",
                    since: "1.16.0",
                    description: "Flow"
                },
                {
                    value: "babel-ts",
                    since: "2.0.0",
                    description: "TypeScript"
                },
                {
                    value: "typescript",
                    since: "1.4.0",
                    description: "TypeScript"
                },
                {
                    value: "espree",
                    since: "2.2.0",
                    description: "JavaScript"
                },
                {
                    value: "meriyah",
                    since: "2.2.0",
                    description: "JavaScript"
                },
                {
                    value: "css",
                    since: "1.7.1",
                    description: "CSS"
                },
                {
                    value: "less",
                    since: "1.7.1",
                    description: "Less"
                },
                {
                    value: "scss",
                    since: "1.7.1",
                    description: "SCSS"
                },
                {
                    value: "json",
                    since: "1.5.0",
                    description: "JSON"
                },
                {
                    value: "json5",
                    since: "1.13.0",
                    description: "JSON5"
                },
                {
                    value: "json-stringify",
                    since: "1.13.0",
                    description: "JSON.stringify"
                },
                {
                    value: "graphql",
                    since: "1.5.0",
                    description: "GraphQL"
                },
                {
                    value: "markdown",
                    since: "1.8.0",
                    description: "Markdown"
                },
                {
                    value: "mdx",
                    since: "1.15.0",
                    description: "MDX"
                },
                {
                    value: "vue",
                    since: "1.10.0",
                    description: "Vue"
                },
                {
                    value: "yaml",
                    since: "1.14.0",
                    description: "YAML"
                },
                {
                    value: "glimmer",
                    since: "2.3.0",
                    description: "Ember / Handlebars"
                },
                {
                    value: "html",
                    since: "1.15.0",
                    description: "HTML"
                },
                {
                    value: "angular",
                    since: "1.15.0",
                    description: "Angular"
                },
                {
                    value: "lwc",
                    since: "1.17.0",
                    description: "Lightning Web Components"
                }
            ]
        },
        plugins: {
            since: "1.10.0",
            type: "path",
            array: !0,
            default: [
                {
                    value: []
                }
            ],
            category: ja,
            description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
            exception: (e)=>"string" == typeof e || "object" == typeof e
            ,
            cliName: "plugin",
            cliCategory: Oa
        },
        pluginSearchDirs: {
            since: "1.13.0",
            type: "path",
            array: !0,
            default: [
                {
                    value: []
                }
            ],
            category: ja,
            description: Pa(Sa || (Sa = lu([
                "\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "
            ]))),
            exception: (e)=>"string" == typeof e || "object" == typeof e
            ,
            cliName: "plugin-search-dir",
            cliCategory: Oa
        },
        printWidth: {
            since: "0.0.0",
            category: ja,
            type: "int",
            default: 80,
            description: "The line length where Prettier will try wrap.",
            range: {
                start: 0,
                end: Number.POSITIVE_INFINITY,
                step: 1
            }
        },
        rangeEnd: {
            since: "1.4.0",
            category: _a,
            type: "int",
            default: Number.POSITIVE_INFINITY,
            range: {
                start: 0,
                end: Number.POSITIVE_INFINITY,
                step: 1
            },
            description: Pa(wa || (wa = lu([
                "\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
            ]))),
            cliCategory: Ia
        },
        rangeStart: {
            since: "1.4.0",
            category: _a,
            type: "int",
            default: 0,
            range: {
                start: 0,
                end: Number.POSITIVE_INFINITY,
                step: 1
            },
            description: Pa(Ta || (Ta = lu([
                "\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
            ]))),
            cliCategory: Ia
        },
        requirePragma: {
            since: "1.7.0",
            category: _a,
            type: "boolean",
            default: !1,
            description: Pa(Ba || (Ba = lu([
                "\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "
            ]))),
            cliCategory: La
        },
        tabWidth: {
            type: "int",
            category: ja,
            default: 2,
            description: "Number of spaces per indentation level.",
            range: {
                start: 0,
                end: Number.POSITIVE_INFINITY,
                step: 1
            }
        },
        useTabs: {
            since: "1.0.0",
            category: ja,
            type: "boolean",
            default: !1,
            description: "Indent with tabs instead of spaces."
        },
        embeddedLanguageFormatting: {
            since: "2.1.0",
            category: ja,
            type: "choice",
            default: [
                {
                    since: "2.1.0",
                    value: "auto"
                }
            ],
            description: "Control how Prettier formats quoted code embedded in the file.",
            choices: [
                {
                    value: "auto",
                    description: "Format embedded code if Prettier can automatically identify it."
                },
                {
                    value: "off",
                    description: "Never automatically format embedded code."
                }
            ]
        }
    };
    const Ra = [
        "cliName",
        "cliCategory",
        "cliDescription"
    ], Va = {
        compare: Ca,
        lt: va,
        gte: Na
    }, $a = (e47, t)=>Object.entries(e47).map((e)=>{
            let [n, r] = e;
            return Object.assign({
                [t]: n
            }, r);
        })
    , Wa = n2.version, qa = {
        CATEGORY_CONFIG: Oa,
        CATEGORY_EDITOR: Ia,
        CATEGORY_FORMAT: "Format",
        CATEGORY_OTHER: La,
        CATEGORY_OUTPUT: "Output",
        CATEGORY_GLOBAL: ja,
        CATEGORY_SPECIAL: _a,
        options: Ma
    }.options;
    function Ua(e48, t, n) {
        const r = new Set(e48.choices.map((e)=>e.value
        ));
        for (const o of t)if (o.parsers) {
            for (const t18 of o.parsers)if (!r.has(t18)) {
                r.add(t18);
                const i = n.find((e)=>e.parsers && e.parsers[t18]
                );
                let u = o.name;
                i && i.name && (u += " (plugin: ".concat(i.name, ")")), e48.choices.push({
                    value: t18,
                    description: u
                });
            }
        }
    }
    var za = {
        getSupportInfo: function() {
            let { plugins: e49 = [] , showUnreleased: t19 = !1 , showDeprecated: n12 = !1 , showInternal: r = !1  } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
            };
            const o = Wa.split("-", 1)[0], i = e49.flatMap((e)=>e.languages || []
            ).filter(s), u = $a(Object.assign({
            }, ...e49.map((e)=>{
                let { options: t  } = e;
                return t;
            }), qa), "name").filter((e)=>s(e) && a(e)
            ).sort((e, t)=>e.name === t.name ? 0 : e.name < t.name ? -1 : 1
            ).map(c).map((t20)=>{
                t20 = Object.assign({
                }, t20), Array.isArray(t20.default) && (t20.default = 1 === t20.default.length ? t20.default[0].value : t20.default.filter(s).sort((e, t)=>Va.compare(t.since, e.since)
                )[0].value), Array.isArray(t20.choices) && (t20.choices = t20.choices.filter((e)=>s(e) && a(e)
                ), "parser" === t20.name && Ua(t20, i, e49));
                const n = Object.fromEntries(e49.filter((e)=>e.defaultOptions && void 0 !== e.defaultOptions[t20.name]
                ).map((e)=>[
                        e.name,
                        e.defaultOptions[t20.name]
                    ]
                ));
                return Object.assign(Object.assign({
                }, t20), {
                }, {
                    pluginDefaults: n
                });
            });
            function s(e) {
                return t19 || !("since" in e) || e.since && Va.gte(o, e.since);
            }
            function a(e) {
                return n12 || !("deprecated" in e) || e.deprecated && Va.lt(o, e.deprecated);
            }
            function c(e) {
                if (r) return e;
                return cu(e, Ra);
            }
            return {
                languages: i,
                options: u
            };
        }
    };
    const Ga = eu.exports, Ha = (e)=>{
        if ("string" != typeof e) throw new TypeError("Expected a string");
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }, Ja = au, { getSupportInfo: Xa  } = za, Ya = /[^\x20-\x7F]/;
    function Ka(e) {
        return (t, n, r)=>{
            const o = r && r.backwards;
            if (!1 === n) return !1;
            const { length: i  } = t;
            let u = n;
            for(; u >= 0 && u < i;){
                const n = t.charAt(u);
                if (e instanceof RegExp) {
                    if (!e.test(n)) return u;
                } else if (!e.includes(n)) return u;
                o ? u-- : u++;
            }
            return (-1 === u || u === i) && u;
        };
    }
    const Qa = Ka(/\s/), Za = Ka(" \t"), ec = Ka(",; \t"), tc = Ka(/[^\n\r]/);
    function nc(e, t) {
        if (!1 === t) return !1;
        if ("/" === e.charAt(t) && "*" === e.charAt(t + 1)) {
            for(let n = t + 2; n < e.length; ++n)if ("*" === e.charAt(n) && "/" === e.charAt(n + 1)) return n + 2;
        }
        return t;
    }
    function rc(e, t) {
        return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? tc(e, t) : t);
    }
    function oc(e, t, n) {
        const r = n && n.backwards;
        if (!1 === t) return !1;
        const o = e.charAt(t);
        if (r) {
            if ("\r" === e.charAt(t - 1) && "\n" === o) return t - 2;
            if ("\n" === o || "\r" === o || "\u2028" === o || "\u2029" === o) return t - 1;
        } else {
            if ("\r" === o && "\n" === e.charAt(t + 1)) return t + 2;
            if ("\n" === o || "\r" === o || "\u2028" === o || "\u2029" === o) return t + 1;
        }
        return t;
    }
    function ic(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
        };
        const r = Za(e, n.backwards ? t - 1 : t, n), o = oc(e, r, n);
        return r !== o;
    }
    function uc(e, t) {
        let n = null, r = t;
        for(; r !== n;)n = r, r = ec(e, r), r = nc(e, r), r = Za(e, r);
        return r = rc(e, r), r = oc(e, r), !1 !== r && ic(e, r);
    }
    function sc(e, t) {
        let n = null, r = t;
        for(; r !== n;)n = r, r = Za(e, r), r = nc(e, r), r = rc(e, r), r = oc(e, r);
        return r;
    }
    function ac(e, t, n) {
        return sc(e, n(t));
    }
    function cc(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = 0;
        for(let o = n; o < e.length; ++o)"\t" === e[o] ? r = r + t - r % t : r++;
        return r;
    }
    function lc(e, t) {
        const n = {
            quote: '"',
            regex: /"/g,
            escaped: "&quot;"
        }, r = {
            quote: "'",
            regex: /'/g,
            escaped: "&apos;"
        }, o = "'" === t ? r : n, i = o === r ? n : r;
        let u = o;
        if (e.includes(o.quote) || e.includes(i.quote)) u = (e.match(o.regex) || []).length > (e.match(i.regex) || []).length ? i : o;
        return u;
    }
    function pc(e, t, n) {
        const r = '"' === t ? "'" : '"', o9 = e.replace(/\\(.)|(["'])/gs, (e, o, i)=>o === r ? o : i === t ? "\\" + i : i || (n && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o) ? o : "\\" + o)
        );
        return t + o9 + t;
    }
    function fc(e50, t21) {
        (e50.comments || (e50.comments = [])).push(t21), t21.printed = !1, t21.nodeDescription = (function(e) {
            const t = e.type || e.kind || "(unknown type)";
            let n = String(e.name || e.id && ("object" == typeof e.id ? e.id.name : e.id) || e.key && ("object" == typeof e.key ? e.key.name : e.key) || e.value && ("object" == typeof e.value ? "" : String(e.value)) || e.operator || "");
            n.length > 20 && (n = n.slice(0, 19) + "\u2026");
            return t + (n ? " " + n : "");
        })(e50);
    }
    var dc = {
        inferParserByLanguage: function(e, t22) {
            const { languages: n13  } = Xa({
                plugins: t22.plugins
            }), r = n13.find((t)=>{
                let { name: n  } = t;
                return n.toLowerCase() === e;
            }) || n13.find((t)=>{
                let { aliases: n  } = t;
                return Array.isArray(n) && n.includes(e);
            }) || n13.find((t)=>{
                let { extensions: n  } = t;
                return Array.isArray(n) && n.includes(".".concat(e));
            });
            return r && r.parsers[0];
        },
        getStringWidth: function(e) {
            return e ? Ya.test(e) ? Ga(e) : e.length : 0;
        },
        getMaxContinuousCount: function(e51, t) {
            const n14 = e51.match(new RegExp("(".concat(Ha(t), ")+"), "g"));
            return null === n14 ? 0 : n14.reduce((e, n)=>Math.max(e, n.length / t.length)
            , 0);
        },
        getMinNotPresentContinuousCount: function(e, t) {
            const n = e.match(new RegExp("(".concat(Ha(t), ")+"), "g"));
            if (null === n) return 0;
            const r = new Map;
            let o = 0;
            for (const e52 of n){
                const n = e52.length / t.length;
                r.set(n, !0), n > o && (o = n);
            }
            for(let e53 = 1; e53 < o; e53++)if (!r.get(e53)) return e53;
            return o + 1;
        },
        getPenultimate: (e)=>e[e.length - 2]
        ,
        getLast: Ja,
        getNextNonSpaceNonCommentCharacterIndexWithStartIndex: sc,
        getNextNonSpaceNonCommentCharacterIndex: ac,
        getNextNonSpaceNonCommentCharacter: function(e, t, n) {
            return e.charAt(ac(e, t, n));
        },
        skip: Ka,
        skipWhitespace: Qa,
        skipSpaces: Za,
        skipToLineEnd: ec,
        skipEverythingButNewLine: tc,
        skipInlineComment: nc,
        skipTrailingComment: rc,
        skipNewline: oc,
        isNextLineEmptyAfterIndex: uc,
        isNextLineEmpty: function(e, t, n) {
            return uc(e, n(t));
        },
        isPreviousLineEmpty: function(e, t, n) {
            let r = n(t) - 1;
            return r = Za(e, r, {
                backwards: !0
            }), r = oc(e, r, {
                backwards: !0
            }), r = Za(e, r, {
                backwards: !0
            }), r !== oc(e, r, {
                backwards: !0
            });
        },
        hasNewline: ic,
        hasNewlineInRange: function(e, t, n) {
            for(let r = t; r < n; ++r)if ("\n" === e.charAt(r)) return !0;
            return !1;
        },
        hasSpaces: function(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
            };
            const r = Za(e, n.backwards ? t - 1 : t, n);
            return r !== t;
        },
        getAlignmentSize: cc,
        getIndentSize: function(e, t) {
            const n = e.lastIndexOf("\n");
            return -1 === n ? 0 : cc(e.slice(n + 1).match(/^[\t ]*/)[0], t);
        },
        getPreferredQuote: lc,
        printString: function(e, t) {
            const n = e.slice(1, -1);
            return pc(n, "json" === t.parser || "json5" === t.parser && "preserve" === t.quoteProps && !t.singleQuote ? '"' : t.__isInHtmlAttribute ? "'" : lc(n, t.singleQuote ? "'" : '"').quote, !("css" === t.parser || "less" === t.parser || "scss" === t.parser || t.__embeddedInHtml));
        },
        printNumber: function(e) {
            return e.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
        },
        makeString: pc,
        addLeadingComment: function(e, t) {
            t.leading = !0, t.trailing = !1, fc(e, t);
        },
        addDanglingComment: function(e, t, n) {
            t.leading = !1, t.trailing = !1, n && (t.marker = n), fc(e, t);
        },
        addTrailingComment: function(e, t) {
            t.leading = !1, t.trailing = !0, fc(e, t);
        },
        isFrontMatterNode: function(e) {
            return e && "front-matter" === e.type;
        },
        getShebang: function(e) {
            if (!e.startsWith("#!")) return "";
            const t = e.indexOf("\n");
            return -1 === t ? e : e.slice(0, t);
        },
        isNonEmptyArray: function(e) {
            return Array.isArray(e) && e.length > 0;
        },
        createGroupIdMapper: function(e) {
            const t = new WeakMap;
            return function(n) {
                return t.has(n) || t.set(n, Symbol(e)), t.get(n);
            };
        }
    };
    var hc = {
        guessEndOfLine: function(e) {
            const t = e.indexOf("\r");
            return t >= 0 ? "\n" === e.charAt(t + 1) ? "crlf" : "cr" : "lf";
        },
        convertEndOfLineToChars: function(e) {
            switch(e){
                case "cr":
                    return "\r";
                case "crlf":
                    return "\r\n";
                default:
                    return "\n";
            }
        },
        countEndOfLineChars: function(e, t) {
            let n;
            if ("\n" === t) n = /\n/g;
            else if ("\r" === t) n = /\r/g;
            else {
                if ("\r\n" !== t) throw new Error('Unexpected "eol" '.concat(JSON.stringify(t), "."));
                n = /\r\n/g;
            }
            const r = e.match(n);
            return r ? r.length : 0;
        },
        normalizeEndOfLine: function(e) {
            return e.replace(/\r\n?/g, "\n");
        }
    };
    const gc = au, { literalline: mc , join: yc  } = Zi, Dc = (e)=>Array.isArray(e) || e && "concat" === e.type
    , Ec = (e)=>{
        if (Array.isArray(e)) return e;
        if ("concat" !== e.type && "fill" !== e.type) throw new Error("Expect doc type to be `concat` or `fill`.");
        return e.parts;
    }, Cc = {
    };
    function bc(e, t, n, r) {
        const o = [
            e
        ];
        for(; o.length > 0;){
            const e = o.pop();
            if (e !== Cc) {
                if (n && o.push(e, Cc), !t || !1 !== t(e)) {
                    if (Dc(e) || "fill" === e.type) {
                        const t = Ec(e);
                        for(let e54 = t.length - 1; e54 >= 0; --e54)o.push(t[e54]);
                    } else if ("if-break" === e.type) e.flatContents && o.push(e.flatContents), e.breakContents && o.push(e.breakContents);
                    else if ("group" === e.type && e.expandedStates) {
                        if (r) for(let t = e.expandedStates.length - 1; t >= 0; --t)o.push(e.expandedStates[t]);
                        else o.push(e.contents);
                    } else e.contents && o.push(e.contents);
                }
            } else n(o.pop());
        }
    }
    function vc(e56, t) {
        const n15 = new Map;
        function r(e57) {
            if (n15.has(e57)) return n15.get(e57);
            const o10 = function(e) {
                if (Array.isArray(e)) return t(e.map(r));
                if ("concat" === e.type || "fill" === e.type) {
                    const n = e.parts.map(r);
                    return t(Object.assign(Object.assign({
                    }, e), {
                    }, {
                        parts: n
                    }));
                }
                if ("if-break" === e.type) {
                    const n = e.breakContents && r(e.breakContents), o = e.flatContents && r(e.flatContents);
                    return t(Object.assign(Object.assign({
                    }, e), {
                    }, {
                        breakContents: n,
                        flatContents: o
                    }));
                }
                if ("group" === e.type && e.expandedStates) {
                    const n = e.expandedStates.map(r), o = n[0];
                    return t(Object.assign(Object.assign({
                    }, e), {
                    }, {
                        contents: o,
                        expandedStates: n
                    }));
                }
                if (e.contents) {
                    const n = r(e.contents);
                    return t(Object.assign(Object.assign({
                    }, e), {
                    }, {
                        contents: n
                    }));
                }
                return t(e);
            }(e57);
            return n15.set(e57, o10), o10;
        }
        return r(e56);
    }
    function Ac(e58, t, n16) {
        let r = n16, o = !1;
        return bc(e58, function(e) {
            const n = t(e);
            if (void 0 !== n && (o = !0, r = n), o) return !1;
        }), r;
    }
    function Fc(e) {
        return !("group" !== e.type || !e.break) || !("line" !== e.type || !e.hard) || "break-parent" === e.type || void 0;
    }
    function xc(e) {
        if (e.length > 0) {
            const t = gc(e);
            t.expandedStates || t.break || (t.break = "propagated");
        }
        return null;
    }
    function Sc(e) {
        return "line" !== e.type || e.hard ? "if-break" === e.type ? e.flatContents || "" : e : e.soft ? "" : " ";
    }
    const wc = (e, t)=>e && "line" === e.type && e.hard && t && "break-parent" === t.type
    ;
    function Tc(e) {
        if (!e) return e;
        if (Dc(e) || "fill" === e.type) {
            const t = Ec(e);
            for(; t.length > 1 && wc(...t.slice(-2));)t.length -= 2;
            if (t.length > 0) {
                const e = Tc(gc(t));
                t[t.length - 1] = e;
            }
            return Array.isArray(e) ? t : Object.assign(Object.assign({
            }, e), {
            }, {
                parts: t
            });
        }
        switch(e.type){
            case "align":
            case "indent":
            case "indent-if-break":
            case "group":
            case "line-suffix":
            case "label":
                {
                    const t = Tc(e.contents);
                    return Object.assign(Object.assign({
                    }, e), {
                    }, {
                        contents: t
                    });
                }
            case "if-break":
                {
                    const t = Tc(e.breakContents), n = Tc(e.flatContents);
                    return Object.assign(Object.assign({
                    }, e), {
                    }, {
                        breakContents: t,
                        flatContents: n
                    });
                }
        }
        return e;
    }
    function Bc(e59) {
        return vc(e59, (e60)=>(function(e61) {
                switch(e61.type){
                    case "fill":
                        if (e61.parts.every((e)=>"" === e
                        )) return "";
                        break;
                    case "group":
                        if (!(e61.contents || e61.id || e61.break || e61.expandedStates)) return "";
                        if ("group" === e61.contents.type && e61.contents.id === e61.id && e61.contents.break === e61.break && e61.contents.expandedStates === e61.expandedStates) return e61.contents;
                        break;
                    case "align":
                    case "indent":
                    case "indent-if-break":
                    case "line-suffix":
                        if (!e61.contents) return "";
                        break;
                    case "if-break":
                        if (!e61.flatContents && !e61.breakContents) return "";
                }
                if (!Dc(e61)) return e61;
                const t = [];
                for (const n of Ec(e61)){
                    if (!n) continue;
                    const [e, ...r] = Dc(n) ? Ec(n) : [
                        n
                    ];
                    "string" == typeof e && "string" == typeof gc(t) ? t[t.length - 1] += e : t.push(e), t.push(...r);
                }
                return 0 === t.length ? "" : 1 === t.length ? t[0] : Array.isArray(e61) ? t : Object.assign(Object.assign({
                }, e61), {
                }, {
                    parts: t
                });
            })(e60)
        );
    }
    function Nc(e) {
        const t = [], n = e.filter(Boolean);
        for(; n.length > 0;){
            const e = n.shift();
            e && (Dc(e) ? n.unshift(...Ec(e)) : t.length > 0 && "string" == typeof gc(t) && "string" == typeof e ? t[t.length - 1] += e : t.push(e));
        }
        return t;
    }
    function kc(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : mc;
        return yc(t, e.split("\n")).parts;
    }
    function Pc(e) {
        if ("line" === e.type) return !0;
    }
    var Oc = {
        isConcat: Dc,
        getDocParts: Ec,
        willBreak: function(e) {
            return Ac(e, Fc, !1);
        },
        traverseDoc: bc,
        findInDoc: Ac,
        mapDoc: vc,
        propagateBreaks: function(e62) {
            const t = new Set, n = [];
            bc(e62, function(e) {
                if ("break-parent" === e.type && xc(n), "group" === e.type) {
                    if (n.push(e), t.has(e)) return !1;
                    t.add(e);
                }
            }, function(e) {
                if ("group" === e.type) n.pop().break && xc(n);
            }, !0);
        },
        removeLines: function(e) {
            return vc(e, Sc);
        },
        stripTrailingHardline: function(e) {
            return Tc(Bc(e));
        },
        normalizeParts: Nc,
        normalizeDoc: function(e63) {
            return vc(e63, (e)=>Array.isArray(e) ? Nc(e) : e.parts ? Object.assign(Object.assign({
                }, e), {
                }, {
                    parts: Nc(e.parts)
                }) : e
            );
        },
        cleanDoc: Bc,
        replaceTextEndOfLine: kc,
        replaceEndOfLine: function(e64) {
            return vc(e64, (e)=>"string" == typeof e && e.includes("\n") ? kc(e) : e
            );
        },
        canBreak: function(e) {
            return Ac(e, Pc, !1);
        }
    };
    const { getStringWidth: Ic , getLast: Lc  } = dc, { convertEndOfLineToChars: jc  } = hc, { fill: _c , cursor: Mc , indent: Rc  } = Zi, { isConcat: Vc , getDocParts: $c  } = Oc;
    let Wc;
    function qc(e, t) {
        return zc(e, {
            type: "indent"
        }, t);
    }
    function Uc(e, t, n) {
        if (t === Number.NEGATIVE_INFINITY) return e.root || {
            value: "",
            length: 0,
            queue: []
        };
        if (t < 0) return zc(e, {
            type: "dedent"
        }, n);
        if (!t) return e;
        if ("root" === t.type) return Object.assign(Object.assign({
        }, e), {
        }, {
            root: e
        });
        return zc(e, {
            type: "string" == typeof t ? "stringAlign" : "numberAlign",
            n: t
        }, n);
    }
    function zc(e66, t, n) {
        const r = "dedent" === t.type ? e66.queue.slice(0, -1) : [
            ...e66.queue,
            t
        ];
        let o = "", i = 0, u = 0, s = 0;
        for (const e65 of r)switch(e65.type){
            case "indent":
                l(), n.useTabs ? a(1) : c(n.tabWidth);
                break;
            case "stringAlign":
                l(), o += e65.n, i += e65.n.length;
                break;
            case "numberAlign":
                u += 1, s += e65.n;
                break;
            default:
                throw new Error("Unexpected type '".concat(e65.type, "'"));
        }
        function a(e) {
            o += "\t".repeat(e), i += n.tabWidth * e;
        }
        function c(e) {
            o += " ".repeat(e), i += e;
        }
        function l() {
            n.useTabs ? (function() {
                u > 0 && a(u);
                f();
            })() : p();
        }
        function p() {
            s > 0 && c(s), f();
        }
        function f() {
            u = 0, s = 0;
        }
        return p(), Object.assign(Object.assign({
        }, e66), {
        }, {
            value: o,
            length: i,
            queue: r
        });
    }
    function Gc(e) {
        if (0 === e.length) return 0;
        let t = 0;
        for(; e.length > 0 && "string" == typeof Lc(e) && /^[\t ]*$/.test(Lc(e));)t += e.pop().length;
        if (e.length > 0 && "string" == typeof Lc(e)) {
            const n = Lc(e).replace(/[\t ]*$/, "");
            t += Lc(e).length - n.length, e[e.length - 1] = n;
        }
        return t;
    }
    function Hc(e, t, n, r, o, i) {
        let u = t.length;
        const s = [
            e
        ], a = [];
        for(; n >= 0;){
            if (0 === s.length) {
                if (0 === u) return !0;
                s.push(t[u - 1]), u--;
                continue;
            }
            const [e, c, l] = s.pop();
            if ("string" == typeof l) a.push(l), n -= Ic(l);
            else if (Vc(l)) {
                const t = $c(l);
                for(let n = t.length - 1; n >= 0; n--)s.push([
                    e,
                    c,
                    t[n]
                ]);
            } else switch(l.type){
                case "indent":
                    s.push([
                        qc(e, r),
                        c,
                        l.contents
                    ]);
                    break;
                case "align":
                    s.push([
                        Uc(e, l.n, r),
                        c,
                        l.contents
                    ]);
                    break;
                case "trim":
                    n += Gc(a);
                    break;
                case "group":
                    {
                        if (i && l.break) return !1;
                        const t = l.break ? 1 : c;
                        s.push([
                            e,
                            t,
                            l.expandedStates && 1 === t ? Lc(l.expandedStates) : l.contents
                        ]), l.id && (Wc[l.id] = t);
                        break;
                    }
                case "fill":
                    for(let t23 = l.parts.length - 1; t23 >= 0; t23--)s.push([
                        e,
                        c,
                        l.parts[t23]
                    ]);
                    break;
                case "if-break":
                case "indent-if-break":
                    {
                        const t = l.groupId ? Wc[l.groupId] : c;
                        if (1 === t) {
                            const t = "if-break" === l.type ? l.breakContents : l.negate ? l.contents : Rc(l.contents);
                            t && s.push([
                                e,
                                c,
                                t
                            ]);
                        }
                        if (2 === t) {
                            const t = "if-break" === l.type ? l.flatContents : l.negate ? Rc(l.contents) : l.contents;
                            t && s.push([
                                e,
                                c,
                                t
                            ]);
                        }
                        break;
                    }
                case "line":
                    switch(c){
                        case 2:
                            if (!l.hard) {
                                l.soft || (a.push(" "), n -= 1);
                                break;
                            }
                            return !0;
                        case 1:
                            return !0;
                    }
                    break;
                case "line-suffix":
                    o = !0;
                    break;
                case "line-suffix-boundary":
                    if (o) return !1;
                    break;
                case "label":
                    s.push([
                        e,
                        c,
                        l.contents
                    ]);
            }
        }
        return !1;
    }
    var Jc = {
        printDocToString: function(e, t) {
            Wc = {
            };
            const n = t.printWidth, r = jc(t.endOfLine);
            let o = 0;
            const i = [
                [
                    {
                        value: "",
                        length: 0,
                        queue: []
                    },
                    1,
                    e
                ]
            ], u = [];
            let s = !1, a = [];
            for(; i.length > 0;){
                const [e, c, l] = i.pop();
                if ("string" == typeof l) {
                    const e = "\n" !== r ? l.replace(/\n/g, r) : l;
                    u.push(e), o += Ic(e);
                } else if (Vc(l)) {
                    const t = $c(l);
                    for(let n = t.length - 1; n >= 0; n--)i.push([
                        e,
                        c,
                        t[n]
                    ]);
                } else switch(l.type){
                    case "cursor":
                        u.push(Mc.placeholder);
                        break;
                    case "indent":
                        i.push([
                            qc(e, t),
                            c,
                            l.contents
                        ]);
                        break;
                    case "align":
                        i.push([
                            Uc(e, l.n, t),
                            c,
                            l.contents
                        ]);
                        break;
                    case "trim":
                        o -= Gc(u);
                        break;
                    case "group":
                        switch(c){
                            case 2:
                                if (!s) {
                                    i.push([
                                        e,
                                        l.break ? 1 : 2,
                                        l.contents
                                    ]);
                                    break;
                                }
                            case 1:
                                {
                                    s = !1;
                                    const r = [
                                        e,
                                        2,
                                        l.contents
                                    ], u = n - o, c = a.length > 0;
                                    if (!l.break && Hc(r, i, u, t, c)) i.push(r);
                                    else if (l.expandedStates) {
                                        const n = Lc(l.expandedStates);
                                        if (l.break) {
                                            i.push([
                                                e,
                                                1,
                                                n
                                            ]);
                                            break;
                                        }
                                        for(let r = 1; r < l.expandedStates.length + 1; r++){
                                            if (r >= l.expandedStates.length) {
                                                i.push([
                                                    e,
                                                    1,
                                                    n
                                                ]);
                                                break;
                                            }
                                            {
                                                const n = [
                                                    e,
                                                    2,
                                                    l.expandedStates[r]
                                                ];
                                                if (Hc(n, i, u, t, c)) {
                                                    i.push(n);
                                                    break;
                                                }
                                            }
                                        }
                                    } else i.push([
                                        e,
                                        1,
                                        l.contents
                                    ]);
                                    break;
                                }
                        }
                        l.id && (Wc[l.id] = Lc(i)[1]);
                        break;
                    case "fill":
                        {
                            const r = n - o, { parts: u  } = l;
                            if (0 === u.length) break;
                            const [s, p] = u, f = [
                                e,
                                2,
                                s
                            ], d = [
                                e,
                                1,
                                s
                            ], h = Hc(f, [], r, t, a.length > 0, !0);
                            if (1 === u.length) {
                                h ? i.push(f) : i.push(d);
                                break;
                            }
                            const g = [
                                e,
                                2,
                                p
                            ], m = [
                                e,
                                1,
                                p
                            ];
                            if (2 === u.length) {
                                h ? i.push(g, f) : i.push(m, d);
                                break;
                            }
                            u.splice(0, 2);
                            const y = [
                                e,
                                c,
                                _c(u)
                            ];
                            Hc([
                                e,
                                2,
                                [
                                    s,
                                    p,
                                    u[0]
                                ]
                            ], [], r, t, a.length > 0, !0) ? i.push(y, g, f) : h ? i.push(y, m, f) : i.push(y, m, d);
                            break;
                        }
                    case "if-break":
                    case "indent-if-break":
                        {
                            const t = l.groupId ? Wc[l.groupId] : c;
                            if (1 === t) {
                                const t = "if-break" === l.type ? l.breakContents : l.negate ? l.contents : Rc(l.contents);
                                t && i.push([
                                    e,
                                    c,
                                    t
                                ]);
                            }
                            if (2 === t) {
                                const t = "if-break" === l.type ? l.flatContents : l.negate ? Rc(l.contents) : l.contents;
                                t && i.push([
                                    e,
                                    c,
                                    t
                                ]);
                            }
                            break;
                        }
                    case "line-suffix":
                        a.push([
                            e,
                            c,
                            l.contents
                        ]);
                        break;
                    case "line-suffix-boundary":
                        a.length > 0 && i.push([
                            e,
                            c,
                            {
                                type: "line",
                                hard: !0
                            }
                        ]);
                        break;
                    case "line":
                        switch(c){
                            case 2:
                                if (!l.hard) {
                                    l.soft || (u.push(" "), o += 1);
                                    break;
                                }
                                s = !0;
                            case 1:
                                if (a.length > 0) {
                                    i.push([
                                        e,
                                        c,
                                        l
                                    ], ...a.reverse()), a = [];
                                    break;
                                }
                                l.literal ? e.root ? (u.push(r, e.root.value), o = e.root.length) : (u.push(r), o = 0) : (o -= Gc(u), u.push(r + e.value), o = e.length);
                        }
                        break;
                    case "label":
                        i.push([
                            e,
                            c,
                            l.contents
                        ]);
                }
                0 === i.length && a.length > 0 && (i.push(...a.reverse()), a = []);
            }
            const c = u.indexOf(Mc.placeholder);
            if (-1 !== c) {
                const e = u.indexOf(Mc.placeholder, c + 1), t = u.slice(0, c).join(""), n = u.slice(c + 1, e).join("");
                return {
                    formatted: t + n + u.slice(e + 1).join(""),
                    cursorNodeStart: t.length,
                    cursorNodeText: n
                };
            }
            return {
                formatted: u.join("")
            };
        }
    };
    const { isConcat: Xc , getDocParts: Yc  } = Oc;
    function Kc(e) {
        if (!e) return "";
        if (Xc(e)) {
            const t = [];
            for (const n of Yc(e))if (Xc(n)) t.push(...Kc(n).parts);
            else {
                const e = Kc(n);
                "" !== e && t.push(e);
            }
            return {
                type: "concat",
                parts: t
            };
        }
        return "if-break" === e.type ? Object.assign(Object.assign({
        }, e), {
        }, {
            breakContents: Kc(e.breakContents),
            flatContents: Kc(e.flatContents)
        }) : "group" === e.type ? Object.assign(Object.assign({
        }, e), {
        }, {
            contents: Kc(e.contents),
            expandedStates: e.expandedStates && e.expandedStates.map(Kc)
        }) : "fill" === e.type ? {
            type: "fill",
            parts: e.parts.map(Kc)
        } : e.contents ? Object.assign(Object.assign({
        }, e), {
        }, {
            contents: Kc(e.contents)
        }) : e;
    }
    var Qc = {
        printDocToDebug: function(e67) {
            const t24 = Object.create(null), n17 = new Set;
            function r8(e) {
                if ("symbol" != typeof e) return JSON.stringify(String(e));
                if (e in t24) return t24[e];
                const r = String(e).slice(7, -1) || "symbol";
                for(let o = 0;; o++){
                    const i = r + (o > 0 ? " #".concat(o) : "");
                    if (!n17.has(i)) return n17.add(i), t24[e] = "Symbol.for(".concat(JSON.stringify(i), ")");
                }
            }
            return (function e(t25, n, o) {
                if ("string" == typeof t25) return JSON.stringify(t25);
                if (Xc(t25)) {
                    const n = Yc(t25).map(e).filter(Boolean);
                    return 1 === n.length ? n[0] : "[".concat(n.join(", "), "]");
                }
                if ("line" === t25.type) {
                    const e = Array.isArray(o) && o[n + 1] && "break-parent" === o[n + 1].type;
                    return t25.literal ? e ? "literalline" : "literallineWithoutBreakParent" : t25.hard ? e ? "hardline" : "hardlineWithoutBreakParent" : t25.soft ? "softline" : "line";
                }
                if ("break-parent" === t25.type) return Array.isArray(o) && o[n - 1] && "line" === o[n - 1].type && o[n - 1].hard ? void 0 : "breakParent";
                if ("trim" === t25.type) return "trim";
                if ("indent" === t25.type) return "indent(" + e(t25.contents) + ")";
                if ("align" === t25.type) return t25.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e(t25.contents) + ")" : t25.n < 0 ? "dedent(" + e(t25.contents) + ")" : "root" === t25.n.type ? "markAsRoot(" + e(t25.contents) + ")" : "align(" + JSON.stringify(t25.n) + ", " + e(t25.contents) + ")";
                if ("if-break" === t25.type) return "ifBreak(" + e(t25.breakContents) + (t25.flatContents ? ", " + e(t25.flatContents) : "") + (t25.groupId ? (t25.flatContents ? "" : ', ""') + ", { groupId: ".concat(r8(t25.groupId), " }") : "") + ")";
                if ("indent-if-break" === t25.type) {
                    const n = [];
                    t25.negate && n.push("negate: true"), t25.groupId && n.push("groupId: ".concat(r8(t25.groupId)));
                    const o = n.length > 0 ? ", { ".concat(n.join(", "), " }") : "";
                    return "indentIfBreak(".concat(e(t25.contents)).concat(o, ")");
                }
                if ("group" === t25.type) {
                    const n = [];
                    t25.break && "propagated" !== t25.break && n.push("shouldBreak: true"), t25.id && n.push("id: ".concat(r8(t25.id)));
                    const o = n.length > 0 ? ", { ".concat(n.join(", "), " }") : "";
                    return t25.expandedStates ? "conditionalGroup([".concat(t25.expandedStates.map((t)=>e(t)
                    ).join(","), "]").concat(o, ")") : "group(".concat(e(t25.contents)).concat(o, ")");
                }
                if ("fill" === t25.type) return "fill([".concat(t25.parts.map((t)=>e(t)
                ).join(", "), "])");
                if ("line-suffix" === t25.type) return "lineSuffix(" + e(t25.contents) + ")";
                if ("line-suffix-boundary" === t25.type) return "lineSuffixBoundary";
                if ("label" === t25.type) return "label(".concat(JSON.stringify(t25.label), ", ").concat(e(t25.contents), ")");
                throw new Error("Unknown doc type " + t25.type);
            })(Kc(e67));
        }
    }, Zc = {
        builders: Zi,
        printer: Jc,
        utils: Oc,
        debug: Qc
    }, el = t3(Object.freeze({
        __proto__: null,
        default: {
        }
    }));
    function tl(e, t) {
        for(var n = 0, r = e.length - 1; r >= 0; r--){
            var o = e[r];
            "." === o ? e.splice(r, 1) : ".." === o ? (e.splice(r, 1), n++) : n && (e.splice(r, 1), n--);
        }
        if (t) for(; n--;)e.unshift("..");
        return e;
    }
    var nl = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, rl = function(e) {
        return nl.exec(e).slice(1);
    };
    function ol() {
        for(var e68 = "", t = !1, n = arguments.length - 1; n >= -1 && !t; n--){
            var r = n >= 0 ? arguments[n] : "/";
            if ("string" != typeof r) throw new TypeError("Arguments to path.resolve must be strings");
            r && (e68 = r + "/" + e68, t = "/" === r.charAt(0));
        }
        return e68 = tl(dl(e68.split("/"), function(e) {
            return !!e;
        }), !t).join("/"), (t ? "/" : "") + e68 || ".";
    }
    function il(e69) {
        var t = ul(e69), n = "/" === hl(e69, -1);
        return e69 = tl(dl(e69.split("/"), function(e) {
            return !!e;
        }), !t).join("/"), e69 || t || (e69 = "."), e69 && n && (e69 += "/"), (t ? "/" : "") + e69;
    }
    function ul(e) {
        return "/" === e.charAt(0);
    }
    function sl() {
        var e70 = Array.prototype.slice.call(arguments, 0);
        return il(dl(e70, function(e, t) {
            if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings");
            return e;
        }).join("/"));
    }
    function al(e71, t26) {
        function n18(e) {
            for(var t = 0; t < e.length && "" === e[t]; t++);
            for(var n = e.length - 1; n >= 0 && "" === e[n]; n--);
            return t > n ? [] : e.slice(t, n - t + 1);
        }
        e71 = ol(e71).substr(1), t26 = ol(t26).substr(1);
        for(var r = n18(e71.split("/")), o = n18(t26.split("/")), i = Math.min(r.length, o.length), u = i, s = 0; s < i; s++)if (r[s] !== o[s]) {
            u = s;
            break;
        }
        var a = [];
        for(s = u; s < r.length; s++)a.push("..");
        return (a = a.concat(o.slice(u))).join("/");
    }
    function cl(e) {
        var t = rl(e), n = t[0], r = t[1];
        return n || r ? (r && (r = r.substr(0, r.length - 1)), n + r) : ".";
    }
    function ll(e, t) {
        var n = rl(e)[2];
        return t && n.substr(-1 * t.length) === t && (n = n.substr(0, n.length - t.length)), n;
    }
    function pl(e) {
        return rl(e)[3];
    }
    var fl = {
        extname: pl,
        basename: ll,
        dirname: cl,
        sep: "/",
        delimiter: ":",
        relative: al,
        join: sl,
        isAbsolute: ul,
        normalize: il,
        resolve: ol
    };
    function dl(e, t) {
        if (e.filter) return e.filter(t);
        for(var n = [], r = 0; r < e.length; r++)t(e[r], r, e) && n.push(e[r]);
        return n;
    }
    var hl = "b" === "ab".substr(-1) ? function(e, t, n) {
        return e.substr(t, n);
    } : function(e, t, n) {
        return t < 0 && (t = e.length + t), e.substr(t, n);
    }, gl = t3(Object.freeze({
        __proto__: null,
        resolve: ol,
        normalize: il,
        isAbsolute: ul,
        join: sl,
        relative: al,
        sep: "/",
        delimiter: ":",
        dirname: cl,
        basename: ll,
        extname: pl,
        default: fl
    })), ml = [], yl = [], Dl = "undefined" != typeof Uint8Array ? Uint8Array : Array, El = !1;
    function Cl() {
        El = !0;
        for(var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, n = e.length; t < n; ++t)ml[t] = e[t], yl[e.charCodeAt(t)] = t;
        yl["-".charCodeAt(0)] = 62, yl["_".charCodeAt(0)] = 63;
    }
    function bl(e, t, n) {
        for(var r, o, i = [], u = t; u < n; u += 3)r = (e[u] << 16) + (e[u + 1] << 8) + e[u + 2], i.push(ml[(o = r) >> 18 & 63] + ml[o >> 12 & 63] + ml[o >> 6 & 63] + ml[63 & o]);
        return i.join("");
    }
    function vl(e) {
        var t;
        El || Cl();
        for(var n = e.length, r = n % 3, o = "", i = [], u = 16383, s = 0, a = n - r; s < a; s += u)i.push(bl(e, s, s + u > a ? a : s + u));
        return 1 === r ? (t = e[n - 1], o += ml[t >> 2], o += ml[t << 4 & 63], o += "==") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], o += ml[t >> 10], o += ml[t >> 4 & 63], o += ml[t << 2 & 63], o += "="), i.push(o), i.join("");
    }
    function Al(e, t, n, r, o) {
        var i, u, s = 8 * o - r - 1, a = (1 << s) - 1, c = a >> 1, l = -7, p = n ? o - 1 : 0, f = n ? -1 : 1, d = e[t + p];
        for(p += f, i = d & (1 << -l) - 1, d >>= -l, l += s; l > 0; i = 256 * i + e[t + p], p += f, l -= 8);
        for(u = i & (1 << -l) - 1, i >>= -l, l += r; l > 0; u = 256 * u + e[t + p], p += f, l -= 8);
        if (0 === i) i = 1 - c;
        else {
            if (i === a) return u ? NaN : 1 / 0 * (d ? -1 : 1);
            u += Math.pow(2, r), i -= c;
        }
        return (d ? -1 : 1) * u * Math.pow(2, i - r);
    }
    function Fl(e, t, n, r, o, i) {
        var u, s, a, c = 8 * i - o - 1, l = (1 << c) - 1, p = l >> 1, f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : i - 1, h = r ? 1 : -1, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
        for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, u = l) : (u = Math.floor(Math.log(t) / Math.LN2), t * (a = Math.pow(2, -u)) < 1 && (u--, a *= 2), (t += u + p >= 1 ? f / a : f * Math.pow(2, 1 - p)) * a >= 2 && (u++, a /= 2), u + p >= l ? (s = 0, u = l) : u + p >= 1 ? (s = (t * a - 1) * Math.pow(2, o), u += p) : (s = t * Math.pow(2, p - 1) * Math.pow(2, o), u = 0)); o >= 8; e[n + d] = 255 & s, d += h, s /= 256, o -= 8);
        for(u = u << o | s, c += o; c > 0; e[n + d] = 255 & u, d += h, u /= 256, c -= 8);
        e[n + d - h] |= 128 * g;
    }
    var xl = {
    }.toString, Sl = Array.isArray || function(e) {
        return "[object Array]" == xl.call(e);
    };
    function wl() {
        return Bl.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    function Tl(e, t) {
        if (wl() < t) throw new RangeError("Invalid typed array length");
        return Bl.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = Bl.prototype : (null === e && (e = new Bl(t)), e.length = t), e;
    }
    function Bl(e, t, n) {
        if (!(Bl.TYPED_ARRAY_SUPPORT || this instanceof Bl)) return new Bl(e, t, n);
        if ("number" == typeof e) {
            if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
            return Pl(this, e);
        }
        return Nl(this, e, t, n);
    }
    function Nl(e72, t27, n19, r9) {
        if ("number" == typeof t27) throw new TypeError('"value" argument must not be a number');
        return "undefined" != typeof ArrayBuffer && t27 instanceof ArrayBuffer ? (function(e, t, n, r) {
            if (t.byteLength, n < 0 || t.byteLength < n) throw new RangeError("'offset' is out of bounds");
            if (t.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds");
            t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r);
            Bl.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = Bl.prototype : e = Ol(e, t);
            return e;
        })(e72, t27, n19, r9) : "string" == typeof t27 ? (function(e, t, n) {
            "string" == typeof n && "" !== n || (n = "utf8");
            if (!Bl.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding');
            var r = 0 | jl(t, n), o = (e = Tl(e, r)).write(t, n);
            o !== r && (e = e.slice(0, o));
            return e;
        })(e72, t27, n19) : (function(e, t) {
            if (Ll(t)) {
                var n = 0 | Il(t.length);
                return 0 === (e = Tl(e, n)).length || t.copy(e, 0, 0, n), e;
            }
            if (t) {
                if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || (r = t.length) != r ? Tl(e, 0) : Ol(e, t);
                if ("Buffer" === t.type && Sl(t.data)) return Ol(e, t.data);
            }
            var r;
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        })(e72, t27);
    }
    function kl(e) {
        if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
        if (e < 0) throw new RangeError('"size" argument must not be negative');
    }
    function Pl(e, t) {
        if (kl(t), e = Tl(e, t < 0 ? 0 : 0 | Il(t)), !Bl.TYPED_ARRAY_SUPPORT) for(var n = 0; n < t; ++n)e[n] = 0;
        return e;
    }
    function Ol(e, t) {
        var n = t.length < 0 ? 0 : 0 | Il(t.length);
        e = Tl(e, n);
        for(var r = 0; r < n; r += 1)e[r] = 255 & t[r];
        return e;
    }
    function Il(e) {
        if (e >= wl()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + wl().toString(16) + " bytes");
        return 0 | e;
    }
    function Ll(e) {
        return !(null == e || !e._isBuffer);
    }
    function jl(e, t) {
        if (Ll(e)) return e.length;
        if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
        "string" != typeof e && (e = "" + e);
        var n = e.length;
        if (0 === n) return 0;
        for(var r = !1;;)switch(t){
            case "ascii":
            case "latin1":
            case "binary":
                return n;
            case "utf8":
            case "utf-8":
            case void 0:
                return cp(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return 2 * n;
            case "hex":
                return n >>> 1;
            case "base64":
                return lp(e).length;
            default:
                if (r) return cp(e).length;
                t = ("" + t).toLowerCase(), r = !0;
        }
    }
    function _l(e, t, n) {
        var r = !1;
        if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
        if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
        if ((n >>>= 0) <= (t >>>= 0)) return "";
        for(e || (e = "utf8");;)switch(e){
            case "hex":
                return Ql(this, t, n);
            case "utf8":
            case "utf-8":
                return Jl(this, t, n);
            case "ascii":
                return Yl(this, t, n);
            case "latin1":
            case "binary":
                return Kl(this, t, n);
            case "base64":
                return Hl(this, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Zl(this, t, n);
            default:
                if (r) throw new TypeError("Unknown encoding: " + e);
                e = (e + "").toLowerCase(), r = !0;
        }
    }
    function Ml(e, t, n) {
        var r = e[t];
        e[t] = e[n], e[n] = r;
    }
    function Rl(e, t, n, r, o) {
        if (0 === e.length) return -1;
        if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
            if (o) return -1;
            n = e.length - 1;
        } else if (n < 0) {
            if (!o) return -1;
            n = 0;
        }
        if ("string" == typeof t && (t = Bl.from(t, r)), Ll(t)) return 0 === t.length ? -1 : Vl(e, t, n, r, o);
        if ("number" == typeof t) return t &= 255, Bl.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : Vl(e, [
            t
        ], n, r, o);
        throw new TypeError("val must be string, number or Buffer");
    }
    function Vl(e73, t28, n, r, o) {
        var i, u = 1, s = e73.length, a = t28.length;
        if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
            if (e73.length < 2 || t28.length < 2) return -1;
            u = 2, s /= 2, a /= 2, n /= 2;
        }
        function c(e, t) {
            return 1 === u ? e[t] : e.readUInt16BE(t * u);
        }
        if (o) {
            var l = -1;
            for(i = n; i < s; i++)if (c(e73, i) === c(t28, -1 === l ? 0 : i - l)) {
                if (-1 === l && (l = i), i - l + 1 === a) return l * u;
            } else -1 !== l && (i -= i - l), l = -1;
        } else for(n + a > s && (n = s - a), i = n; i >= 0; i--){
            for(var p = !0, f = 0; f < a; f++)if (c(e73, i + f) !== c(t28, f)) {
                p = !1;
                break;
            }
            if (p) return i;
        }
        return -1;
    }
    function $l(e, t, n, r) {
        n = Number(n) || 0;
        var o = e.length - n;
        r ? (r = Number(r)) > o && (r = o) : r = o;
        var i = t.length;
        if (i % 2 != 0) throw new TypeError("Invalid hex string");
        r > i / 2 && (r = i / 2);
        for(var u = 0; u < r; ++u){
            var s = parseInt(t.substr(2 * u, 2), 16);
            if (isNaN(s)) return u;
            e[n + u] = s;
        }
        return u;
    }
    function Wl(e, t, n, r) {
        return pp(cp(t, e.length - n), e, n, r);
    }
    function ql(e74, t29, n20, r) {
        return pp(function(e) {
            for(var t = [], n = 0; n < e.length; ++n)t.push(255 & e.charCodeAt(n));
            return t;
        }(t29), e74, n20, r);
    }
    function Ul(e, t, n, r) {
        return ql(e, t, n, r);
    }
    function zl(e, t, n, r) {
        return pp(lp(t), e, n, r);
    }
    function Gl(e75, t30, n21, r10) {
        return pp(function(e, t) {
            for(var n, r, o, i = [], u = 0; u < e.length && !((t -= 2) < 0); ++u)r = (n = e.charCodeAt(u)) >> 8, o = n % 256, i.push(o), i.push(r);
            return i;
        }(t30, e75.length - n21), e75, n21, r10);
    }
    function Hl(e, t, n) {
        return 0 === t && n === e.length ? vl(e) : vl(e.slice(t, n));
    }
    function Jl(e76, t31, n22) {
        n22 = Math.min(e76.length, n22);
        for(var r11 = [], o = t31; o < n22;){
            var i, u, s, a, c = e76[o], l = null, p = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
            if (o + p <= n22) switch(p){
                case 1:
                    c < 128 && (l = c);
                    break;
                case 2:
                    128 == (192 & (i = e76[o + 1])) && (a = (31 & c) << 6 | 63 & i) > 127 && (l = a);
                    break;
                case 3:
                    i = e76[o + 1], u = e76[o + 2], 128 == (192 & i) && 128 == (192 & u) && (a = (15 & c) << 12 | (63 & i) << 6 | 63 & u) > 2047 && (a < 55296 || a > 57343) && (l = a);
                    break;
                case 4:
                    i = e76[o + 1], u = e76[o + 2], s = e76[o + 3], 128 == (192 & i) && 128 == (192 & u) && 128 == (192 & s) && (a = (15 & c) << 18 | (63 & i) << 12 | (63 & u) << 6 | 63 & s) > 65535 && a < 1114112 && (l = a);
            }
            null === l ? (l = 65533, p = 1) : l > 65535 && (l -= 65536, r11.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), r11.push(l), o += p;
        }
        return (function(e) {
            var t = e.length;
            if (t <= Xl) return String.fromCharCode.apply(String, e);
            var n = "", r = 0;
            for(; r < t;)n += String.fromCharCode.apply(String, e.slice(r, r += Xl));
            return n;
        })(r11);
    }
    Bl.TYPED_ARRAY_SUPPORT = void 0 === Ns.TYPED_ARRAY_SUPPORT || Ns.TYPED_ARRAY_SUPPORT, Bl.poolSize = 8192, Bl._augment = function(e) {
        return e.__proto__ = Bl.prototype, e;
    }, Bl.from = function(e, t, n) {
        return Nl(null, e, t, n);
    }, Bl.TYPED_ARRAY_SUPPORT && (Bl.prototype.__proto__ = Uint8Array.prototype, Bl.__proto__ = Uint8Array), Bl.alloc = function(e77, t32, n23) {
        return (function(e, t, n, r) {
            return kl(t), t <= 0 ? Tl(e, t) : void 0 !== n ? "string" == typeof r ? Tl(e, t).fill(n, r) : Tl(e, t).fill(n) : Tl(e, t);
        })(null, e77, t32, n23);
    }, Bl.allocUnsafe = function(e) {
        return Pl(null, e);
    }, Bl.allocUnsafeSlow = function(e) {
        return Pl(null, e);
    }, Bl.isBuffer = fp, Bl.compare = function(e, t) {
        if (!Ll(e) || !Ll(t)) throw new TypeError("Arguments must be Buffers");
        if (e === t) return 0;
        for(var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o)if (e[o] !== t[o]) {
            n = e[o], r = t[o];
            break;
        }
        return n < r ? -1 : r < n ? 1 : 0;
    }, Bl.isEncoding = function(e) {
        switch(String(e).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, Bl.concat = function(e, t) {
        if (!Sl(e)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === e.length) return Bl.alloc(0);
        var n;
        if (void 0 === t) for(t = 0, n = 0; n < e.length; ++n)t += e[n].length;
        var r = Bl.allocUnsafe(t), o = 0;
        for(n = 0; n < e.length; ++n){
            var i = e[n];
            if (!Ll(i)) throw new TypeError('"list" argument must be an Array of Buffers');
            i.copy(r, o), o += i.length;
        }
        return r;
    }, Bl.byteLength = jl, Bl.prototype._isBuffer = !0, Bl.prototype.swap16 = function() {
        var e = this.length;
        if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(var t = 0; t < e; t += 2)Ml(this, t, t + 1);
        return this;
    }, Bl.prototype.swap32 = function() {
        var e = this.length;
        if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(var t = 0; t < e; t += 4)Ml(this, t, t + 3), Ml(this, t + 1, t + 2);
        return this;
    }, Bl.prototype.swap64 = function() {
        var e = this.length;
        if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(var t = 0; t < e; t += 8)Ml(this, t, t + 7), Ml(this, t + 1, t + 6), Ml(this, t + 2, t + 5), Ml(this, t + 3, t + 4);
        return this;
    }, Bl.prototype.toString = function() {
        var e = 0 | this.length;
        return 0 === e ? "" : 0 === arguments.length ? Jl(this, 0, e) : _l.apply(this, arguments);
    }, Bl.prototype.equals = function(e) {
        if (!Ll(e)) throw new TypeError("Argument must be a Buffer");
        return this === e || 0 === Bl.compare(this, e);
    }, Bl.prototype.inspect = function() {
        var e = "";
        return this.length > 0 && (e = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e += " ... ")), "<Buffer " + e + ">";
    }, Bl.prototype.compare = function(e, t, n, r, o) {
        if (!Ll(e)) throw new TypeError("Argument must be a Buffer");
        if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), t < 0 || n > e.length || r < 0 || o > this.length) throw new RangeError("out of range index");
        if (r >= o && t >= n) return 0;
        if (r >= o) return -1;
        if (t >= n) return 1;
        if (this === e) return 0;
        for(var i = (o >>>= 0) - (r >>>= 0), u = (n >>>= 0) - (t >>>= 0), s = Math.min(i, u), a = this.slice(r, o), c = e.slice(t, n), l = 0; l < s; ++l)if (a[l] !== c[l]) {
            i = a[l], u = c[l];
            break;
        }
        return i < u ? -1 : u < i ? 1 : 0;
    }, Bl.prototype.includes = function(e, t, n) {
        return -1 !== this.indexOf(e, t, n);
    }, Bl.prototype.indexOf = function(e, t, n) {
        return Rl(this, e, t, n, !0);
    }, Bl.prototype.lastIndexOf = function(e, t, n) {
        return Rl(this, e, t, n, !1);
    }, Bl.prototype.write = function(e, t, n, r) {
        if (void 0 === t) r = "utf8", n = this.length, t = 0;
        else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0;
        else {
            if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0);
        }
        var o = this.length - t;
        if ((void 0 === n || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        r || (r = "utf8");
        for(var i = !1;;)switch(r){
            case "hex":
                return $l(this, e, t, n);
            case "utf8":
            case "utf-8":
                return Wl(this, e, t, n);
            case "ascii":
                return ql(this, e, t, n);
            case "latin1":
            case "binary":
                return Ul(this, e, t, n);
            case "base64":
                return zl(this, e, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Gl(this, e, t, n);
            default:
                if (i) throw new TypeError("Unknown encoding: " + r);
                r = ("" + r).toLowerCase(), i = !0;
        }
    }, Bl.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    var Xl = 4096;
    function Yl(e, t, n) {
        var r = "";
        n = Math.min(e.length, n);
        for(var o = t; o < n; ++o)r += String.fromCharCode(127 & e[o]);
        return r;
    }
    function Kl(e, t, n) {
        var r = "";
        n = Math.min(e.length, n);
        for(var o = t; o < n; ++o)r += String.fromCharCode(e[o]);
        return r;
    }
    function Ql(e, t, n) {
        var r = e.length;
        (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
        for(var o = "", i = t; i < n; ++i)o += ap(e[i]);
        return o;
    }
    function Zl(e, t, n) {
        for(var r = e.slice(t, n), o = "", i = 0; i < r.length; i += 2)o += String.fromCharCode(r[i] + 256 * r[i + 1]);
        return o;
    }
    function ep(e, t, n) {
        if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
        if (e + t > n) throw new RangeError("Trying to access beyond buffer length");
    }
    function tp(e, t, n, r, o, i) {
        if (!Ll(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t > o || t < i) throw new RangeError('"value" argument is out of bounds');
        if (n + r > e.length) throw new RangeError("Index out of range");
    }
    function np(e, t, n, r) {
        t < 0 && (t = 65535 + t + 1);
        for(var o = 0, i = Math.min(e.length - n, 2); o < i; ++o)e[n + o] = (t & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o);
    }
    function rp(e, t, n, r) {
        t < 0 && (t = 4294967295 + t + 1);
        for(var o = 0, i = Math.min(e.length - n, 4); o < i; ++o)e[n + o] = t >>> 8 * (r ? o : 3 - o) & 255;
    }
    function op(e, t, n, r, o, i) {
        if (n + r > e.length) throw new RangeError("Index out of range");
        if (n < 0) throw new RangeError("Index out of range");
    }
    function ip(e, t, n, r, o) {
        return o || op(e, 0, n, 4), Fl(e, t, n, r, 23, 4), n + 4;
    }
    function up(e, t, n, r, o) {
        return o || op(e, 0, n, 8), Fl(e, t, n, r, 52, 8), n + 8;
    }
    Bl.prototype.slice = function(e, t) {
        var n, r = this.length;
        if ((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e), Bl.TYPED_ARRAY_SUPPORT) (n = this.subarray(e, t)).__proto__ = Bl.prototype;
        else {
            var o = t - e;
            n = new Bl(o, void 0);
            for(var i = 0; i < o; ++i)n[i] = this[i + e];
        }
        return n;
    }, Bl.prototype.readUIntLE = function(e, t, n) {
        e |= 0, t |= 0, n || ep(e, t, this.length);
        for(var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)r += this[e + i] * o;
        return r;
    }, Bl.prototype.readUIntBE = function(e, t, n) {
        e |= 0, t |= 0, n || ep(e, t, this.length);
        for(var r = this[e + --t], o = 1; t > 0 && (o *= 256);)r += this[e + --t] * o;
        return r;
    }, Bl.prototype.readUInt8 = function(e, t) {
        return t || ep(e, 1, this.length), this[e];
    }, Bl.prototype.readUInt16LE = function(e, t) {
        return t || ep(e, 2, this.length), this[e] | this[e + 1] << 8;
    }, Bl.prototype.readUInt16BE = function(e, t) {
        return t || ep(e, 2, this.length), this[e] << 8 | this[e + 1];
    }, Bl.prototype.readUInt32LE = function(e, t) {
        return t || ep(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];
    }, Bl.prototype.readUInt32BE = function(e, t) {
        return t || ep(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    }, Bl.prototype.readIntLE = function(e, t, n) {
        e |= 0, t |= 0, n || ep(e, t, this.length);
        for(var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)r += this[e + i] * o;
        return r >= (o *= 128) && (r -= Math.pow(2, 8 * t)), r;
    }, Bl.prototype.readIntBE = function(e, t, n) {
        e |= 0, t |= 0, n || ep(e, t, this.length);
        for(var r = t, o = 1, i = this[e + --r]; r > 0 && (o *= 256);)i += this[e + --r] * o;
        return i >= (o *= 128) && (i -= Math.pow(2, 8 * t)), i;
    }, Bl.prototype.readInt8 = function(e, t) {
        return t || ep(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
    }, Bl.prototype.readInt16LE = function(e, t) {
        t || ep(e, 2, this.length);
        var n = this[e] | this[e + 1] << 8;
        return 32768 & n ? 4294901760 | n : n;
    }, Bl.prototype.readInt16BE = function(e, t) {
        t || ep(e, 2, this.length);
        var n = this[e + 1] | this[e] << 8;
        return 32768 & n ? 4294901760 | n : n;
    }, Bl.prototype.readInt32LE = function(e, t) {
        return t || ep(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    }, Bl.prototype.readInt32BE = function(e, t) {
        return t || ep(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    }, Bl.prototype.readFloatLE = function(e, t) {
        return t || ep(e, 4, this.length), Al(this, e, !0, 23, 4);
    }, Bl.prototype.readFloatBE = function(e, t) {
        return t || ep(e, 4, this.length), Al(this, e, !1, 23, 4);
    }, Bl.prototype.readDoubleLE = function(e, t) {
        return t || ep(e, 8, this.length), Al(this, e, !0, 52, 8);
    }, Bl.prototype.readDoubleBE = function(e, t) {
        return t || ep(e, 8, this.length), Al(this, e, !1, 52, 8);
    }, Bl.prototype.writeUIntLE = function(e, t, n, r) {
        (e = +e, t |= 0, n |= 0, r) || tp(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
        var o = 1, i = 0;
        for(this[t] = 255 & e; ++i < n && (o *= 256);)this[t + i] = e / o & 255;
        return t + n;
    }, Bl.prototype.writeUIntBE = function(e, t, n, r) {
        (e = +e, t |= 0, n |= 0, r) || tp(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
        var o = n - 1, i = 1;
        for(this[t + o] = 255 & e; --o >= 0 && (i *= 256);)this[t + o] = e / i & 255;
        return t + n;
    }, Bl.prototype.writeUInt8 = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 1, 255, 0), Bl.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1;
    }, Bl.prototype.writeUInt16LE = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 2, 65535, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : np(this, e, t, !0), t + 2;
    }, Bl.prototype.writeUInt16BE = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 2, 65535, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : np(this, e, t, !1), t + 2;
    }, Bl.prototype.writeUInt32LE = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 4, 4294967295, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : rp(this, e, t, !0), t + 4;
    }, Bl.prototype.writeUInt32BE = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 4, 4294967295, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : rp(this, e, t, !1), t + 4;
    }, Bl.prototype.writeIntLE = function(e, t, n, r) {
        if (e = +e, t |= 0, !r) {
            var o = Math.pow(2, 8 * n - 1);
            tp(this, e, t, n, o - 1, -o);
        }
        var i = 0, u = 1, s = 0;
        for(this[t] = 255 & e; ++i < n && (u *= 256);)e < 0 && 0 === s && 0 !== this[t + i - 1] && (s = 1), this[t + i] = (e / u >> 0) - s & 255;
        return t + n;
    }, Bl.prototype.writeIntBE = function(e, t, n, r) {
        if (e = +e, t |= 0, !r) {
            var o = Math.pow(2, 8 * n - 1);
            tp(this, e, t, n, o - 1, -o);
        }
        var i = n - 1, u = 1, s = 0;
        for(this[t + i] = 255 & e; --i >= 0 && (u *= 256);)e < 0 && 0 === s && 0 !== this[t + i + 1] && (s = 1), this[t + i] = (e / u >> 0) - s & 255;
        return t + n;
    }, Bl.prototype.writeInt8 = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 1, 127, -128), Bl.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1;
    }, Bl.prototype.writeInt16LE = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 2, 32767, -32768), Bl.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : np(this, e, t, !0), t + 2;
    }, Bl.prototype.writeInt16BE = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 2, 32767, -32768), Bl.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : np(this, e, t, !1), t + 2;
    }, Bl.prototype.writeInt32LE = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 4, 2147483647, -2147483648), Bl.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : rp(this, e, t, !0), t + 4;
    }, Bl.prototype.writeInt32BE = function(e, t, n) {
        return e = +e, t |= 0, n || tp(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), Bl.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : rp(this, e, t, !1), t + 4;
    }, Bl.prototype.writeFloatLE = function(e, t, n) {
        return ip(this, e, t, !0, n);
    }, Bl.prototype.writeFloatBE = function(e, t, n) {
        return ip(this, e, t, !1, n);
    }, Bl.prototype.writeDoubleLE = function(e, t, n) {
        return up(this, e, t, !0, n);
    }, Bl.prototype.writeDoubleBE = function(e, t, n) {
        return up(this, e, t, !1, n);
    }, Bl.prototype.copy = function(e, t, n, r) {
        if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0;
        if (0 === e.length || 0 === this.length) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
        if (r < 0) throw new RangeError("sourceEnd out of bounds");
        r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
        var o, i = r - n;
        if (this === e && n < t && t < r) for(o = i - 1; o >= 0; --o)e[o + t] = this[o + n];
        else if (i < 1000 || !Bl.TYPED_ARRAY_SUPPORT) for(o = 0; o < i; ++o)e[o + t] = this[o + n];
        else Uint8Array.prototype.set.call(e, this.subarray(n, n + i), t);
        return i;
    }, Bl.prototype.fill = function(e, t, n, r) {
        if ("string" == typeof e) {
            if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) {
                var o = e.charCodeAt(0);
                o < 256 && (e = o);
            }
            if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string");
            if ("string" == typeof r && !Bl.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
        } else "number" == typeof e && (e &= 255);
        if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
        if (n <= t) return this;
        var i;
        if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e) for(i = t; i < n; ++i)this[i] = e;
        else {
            var u = Ll(e) ? e : cp(new Bl(e, r).toString()), s = u.length;
            for(i = 0; i < n - t; ++i)this[i + t] = u[i % s];
        }
        return this;
    };
    var sp = /[^+\/0-9A-Za-z-_]/g;
    function ap(e) {
        return e < 16 ? "0" + e.toString(16) : e.toString(16);
    }
    function cp(e, t) {
        var n;
        t = t || 1 / 0;
        for(var r = e.length, o = null, i = [], u = 0; u < r; ++u){
            if ((n = e.charCodeAt(u)) > 55295 && n < 57344) {
                if (!o) {
                    if (n > 56319) {
                        (t -= 3) > -1 && i.push(239, 191, 189);
                        continue;
                    }
                    if (u + 1 === r) {
                        (t -= 3) > -1 && i.push(239, 191, 189);
                        continue;
                    }
                    o = n;
                    continue;
                }
                if (n < 56320) {
                    (t -= 3) > -1 && i.push(239, 191, 189), o = n;
                    continue;
                }
                n = 65536 + (o - 55296 << 10 | n - 56320);
            } else o && (t -= 3) > -1 && i.push(239, 191, 189);
            if (o = null, n < 128) {
                if ((t -= 1) < 0) break;
                i.push(n);
            } else if (n < 2048) {
                if ((t -= 2) < 0) break;
                i.push(n >> 6 | 192, 63 & n | 128);
            } else if (n < 65536) {
                if ((t -= 3) < 0) break;
                i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);
            } else {
                if (!(n < 1114112)) throw new Error("Invalid code point");
                if ((t -= 4) < 0) break;
                i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);
            }
        }
        return i;
    }
    function lp(e78) {
        return (function(e) {
            var t, n, r, o, i, u;
            El || Cl();
            var s = e.length;
            if (s % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            i = "=" === e[s - 2] ? 2 : "=" === e[s - 1] ? 1 : 0, u = new Dl(3 * s / 4 - i), r = i > 0 ? s - 4 : s;
            var a = 0;
            for(t = 0, n = 0; t < r; t += 4, n += 3)o = yl[e.charCodeAt(t)] << 18 | yl[e.charCodeAt(t + 1)] << 12 | yl[e.charCodeAt(t + 2)] << 6 | yl[e.charCodeAt(t + 3)], u[a++] = o >> 16 & 255, u[a++] = o >> 8 & 255, u[a++] = 255 & o;
            return 2 === i ? (o = yl[e.charCodeAt(t)] << 2 | yl[e.charCodeAt(t + 1)] >> 4, u[a++] = 255 & o) : 1 === i && (o = yl[e.charCodeAt(t)] << 10 | yl[e.charCodeAt(t + 1)] << 4 | yl[e.charCodeAt(t + 2)] >> 2, u[a++] = o >> 8 & 255, u[a++] = 255 & o), u;
        })(function(e79) {
            if ((e79 = (function(e) {
                return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
            })(e79).replace(sp, "")).length < 2) return "";
            for(; e79.length % 4 != 0;)e79 += "=";
            return e79;
        }(e78));
    }
    function pp(e, t, n, r) {
        for(var o = 0; o < r && !(o + n >= t.length || o >= e.length); ++o)t[o + n] = e[o];
        return o;
    }
    function fp(e80) {
        return null != e80 && (!!e80._isBuffer || dp(e80) || (function(e) {
            return "function" == typeof e.readFloatLE && "function" == typeof e.slice && dp(e.slice(0, 0));
        })(e80));
    }
    function dp(e) {
        return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e);
    }
    const hp = el;
    var gp = class {
        constructor(e, t){
            (t = t || {
            }).readChunk || (t.readChunk = 1024), t.newLineCharacter ? t.newLineCharacter = t.newLineCharacter.charCodeAt(0) : t.newLineCharacter = 10, this.fd = "number" == typeof e ? e : hp.openSync(e, "r"), this.options = t, this.newLineCharacter = t.newLineCharacter, this.reset();
        }
        _searchInBuffer(e, t) {
            let n = -1;
            for(let r = 0; r <= e.length; r++)if (e[r] === t) {
                n = r;
                break;
            }
            return n;
        }
        reset() {
            this.eofReached = !1, this.linesCache = [], this.fdPosition = 0;
        }
        close() {
            hp.closeSync(this.fd), this.fd = null;
        }
        _extractLines(e) {
            let t;
            const n = [];
            let r = 0, o = 0;
            for(;;){
                let i = e[r++];
                if (i === this.newLineCharacter) t = e.slice(o, r), n.push(t), o = r;
                else if (void 0 === i) break;
            }
            let i = e.slice(o, r);
            return i.length && n.push(i), n;
        }
        _readChunk(e) {
            let t, n = 0;
            const r = [];
            do {
                const e = new Bl(this.options.readChunk);
                t = hp.readSync(this.fd, e, 0, this.options.readChunk, this.fdPosition), n += t, this.fdPosition = this.fdPosition + t, r.push(e);
            }while (t && -1 === this._searchInBuffer(r[r.length - 1], this.options.newLineCharacter))
            let o = Bl.concat(r);
            return t < this.options.readChunk && (this.eofReached = !0, o = o.slice(0, n)), n && (this.linesCache = this._extractLines(o), e && (this.linesCache[0] = Bl.concat([
                e,
                this.linesCache[0]
            ]))), n;
        }
        next() {
            if (!this.fd) return !1;
            let e, t = !1;
            if (this.eofReached && 0 === this.linesCache.length) return t;
            if (this.linesCache.length || (e = this._readChunk()), this.linesCache.length) {
                t = this.linesCache.shift();
                t[t.length - 1] !== this.newLineCharacter && (e = this._readChunk(t), e && (t = this.linesCache.shift()));
            }
            return this.eofReached && 0 === this.linesCache.length && this.close(), t && t[t.length - 1] === this.newLineCharacter && (t = t.slice(0, t.length - 1)), t;
        }
    };
    class mp extends Error {
    }
    class yp extends Error {
    }
    class Dp extends Error {
    }
    class Ep extends Error {
    }
    var Cp = {
        ConfigError: mp,
        DebugError: yp,
        UndefinedParserError: Dp,
        ArgExpansionBailout: Ep
    }, bp = {
    }, vp = function(e81, t33) {
        return vp = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(e, t) {
            e.__proto__ = t;
        } || function(e, t) {
            for(var n in t)t.hasOwnProperty(n) && (e[n] = t[n]);
        }, vp(e81, t33);
    };
    var Ap = function() {
        return Ap = Object.assign || function(e) {
            for(var t, n = 1, r = arguments.length; n < r; n++)for(var o in t = arguments[n])Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
            return e;
        }, Ap.apply(this, arguments);
    };
    function Fp(e) {
        var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0;
        if (n) return n.call(e);
        if (e && "number" == typeof e.length) return {
            next: function() {
                return e && r >= e.length && (e = void 0), {
                    value: e && e[r++],
                    done: !e
                };
            }
        };
        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function xp(e, t) {
        var n = "function" == typeof Symbol && e[Symbol.iterator];
        if (!n) return e;
        var r, o, i = n.call(e), u = [];
        try {
            for(; (void 0 === t || t-- > 0) && !(r = i.next()).done;)u.push(r.value);
        } catch (e82) {
            o = {
                error: e82
            };
        } finally{
            try {
                r && !r.done && (n = i.return) && n.call(i);
            } finally{
                if (o) throw o.error;
            }
        }
        return u;
    }
    function Sp(e) {
        return this instanceof Sp ? (this.v = e, this) : new Sp(e);
    }
    var wp = Object.freeze({
        __proto__: null,
        __extends: function(e, t) {
            function n() {
                this.constructor = e;
            }
            vp(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n);
        },
        get __assign () {
            return Ap;
        },
        __rest: function(e, t) {
            var n = {
            };
            for(var r in e)Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
            if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                var o = 0;
                for(r = Object.getOwnPropertySymbols(e); o < r.length; o++)t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
            }
            return n;
        },
        __decorate: function(e, t, n, r) {
            var o, i = arguments.length, u = i < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) u = Reflect.decorate(e, t, n, r);
            else for(var s = e.length - 1; s >= 0; s--)(o = e[s]) && (u = (i < 3 ? o(u) : i > 3 ? o(t, n, u) : o(t, n)) || u);
            return i > 3 && u && Object.defineProperty(t, n, u), u;
        },
        __param: function(e, t) {
            return function(n, r) {
                t(n, r, e);
            };
        },
        __metadata: function(e, t) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        },
        __awaiter: function(e83, t34, n, r) {
            return new (n || (n = Promise))(function(o, i) {
                function u(e) {
                    try {
                        a(r.next(e));
                    } catch (e84) {
                        i(e84);
                    }
                }
                function s(e) {
                    try {
                        a(r.throw(e));
                    } catch (e85) {
                        i(e85);
                    }
                }
                function a(e86) {
                    var t;
                    e86.done ? o(e86.value) : (t = e86.value, t instanceof n ? t : new n(function(e) {
                        e(t);
                    })).then(u, s);
                }
                a((r = r.apply(e83, t34 || [])).next());
            });
        },
        __generator: function(e87, t) {
            var n, r, o, i8, u = {
                label: 0,
                sent: function() {
                    if (1 & o[0]) throw o[1];
                    return o[1];
                },
                trys: [],
                ops: []
            };
            function s4(i9) {
                return function(s) {
                    return (function(i) {
                        if (n) throw new TypeError("Generator is already executing.");
                        for(; u;)try {
                            if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;
                            switch(r = 0, o && (i = [
                                2 & i[0],
                                o.value
                            ]), i[0]){
                                case 0:
                                case 1:
                                    o = i;
                                    break;
                                case 4:
                                    return u.label++, {
                                        value: i[1],
                                        done: !1
                                    };
                                case 5:
                                    u.label++, r = i[1], i = [
                                        0
                                    ];
                                    continue;
                                case 7:
                                    i = u.ops.pop(), u.trys.pop();
                                    continue;
                                default:
                                    if (!(o = u.trys, (o = o.length > 0 && o[o.length - 1]) || 6 !== i[0] && 2 !== i[0])) {
                                        u = 0;
                                        continue;
                                    }
                                    if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                                        u.label = i[1];
                                        break;
                                    }
                                    if (6 === i[0] && u.label < o[1]) {
                                        u.label = o[1], o = i;
                                        break;
                                    }
                                    if (o && u.label < o[2]) {
                                        u.label = o[2], u.ops.push(i);
                                        break;
                                    }
                                    o[2] && u.ops.pop(), u.trys.pop();
                                    continue;
                            }
                            i = t.call(e87, u);
                        } catch (e) {
                            i = [
                                6,
                                e
                            ], r = 0;
                        } finally{
                            n = o = 0;
                        }
                        if (5 & i[0]) throw i[1];
                        return {
                            value: i[0] ? i[1] : void 0,
                            done: !0
                        };
                    })([
                        i9,
                        s
                    ]);
                };
            }
            return i8 = {
                next: s4(0),
                throw: s4(1),
                return: s4(2)
            }, "function" == typeof Symbol && (i8[Symbol.iterator] = function() {
                return this;
            }), i8;
        },
        __createBinding: function(e, t, n, r) {
            void 0 === r && (r = n), e[r] = t[n];
        },
        __exportStar: function(e, t) {
            for(var n in e)"default" === n || t.hasOwnProperty(n) || (t[n] = e[n]);
        },
        __values: Fp,
        __read: xp,
        __spread: function() {
            for(var e = [], t = 0; t < arguments.length; t++)e = e.concat(xp(arguments[t]));
            return e;
        },
        __spreadArrays: function() {
            for(var e = 0, t = 0, n = arguments.length; t < n; t++)e += arguments[t].length;
            var r = Array(e), o = 0;
            for(t = 0; t < n; t++)for(var i = arguments[t], u = 0, s = i.length; u < s; u++, o++)r[o] = i[u];
            return r;
        },
        __await: Sp,
        __asyncGenerator: function(e88, t35, n24) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var r12, o = n24.apply(e88, t35 || []), i = [];
            function u(e) {
                o[e] && (r12[e] = function(t) {
                    return new Promise(function(n, r) {
                        i.push([
                            e,
                            t,
                            n,
                            r
                        ]) > 1 || s(e, t);
                    });
                });
            }
            function s(e, t) {
                try {
                    (n = o[e](t)).value instanceof Sp ? Promise.resolve(n.value.v).then(a, c) : l(i[0][2], n);
                } catch (e89) {
                    l(i[0][3], e89);
                }
                var n;
            }
            function a(e) {
                s("next", e);
            }
            function c(e) {
                s("throw", e);
            }
            function l(e, t) {
                e(t), i.shift(), i.length && s(i[0][0], i[0][1]);
            }
            return r12 = {
            }, u("next"), u("throw"), u("return"), r12[Symbol.asyncIterator] = function() {
                return this;
            }, r12;
        },
        __asyncDelegator: function(e90) {
            var t36, n;
            function r13(r, o) {
                t36[r] = e90[r] ? function(t) {
                    return (n = !n) ? {
                        value: Sp(e90[r](t)),
                        done: "return" === r
                    } : o ? o(t) : t;
                } : o;
            }
            return t36 = {
            }, r13("next"), r13("throw", function(e) {
                throw e;
            }), r13("return"), t36[Symbol.iterator] = function() {
                return this;
            }, t36;
        },
        __asyncValues: function(e91) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var t37, n25 = e91[Symbol.asyncIterator];
            function r14(n26) {
                t37[n26] = e91[n26] && function(t38) {
                    return new Promise(function(r15, o) {
                        (function(e, t39, n, r) {
                            Promise.resolve(r).then(function(t) {
                                e({
                                    value: t,
                                    done: n
                                });
                            }, t39);
                        })(r15, o, (t38 = e91[n26](t38)).done, t38.value);
                    });
                };
            }
            return n25 ? n25.call(e91) : (e91 = Fp(e91), t37 = {
            }, r14("next"), r14("throw"), r14("return"), t37[Symbol.asyncIterator] = function() {
                return this;
            }, t37);
        },
        __makeTemplateObject: function(e, t) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", {
                value: t
            }) : e.raw = t, e;
        },
        __importStar: function(e) {
            if (e && e.__esModule) return e;
            var t = {
            };
            if (null != e) for(var n in e)Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t.default = e, t;
        },
        __importDefault: function(e) {
            return e && e.__esModule ? e : {
                default: e
            };
        },
        __classPrivateFieldGet: function(e, t) {
            if (!t.has(e)) throw new TypeError("attempted to get private field on non-instance");
            return t.get(e);
        },
        __classPrivateFieldSet: function(e, t, n) {
            if (!t.has(e)) throw new TypeError("attempted to set private field on non-instance");
            return t.set(e, n), n;
        }
    }), Tp = {
    }, Bp = {
    };
    !function(e92) {
        Object.defineProperty(e92, "__esModule", {
            value: !0
        }), e92.apiDescriptor = {
            key: (e)=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e)
            ,
            value (t40) {
                if (null === t40 || "object" != typeof t40) return JSON.stringify(t40);
                if (Array.isArray(t40)) return "[".concat(t40.map((t)=>e92.apiDescriptor.value(t)
                ).join(", "), "]");
                const n27 = Object.keys(t40);
                return 0 === n27.length ? "{}" : "{ ".concat(n27.map((n)=>"".concat(e92.apiDescriptor.key(n), ": ").concat(e92.apiDescriptor.value(t40[n]))
                ).join(", "), " }");
            },
            pair: (t)=>{
                let { key: n , value: r  } = t;
                return e92.apiDescriptor.value({
                    [n]: r
                });
            }
        };
    }(Bp), (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        wp.__exportStar(Bp, e);
    })(Tp);
    var Np = {
    }, kp = {
    }, Pp = {
    }, Op = {
        exports: {
        }
    }, Ip = /[|\\{}()[\]^$+*?.]/g, Lp = function(e) {
        if ("string" != typeof e) throw new TypeError("Expected a string");
        return e.replace(Ip, "\\$&");
    }, jp = {
        exports: {
        }
    }, _p = {
        exports: {
        }
    }, Mp = {
        aliceblue: [
            240,
            248,
            255
        ],
        antiquewhite: [
            250,
            235,
            215
        ],
        aqua: [
            0,
            255,
            255
        ],
        aquamarine: [
            127,
            255,
            212
        ],
        azure: [
            240,
            255,
            255
        ],
        beige: [
            245,
            245,
            220
        ],
        bisque: [
            255,
            228,
            196
        ],
        black: [
            0,
            0,
            0
        ],
        blanchedalmond: [
            255,
            235,
            205
        ],
        blue: [
            0,
            0,
            255
        ],
        blueviolet: [
            138,
            43,
            226
        ],
        brown: [
            165,
            42,
            42
        ],
        burlywood: [
            222,
            184,
            135
        ],
        cadetblue: [
            95,
            158,
            160
        ],
        chartreuse: [
            127,
            255,
            0
        ],
        chocolate: [
            210,
            105,
            30
        ],
        coral: [
            255,
            127,
            80
        ],
        cornflowerblue: [
            100,
            149,
            237
        ],
        cornsilk: [
            255,
            248,
            220
        ],
        crimson: [
            220,
            20,
            60
        ],
        cyan: [
            0,
            255,
            255
        ],
        darkblue: [
            0,
            0,
            139
        ],
        darkcyan: [
            0,
            139,
            139
        ],
        darkgoldenrod: [
            184,
            134,
            11
        ],
        darkgray: [
            169,
            169,
            169
        ],
        darkgreen: [
            0,
            100,
            0
        ],
        darkgrey: [
            169,
            169,
            169
        ],
        darkkhaki: [
            189,
            183,
            107
        ],
        darkmagenta: [
            139,
            0,
            139
        ],
        darkolivegreen: [
            85,
            107,
            47
        ],
        darkorange: [
            255,
            140,
            0
        ],
        darkorchid: [
            153,
            50,
            204
        ],
        darkred: [
            139,
            0,
            0
        ],
        darksalmon: [
            233,
            150,
            122
        ],
        darkseagreen: [
            143,
            188,
            143
        ],
        darkslateblue: [
            72,
            61,
            139
        ],
        darkslategray: [
            47,
            79,
            79
        ],
        darkslategrey: [
            47,
            79,
            79
        ],
        darkturquoise: [
            0,
            206,
            209
        ],
        darkviolet: [
            148,
            0,
            211
        ],
        deeppink: [
            255,
            20,
            147
        ],
        deepskyblue: [
            0,
            191,
            255
        ],
        dimgray: [
            105,
            105,
            105
        ],
        dimgrey: [
            105,
            105,
            105
        ],
        dodgerblue: [
            30,
            144,
            255
        ],
        firebrick: [
            178,
            34,
            34
        ],
        floralwhite: [
            255,
            250,
            240
        ],
        forestgreen: [
            34,
            139,
            34
        ],
        fuchsia: [
            255,
            0,
            255
        ],
        gainsboro: [
            220,
            220,
            220
        ],
        ghostwhite: [
            248,
            248,
            255
        ],
        gold: [
            255,
            215,
            0
        ],
        goldenrod: [
            218,
            165,
            32
        ],
        gray: [
            128,
            128,
            128
        ],
        green: [
            0,
            128,
            0
        ],
        greenyellow: [
            173,
            255,
            47
        ],
        grey: [
            128,
            128,
            128
        ],
        honeydew: [
            240,
            255,
            240
        ],
        hotpink: [
            255,
            105,
            180
        ],
        indianred: [
            205,
            92,
            92
        ],
        indigo: [
            75,
            0,
            130
        ],
        ivory: [
            255,
            255,
            240
        ],
        khaki: [
            240,
            230,
            140
        ],
        lavender: [
            230,
            230,
            250
        ],
        lavenderblush: [
            255,
            240,
            245
        ],
        lawngreen: [
            124,
            252,
            0
        ],
        lemonchiffon: [
            255,
            250,
            205
        ],
        lightblue: [
            173,
            216,
            230
        ],
        lightcoral: [
            240,
            128,
            128
        ],
        lightcyan: [
            224,
            255,
            255
        ],
        lightgoldenrodyellow: [
            250,
            250,
            210
        ],
        lightgray: [
            211,
            211,
            211
        ],
        lightgreen: [
            144,
            238,
            144
        ],
        lightgrey: [
            211,
            211,
            211
        ],
        lightpink: [
            255,
            182,
            193
        ],
        lightsalmon: [
            255,
            160,
            122
        ],
        lightseagreen: [
            32,
            178,
            170
        ],
        lightskyblue: [
            135,
            206,
            250
        ],
        lightslategray: [
            119,
            136,
            153
        ],
        lightslategrey: [
            119,
            136,
            153
        ],
        lightsteelblue: [
            176,
            196,
            222
        ],
        lightyellow: [
            255,
            255,
            224
        ],
        lime: [
            0,
            255,
            0
        ],
        limegreen: [
            50,
            205,
            50
        ],
        linen: [
            250,
            240,
            230
        ],
        magenta: [
            255,
            0,
            255
        ],
        maroon: [
            128,
            0,
            0
        ],
        mediumaquamarine: [
            102,
            205,
            170
        ],
        mediumblue: [
            0,
            0,
            205
        ],
        mediumorchid: [
            186,
            85,
            211
        ],
        mediumpurple: [
            147,
            112,
            219
        ],
        mediumseagreen: [
            60,
            179,
            113
        ],
        mediumslateblue: [
            123,
            104,
            238
        ],
        mediumspringgreen: [
            0,
            250,
            154
        ],
        mediumturquoise: [
            72,
            209,
            204
        ],
        mediumvioletred: [
            199,
            21,
            133
        ],
        midnightblue: [
            25,
            25,
            112
        ],
        mintcream: [
            245,
            255,
            250
        ],
        mistyrose: [
            255,
            228,
            225
        ],
        moccasin: [
            255,
            228,
            181
        ],
        navajowhite: [
            255,
            222,
            173
        ],
        navy: [
            0,
            0,
            128
        ],
        oldlace: [
            253,
            245,
            230
        ],
        olive: [
            128,
            128,
            0
        ],
        olivedrab: [
            107,
            142,
            35
        ],
        orange: [
            255,
            165,
            0
        ],
        orangered: [
            255,
            69,
            0
        ],
        orchid: [
            218,
            112,
            214
        ],
        palegoldenrod: [
            238,
            232,
            170
        ],
        palegreen: [
            152,
            251,
            152
        ],
        paleturquoise: [
            175,
            238,
            238
        ],
        palevioletred: [
            219,
            112,
            147
        ],
        papayawhip: [
            255,
            239,
            213
        ],
        peachpuff: [
            255,
            218,
            185
        ],
        peru: [
            205,
            133,
            63
        ],
        pink: [
            255,
            192,
            203
        ],
        plum: [
            221,
            160,
            221
        ],
        powderblue: [
            176,
            224,
            230
        ],
        purple: [
            128,
            0,
            128
        ],
        rebeccapurple: [
            102,
            51,
            153
        ],
        red: [
            255,
            0,
            0
        ],
        rosybrown: [
            188,
            143,
            143
        ],
        royalblue: [
            65,
            105,
            225
        ],
        saddlebrown: [
            139,
            69,
            19
        ],
        salmon: [
            250,
            128,
            114
        ],
        sandybrown: [
            244,
            164,
            96
        ],
        seagreen: [
            46,
            139,
            87
        ],
        seashell: [
            255,
            245,
            238
        ],
        sienna: [
            160,
            82,
            45
        ],
        silver: [
            192,
            192,
            192
        ],
        skyblue: [
            135,
            206,
            235
        ],
        slateblue: [
            106,
            90,
            205
        ],
        slategray: [
            112,
            128,
            144
        ],
        slategrey: [
            112,
            128,
            144
        ],
        snow: [
            255,
            250,
            250
        ],
        springgreen: [
            0,
            255,
            127
        ],
        steelblue: [
            70,
            130,
            180
        ],
        tan: [
            210,
            180,
            140
        ],
        teal: [
            0,
            128,
            128
        ],
        thistle: [
            216,
            191,
            216
        ],
        tomato: [
            255,
            99,
            71
        ],
        turquoise: [
            64,
            224,
            208
        ],
        violet: [
            238,
            130,
            238
        ],
        wheat: [
            245,
            222,
            179
        ],
        white: [
            255,
            255,
            255
        ],
        whitesmoke: [
            245,
            245,
            245
        ],
        yellow: [
            255,
            255,
            0
        ],
        yellowgreen: [
            154,
            205,
            50
        ]
    }, Rp = {
    };
    for(var Vp in Mp)Mp.hasOwnProperty(Vp) && (Rp[Mp[Vp]] = Vp);
    var $p = _p.exports = {
        rgb: {
            channels: 3,
            labels: "rgb"
        },
        hsl: {
            channels: 3,
            labels: "hsl"
        },
        hsv: {
            channels: 3,
            labels: "hsv"
        },
        hwb: {
            channels: 3,
            labels: "hwb"
        },
        cmyk: {
            channels: 4,
            labels: "cmyk"
        },
        xyz: {
            channels: 3,
            labels: "xyz"
        },
        lab: {
            channels: 3,
            labels: "lab"
        },
        lch: {
            channels: 3,
            labels: "lch"
        },
        hex: {
            channels: 1,
            labels: [
                "hex"
            ]
        },
        keyword: {
            channels: 1,
            labels: [
                "keyword"
            ]
        },
        ansi16: {
            channels: 1,
            labels: [
                "ansi16"
            ]
        },
        ansi256: {
            channels: 1,
            labels: [
                "ansi256"
            ]
        },
        hcg: {
            channels: 3,
            labels: [
                "h",
                "c",
                "g"
            ]
        },
        apple: {
            channels: 3,
            labels: [
                "r16",
                "g16",
                "b16"
            ]
        },
        gray: {
            channels: 1,
            labels: [
                "gray"
            ]
        }
    };
    for(var Wp in $p)if ($p.hasOwnProperty(Wp)) {
        if (!("channels" in $p[Wp])) throw new Error("missing channels property: " + Wp);
        if (!("labels" in $p[Wp])) throw new Error("missing channel labels property: " + Wp);
        if ($p[Wp].labels.length !== $p[Wp].channels) throw new Error("channel and label counts mismatch: " + Wp);
        var qp = $p[Wp].channels, Up = $p[Wp].labels;
        delete $p[Wp].channels, delete $p[Wp].labels, Object.defineProperty($p[Wp], "channels", {
            value: qp
        }), Object.defineProperty($p[Wp], "labels", {
            value: Up
        });
    }
    $p.rgb.hsl = function(e) {
        var t, n, r = e[0] / 255, o = e[1] / 255, i = e[2] / 255, u = Math.min(r, o, i), s = Math.max(r, o, i), a = s - u;
        return s === u ? t = 0 : r === s ? t = (o - i) / a : o === s ? t = 2 + (i - r) / a : i === s && (t = 4 + (r - o) / a), (t = Math.min(60 * t, 360)) < 0 && (t += 360), n = (u + s) / 2, [
            t,
            100 * (s === u ? 0 : n <= 0.5 ? a / (s + u) : a / (2 - s - u)),
            100 * n
        ];
    }, $p.rgb.hsv = function(e93) {
        var t, n, r, o, i, u = e93[0] / 255, s = e93[1] / 255, a = e93[2] / 255, c = Math.max(u, s, a), l = c - Math.min(u, s, a), p = function(e) {
            return (c - e) / 6 / l + 0.5;
        };
        return 0 === l ? o = i = 0 : (i = l / c, t = p(u), n = p(s), r = p(a), u === c ? o = r - n : s === c ? o = 1 / 3 + t - r : a === c && (o = 2 / 3 + n - t), o < 0 ? o += 1 : o > 1 && (o -= 1)), [
            360 * o,
            100 * i,
            100 * c
        ];
    }, $p.rgb.hwb = function(e) {
        var t = e[0], n = e[1], r = e[2];
        return [
            $p.rgb.hsl(e)[0],
            100 * (1 / 255 * Math.min(t, Math.min(n, r))),
            100 * (r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)))
        ];
    }, $p.rgb.cmyk = function(e) {
        var t, n = e[0] / 255, r = e[1] / 255, o = e[2] / 255;
        return [
            100 * ((1 - n - (t = Math.min(1 - n, 1 - r, 1 - o))) / (1 - t) || 0),
            100 * ((1 - r - t) / (1 - t) || 0),
            100 * ((1 - o - t) / (1 - t) || 0),
            100 * t
        ];
    }, $p.rgb.keyword = function(e) {
        var t = Rp[e];
        if (t) return t;
        var n, r, o, i = 1 / 0;
        for(var u in Mp)if (Mp.hasOwnProperty(u)) {
            var s = Mp[u], a = (r = e, o = s, Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2) + Math.pow(r[2] - o[2], 2));
            a < i && (i = a, n = u);
        }
        return n;
    }, $p.keyword.rgb = function(e) {
        return Mp[e];
    }, $p.rgb.xyz = function(e) {
        var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255;
        return [
            100 * (0.4124 * (t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92) + 0.3576 * (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) + 0.1805 * (r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92)),
            100 * (0.2126 * t + 0.7152 * n + 0.0722 * r),
            100 * (0.0193 * t + 0.1192 * n + 0.9505 * r)
        ];
    }, $p.rgb.lab = function(e) {
        var t = $p.rgb.xyz(e), n = t[0], r = t[1], o = t[2];
        return r /= 100, o /= 108.883, n = (n /= 95.047) > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, [
            116 * (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116) - 16,
            500 * (n - r),
            200 * (r - (o = o > 0.008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116))
        ];
    }, $p.hsl.rgb = function(e) {
        var t, n, r, o, i, u = e[0] / 360, s = e[1] / 100, a = e[2] / 100;
        if (0 === s) return [
            i = 255 * a,
            i,
            i
        ];
        t = 2 * a - (n = a < 0.5 ? a * (1 + s) : a + s - a * s), o = [
            0,
            0,
            0
        ];
        for(var c = 0; c < 3; c++)(r = u + 1 / 3 * -(c - 1)) < 0 && r++, r > 1 && r--, i = 6 * r < 1 ? t + 6 * (n - t) * r : 2 * r < 1 ? n : 3 * r < 2 ? t + (n - t) * (2 / 3 - r) * 6 : t, o[c] = 255 * i;
        return o;
    }, $p.hsl.hsv = function(e) {
        var t = e[0], n = e[1] / 100, r = e[2] / 100, o = n, i = Math.max(r, 0.01);
        return n *= (r *= 2) <= 1 ? r : 2 - r, o *= i <= 1 ? i : 2 - i, [
            t,
            100 * (0 === r ? 2 * o / (i + o) : 2 * n / (r + n)),
            100 * ((r + n) / 2)
        ];
    }, $p.hsv.rgb = function(e) {
        var t = e[0] / 60, n = e[1] / 100, r = e[2] / 100, o = Math.floor(t) % 6, i = t - Math.floor(t), u = 255 * r * (1 - n), s = 255 * r * (1 - n * i), a = 255 * r * (1 - n * (1 - i));
        switch(r *= 255, o){
            case 0:
                return [
                    r,
                    a,
                    u
                ];
            case 1:
                return [
                    s,
                    r,
                    u
                ];
            case 2:
                return [
                    u,
                    r,
                    a
                ];
            case 3:
                return [
                    u,
                    s,
                    r
                ];
            case 4:
                return [
                    a,
                    u,
                    r
                ];
            case 5:
                return [
                    r,
                    u,
                    s
                ];
        }
    }, $p.hsv.hsl = function(e) {
        var t, n, r, o = e[0], i = e[1] / 100, u = e[2] / 100, s = Math.max(u, 0.01);
        return r = (2 - i) * u, n = i * s, [
            o,
            100 * (n = (n /= (t = (2 - i) * s) <= 1 ? t : 2 - t) || 0),
            100 * (r /= 2)
        ];
    }, $p.hwb.rgb = function(e) {
        var t, n, r, o, i, u, s, a = e[0] / 360, c = e[1] / 100, l = e[2] / 100, p = c + l;
        switch(p > 1 && (c /= p, l /= p), r = 6 * a - (t = Math.floor(6 * a)), 0 != (1 & t) && (r = 1 - r), o = c + r * ((n = 1 - l) - c), t){
            default:
            case 6:
            case 0:
                i = n, u = o, s = c;
                break;
            case 1:
                i = o, u = n, s = c;
                break;
            case 2:
                i = c, u = n, s = o;
                break;
            case 3:
                i = c, u = o, s = n;
                break;
            case 4:
                i = o, u = c, s = n;
                break;
            case 5:
                i = n, u = c, s = o;
        }
        return [
            255 * i,
            255 * u,
            255 * s
        ];
    }, $p.cmyk.rgb = function(e) {
        var t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100;
        return [
            255 * (1 - Math.min(1, t * (1 - o) + o)),
            255 * (1 - Math.min(1, n * (1 - o) + o)),
            255 * (1 - Math.min(1, r * (1 - o) + o))
        ];
    }, $p.xyz.rgb = function(e) {
        var t, n, r, o = e[0] / 100, i = e[1] / 100, u = e[2] / 100;
        return n = -0.9689 * o + 1.8758 * i + 0.0415 * u, r = 0.0557 * o + -0.204 * i + 1.057 * u, t = (t = 3.2406 * o + -1.5372 * i + -0.4986 * u) > 0.0031308 ? 1.055 * Math.pow(t, 1 / 2.4) - 0.055 : 12.92 * t, n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n, r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r, [
            255 * (t = Math.min(Math.max(0, t), 1)),
            255 * (n = Math.min(Math.max(0, n), 1)),
            255 * (r = Math.min(Math.max(0, r), 1))
        ];
    }, $p.xyz.lab = function(e) {
        var t = e[0], n = e[1], r = e[2];
        return n /= 100, r /= 108.883, t = (t /= 95.047) > 0.008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, [
            116 * (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16,
            500 * (t - n),
            200 * (n - (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))
        ];
    }, $p.lab.xyz = function(e) {
        var t, n, r, o = e[0];
        t = e[1] / 500 + (n = (o + 16) / 116), r = n - e[2] / 200;
        var i = Math.pow(n, 3), u = Math.pow(t, 3), s = Math.pow(r, 3);
        return n = i > 0.008856 ? i : (n - 16 / 116) / 7.787, t = u > 0.008856 ? u : (t - 16 / 116) / 7.787, r = s > 0.008856 ? s : (r - 16 / 116) / 7.787, [
            t *= 95.047,
            n *= 100,
            r *= 108.883
        ];
    }, $p.lab.lch = function(e) {
        var t, n = e[0], r = e[1], o = e[2];
        return (t = 360 * Math.atan2(o, r) / 2 / Math.PI) < 0 && (t += 360), [
            n,
            Math.sqrt(r * r + o * o),
            t
        ];
    }, $p.lch.lab = function(e) {
        var t, n = e[0], r = e[1];
        return t = e[2] / 360 * 2 * Math.PI, [
            n,
            r * Math.cos(t),
            r * Math.sin(t)
        ];
    }, $p.rgb.ansi16 = function(e) {
        var t = e[0], n = e[1], r = e[2], o = 1 in arguments ? arguments[1] : $p.rgb.hsv(e)[2];
        if (0 === (o = Math.round(o / 50))) return 30;
        var i = 30 + (Math.round(r / 255) << 2 | Math.round(n / 255) << 1 | Math.round(t / 255));
        return 2 === o && (i += 60), i;
    }, $p.hsv.ansi16 = function(e) {
        return $p.rgb.ansi16($p.hsv.rgb(e), e[2]);
    }, $p.rgb.ansi256 = function(e) {
        var t = e[0], n = e[1], r = e[2];
        return t === n && n === r ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
    }, $p.ansi16.rgb = function(e) {
        var t = e % 10;
        if (0 === t || 7 === t) return e > 50 && (t += 3.5), [
            t = t / 10.5 * 255,
            t,
            t
        ];
        var n = 0.5 * (1 + ~~(e > 50));
        return [
            (1 & t) * n * 255,
            (t >> 1 & 1) * n * 255,
            (t >> 2 & 1) * n * 255
        ];
    }, $p.ansi256.rgb = function(e) {
        if (e >= 232) {
            var t = 10 * (e - 232) + 8;
            return [
                t,
                t,
                t
            ];
        }
        var n;
        return e -= 16, [
            Math.floor(e / 36) / 5 * 255,
            Math.floor((n = e % 36) / 6) / 5 * 255,
            n % 6 / 5 * 255
        ];
    }, $p.rgb.hex = function(e) {
        var t = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase();
        return "000000".substring(t.length) + t;
    }, $p.hex.rgb = function(e94) {
        var t = e94.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t) return [
            0,
            0,
            0
        ];
        var n = t[0];
        3 === t[0].length && (n = n.split("").map(function(e) {
            return e + e;
        }).join(""));
        var r = parseInt(n, 16);
        return [
            r >> 16 & 255,
            r >> 8 & 255,
            255 & r
        ];
    }, $p.rgb.hcg = function(e) {
        var t, n = e[0] / 255, r = e[1] / 255, o = e[2] / 255, i = Math.max(Math.max(n, r), o), u = Math.min(Math.min(n, r), o), s = i - u;
        return t = s <= 0 ? 0 : i === n ? (r - o) / s % 6 : i === r ? 2 + (o - n) / s : 4 + (n - r) / s + 4, t /= 6, [
            360 * (t %= 1),
            100 * s,
            100 * (s < 1 ? u / (1 - s) : 0)
        ];
    }, $p.hsl.hcg = function(e) {
        var t = e[1] / 100, n = e[2] / 100, r = 1, o = 0;
        return (r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n)) < 1 && (o = (n - 0.5 * r) / (1 - r)), [
            e[0],
            100 * r,
            100 * o
        ];
    }, $p.hsv.hcg = function(e) {
        var t = e[1] / 100, n = e[2] / 100, r = t * n, o = 0;
        return r < 1 && (o = (n - r) / (1 - r)), [
            e[0],
            100 * r,
            100 * o
        ];
    }, $p.hcg.rgb = function(e) {
        var t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
        if (0 === n) return [
            255 * r,
            255 * r,
            255 * r
        ];
        var o, i = [
            0,
            0,
            0
        ], u = t % 1 * 6, s = u % 1, a = 1 - s;
        switch(Math.floor(u)){
            case 0:
                i[0] = 1, i[1] = s, i[2] = 0;
                break;
            case 1:
                i[0] = a, i[1] = 1, i[2] = 0;
                break;
            case 2:
                i[0] = 0, i[1] = 1, i[2] = s;
                break;
            case 3:
                i[0] = 0, i[1] = a, i[2] = 1;
                break;
            case 4:
                i[0] = s, i[1] = 0, i[2] = 1;
                break;
            default:
                i[0] = 1, i[1] = 0, i[2] = a;
        }
        return o = (1 - n) * r, [
            255 * (n * i[0] + o),
            255 * (n * i[1] + o),
            255 * (n * i[2] + o)
        ];
    }, $p.hcg.hsv = function(e) {
        var t = e[1] / 100, n = t + e[2] / 100 * (1 - t), r = 0;
        return n > 0 && (r = t / n), [
            e[0],
            100 * r,
            100 * n
        ];
    }, $p.hcg.hsl = function(e) {
        var t = e[1] / 100, n = e[2] / 100 * (1 - t) + 0.5 * t, r = 0;
        return n > 0 && n < 0.5 ? r = t / (2 * n) : n >= 0.5 && n < 1 && (r = t / (2 * (1 - n))), [
            e[0],
            100 * r,
            100 * n
        ];
    }, $p.hcg.hwb = function(e) {
        var t = e[1] / 100, n = t + e[2] / 100 * (1 - t);
        return [
            e[0],
            100 * (n - t),
            100 * (1 - n)
        ];
    }, $p.hwb.hcg = function(e) {
        var t = e[1] / 100, n = 1 - e[2] / 100, r = n - t, o = 0;
        return r < 1 && (o = (n - r) / (1 - r)), [
            e[0],
            100 * r,
            100 * o
        ];
    }, $p.apple.rgb = function(e) {
        return [
            e[0] / 65535 * 255,
            e[1] / 65535 * 255,
            e[2] / 65535 * 255
        ];
    }, $p.rgb.apple = function(e) {
        return [
            e[0] / 255 * 65535,
            e[1] / 255 * 65535,
            e[2] / 255 * 65535
        ];
    }, $p.gray.rgb = function(e) {
        return [
            e[0] / 100 * 255,
            e[0] / 100 * 255,
            e[0] / 100 * 255
        ];
    }, $p.gray.hsl = $p.gray.hsv = function(e) {
        return [
            0,
            0,
            e[0]
        ];
    }, $p.gray.hwb = function(e) {
        return [
            0,
            100,
            e[0]
        ];
    }, $p.gray.cmyk = function(e) {
        return [
            0,
            0,
            0,
            e[0]
        ];
    }, $p.gray.lab = function(e) {
        return [
            e[0],
            0,
            0
        ];
    }, $p.gray.hex = function(e) {
        var t = 255 & Math.round(e[0] / 100 * 255), n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
        return "000000".substring(n.length) + n;
    }, $p.rgb.gray = function(e) {
        return [
            (e[0] + e[1] + e[2]) / 3 / 255 * 100
        ];
    };
    var zp = _p.exports;
    function Gp(e95) {
        var t41 = function() {
            for(var e = {
            }, t = Object.keys(zp), n = t.length, r = 0; r < n; r++)e[t[r]] = {
                distance: -1,
                parent: null
            };
            return e;
        }(), n28 = [
            e95
        ];
        for(t41[e95].distance = 0; n28.length;)for(var r16 = n28.pop(), o = Object.keys(zp[r16]), i = o.length, u = 0; u < i; u++){
            var s = o[u], a = t41[s];
            -1 === a.distance && (a.distance = t41[r16].distance + 1, a.parent = r16, n28.unshift(s));
        }
        return t41;
    }
    function Hp(e, t) {
        return function(n) {
            return t(e(n));
        };
    }
    function Jp(e, t) {
        for(var n = [
            t[e].parent,
            e
        ], r = zp[t[e].parent][e], o = t[e].parent; t[o].parent;)n.unshift(t[o].parent), r = Hp(zp[t[o].parent][o], r), o = t[o].parent;
        return r.conversion = n, r;
    }
    var Xp = _p.exports, Yp = function(e) {
        for(var t = Gp(e), n = {
        }, r = Object.keys(t), o = r.length, i = 0; i < o; i++){
            var u = r[i];
            null !== t[u].parent && (n[u] = Jp(u, t));
        }
        return n;
    }, Kp = {
    };
    Object.keys(Xp).forEach(function(e96) {
        Kp[e96] = {
        }, Object.defineProperty(Kp[e96], "channels", {
            value: Xp[e96].channels
        }), Object.defineProperty(Kp[e96], "labels", {
            value: Xp[e96].labels
        });
        var t42 = Yp(e96);
        Object.keys(t42).forEach(function(n29) {
            var r17 = t42[n29];
            Kp[e96][n29] = (function(e) {
                var t43 = function(t) {
                    if (null == t) return t;
                    arguments.length > 1 && (t = Array.prototype.slice.call(arguments));
                    var n = e(t);
                    if ("object" == typeof n) for(var r = n.length, o = 0; o < r; o++)n[o] = Math.round(n[o]);
                    return n;
                };
                return "conversion" in e && (t43.conversion = e.conversion), t43;
            })(r17), Kp[e96][n29].raw = (function(e) {
                var t44 = function(t) {
                    return null == t ? t : (arguments.length > 1 && (t = Array.prototype.slice.call(arguments)), e(t));
                };
                return "conversion" in e && (t44.conversion = e.conversion), t44;
            })(r17);
        });
    });
    var Qp, Zp = Kp;
    function ef() {
        if (void 0 === Qp) {
            var e = new ArrayBuffer(2), t = new Uint8Array(e), n = new Uint16Array(e);
            if (t[0] = 1, t[1] = 2, 258 === n[0]) Qp = "BE";
            else {
                if (513 !== n[0]) throw new Error("unable to figure out endianess");
                Qp = "LE";
            }
        }
        return Qp;
    }
    function tf() {
        return void 0 !== Ns.location ? Ns.location.hostname : "";
    }
    function nf() {
        return [];
    }
    function rf() {
        return 0;
    }
    function of() {
        return Number.MAX_VALUE;
    }
    function uf() {
        return Number.MAX_VALUE;
    }
    function sf() {
        return [];
    }
    function af() {
        return "Browser";
    }
    function cf() {
        return void 0 !== Ns.navigator ? Ns.navigator.appVersion : "";
    }
    function lf() {
    }
    function pf() {
    }
    function ff() {
        return "javascript";
    }
    function df() {
        return "browser";
    }
    function hf() {
        return "/tmp";
    }
    !function(e97) {
        const t45 = Zp, n30 = (e, n)=>function() {
                const r = e.apply(t45, arguments);
                return "\x1b[".concat(r + n, "m");
            }
        , r18 = (e, n)=>function() {
                const r = e.apply(t45, arguments);
                return "\x1b[".concat(38 + n, ";5;").concat(r, "m");
            }
        , o = (e, n)=>function() {
                const r = e.apply(t45, arguments);
                return "\x1b[".concat(38 + n, ";2;").concat(r[0], ";").concat(r[1], ";").concat(r[2], "m");
            }
        ;
        Object.defineProperty(e97, "exports", {
            enumerable: !0,
            get: function() {
                const e99 = new Map, i = {
                    modifier: {
                        reset: [
                            0,
                            0
                        ],
                        bold: [
                            1,
                            22
                        ],
                        dim: [
                            2,
                            22
                        ],
                        italic: [
                            3,
                            23
                        ],
                        underline: [
                            4,
                            24
                        ],
                        inverse: [
                            7,
                            27
                        ],
                        hidden: [
                            8,
                            28
                        ],
                        strikethrough: [
                            9,
                            29
                        ]
                    },
                    color: {
                        black: [
                            30,
                            39
                        ],
                        red: [
                            31,
                            39
                        ],
                        green: [
                            32,
                            39
                        ],
                        yellow: [
                            33,
                            39
                        ],
                        blue: [
                            34,
                            39
                        ],
                        magenta: [
                            35,
                            39
                        ],
                        cyan: [
                            36,
                            39
                        ],
                        white: [
                            37,
                            39
                        ],
                        gray: [
                            90,
                            39
                        ],
                        redBright: [
                            91,
                            39
                        ],
                        greenBright: [
                            92,
                            39
                        ],
                        yellowBright: [
                            93,
                            39
                        ],
                        blueBright: [
                            94,
                            39
                        ],
                        magentaBright: [
                            95,
                            39
                        ],
                        cyanBright: [
                            96,
                            39
                        ],
                        whiteBright: [
                            97,
                            39
                        ]
                    },
                    bgColor: {
                        bgBlack: [
                            40,
                            49
                        ],
                        bgRed: [
                            41,
                            49
                        ],
                        bgGreen: [
                            42,
                            49
                        ],
                        bgYellow: [
                            43,
                            49
                        ],
                        bgBlue: [
                            44,
                            49
                        ],
                        bgMagenta: [
                            45,
                            49
                        ],
                        bgCyan: [
                            46,
                            49
                        ],
                        bgWhite: [
                            47,
                            49
                        ],
                        bgBlackBright: [
                            100,
                            49
                        ],
                        bgRedBright: [
                            101,
                            49
                        ],
                        bgGreenBright: [
                            102,
                            49
                        ],
                        bgYellowBright: [
                            103,
                            49
                        ],
                        bgBlueBright: [
                            104,
                            49
                        ],
                        bgMagentaBright: [
                            105,
                            49
                        ],
                        bgCyanBright: [
                            106,
                            49
                        ],
                        bgWhiteBright: [
                            107,
                            49
                        ]
                    }
                };
                i.color.grey = i.color.gray;
                for (const t47 of Object.keys(i)){
                    const n = i[t47];
                    for (const t46 of Object.keys(n)){
                        const r = n[t46];
                        i[t46] = {
                            open: "\x1b[".concat(r[0], "m"),
                            close: "\x1b[".concat(r[1], "m")
                        }, n[t46] = i[t46], e99.set(r[0], r[1]);
                    }
                    Object.defineProperty(i, t47, {
                        value: n,
                        enumerable: !1
                    }), Object.defineProperty(i, "codes", {
                        value: e99,
                        enumerable: !1
                    });
                }
                const u = (e)=>e
                , s = (e, t, n)=>[
                        e,
                        t,
                        n
                    ]
                ;
                i.color.close = "\x1b[39m", i.bgColor.close = "\x1b[49m", i.color.ansi = {
                    ansi: n30(u, 0)
                }, i.color.ansi256 = {
                    ansi256: r18(u, 0)
                }, i.color.ansi16m = {
                    rgb: o(s, 0)
                }, i.bgColor.ansi = {
                    ansi: n30(u, 10)
                }, i.bgColor.ansi256 = {
                    ansi256: r18(u, 10)
                }, i.bgColor.ansi16m = {
                    rgb: o(s, 10)
                };
                for (let e98 of Object.keys(t45)){
                    if ("object" != typeof t45[e98]) continue;
                    const u = t45[e98];
                    "ansi16" === e98 && (e98 = "ansi"), "ansi16" in u && (i.color.ansi[e98] = n30(u.ansi16, 0), i.bgColor.ansi[e98] = n30(u.ansi16, 10)), "ansi256" in u && (i.color.ansi256[e98] = r18(u.ansi256, 0), i.bgColor.ansi256[e98] = r18(u.ansi256, 10)), "rgb" in u && (i.color.ansi16m[e98] = o(u.rgb, 0), i.bgColor.ansi16m[e98] = o(u.rgb, 10));
                }
                return i;
            }
        });
    }(jp);
    var gf = hf, mf = {
        EOL: "\n",
        arch: ff,
        platform: df,
        tmpdir: gf,
        tmpDir: hf,
        networkInterfaces: lf,
        getNetworkInterfaces: pf,
        release: cf,
        type: af,
        cpus: sf,
        totalmem: uf,
        freemem: of,
        uptime: rf,
        loadavg: nf,
        hostname: tf,
        endianness: ef
    }, yf = t3(Object.freeze({
        __proto__: null,
        endianness: ef,
        hostname: tf,
        loadavg: nf,
        uptime: rf,
        freemem: of,
        totalmem: uf,
        cpus: sf,
        type: af,
        release: cf,
        networkInterfaces: lf,
        getNetworkInterfaces: pf,
        arch: ff,
        platform: df,
        tmpDir: hf,
        tmpdir: gf,
        EOL: "\n",
        default: mf
    }));
    const Df = yf, Ef = (e, t)=>{
        t = t || ta.argv;
        const n = e.startsWith("-") ? "" : 1 === e.length ? "-" : "--", r = t.indexOf(n + e), o = t.indexOf("--");
        return -1 !== r && (-1 === o || r < o);
    }, Cf = ta.env;
    let bf;
    function vf(e100) {
        const t48 = function(e101) {
            if (!1 === bf) return 0;
            if (Ef("color=16m") || Ef("color=full") || Ef("color=truecolor")) return 3;
            if (Ef("color=256")) return 2;
            if (e101 && !e101.isTTY && !0 !== bf) return 0;
            const t = bf ? 1 : 0;
            if ("win32" === ta.platform) {
                const e = Df.release().split(".");
                return Number(ta.versions.node.split(".")[0]) >= 8 && Number(e[0]) >= 10 && Number(e[2]) >= 10586 ? Number(e[2]) >= 14931 ? 3 : 2 : 1;
            }
            if ("CI" in Cf) return [
                "TRAVIS",
                "CIRCLECI",
                "APPVEYOR",
                "GITLAB_CI"
            ].some((e)=>e in Cf
            ) || "codeship" === Cf.CI_NAME ? 1 : t;
            if ("TEAMCITY_VERSION" in Cf) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Cf.TEAMCITY_VERSION) ? 1 : 0;
            if ("truecolor" === Cf.COLORTERM) return 3;
            if ("TERM_PROGRAM" in Cf) {
                const e = parseInt((Cf.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
                switch(Cf.TERM_PROGRAM){
                    case "iTerm.app":
                        return e >= 3 ? 3 : 2;
                    case "Apple_Terminal":
                        return 2;
                }
            }
            return /-256(color)?$/i.test(Cf.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Cf.TERM) || "COLORTERM" in Cf ? 1 : (Cf.TERM, t);
        }(e100);
        return (function(e) {
            return 0 !== e && {
                level: e,
                hasBasic: !0,
                has256: e >= 2,
                has16m: e >= 3
            };
        })(t48);
    }
    Ef("no-color") || Ef("no-colors") || Ef("color=false") ? bf = !1 : (Ef("color") || Ef("colors") || Ef("color=true") || Ef("color=always")) && (bf = !0), "FORCE_COLOR" in Cf && (bf = 0 === Cf.FORCE_COLOR.length || 0 !== parseInt(Cf.FORCE_COLOR, 10));
    var Af = {
        supportsColor: vf,
        stdout: vf(ta.stdout),
        stderr: vf(ta.stderr)
    };
    const Ff = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, xf = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Sf = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, wf = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Tf = new Map([
        [
            "n",
            "\n"
        ],
        [
            "r",
            "\r"
        ],
        [
            "t",
            "\t"
        ],
        [
            "b",
            "\b"
        ],
        [
            "f",
            "\f"
        ],
        [
            "v",
            "\v"
        ],
        [
            "0",
            "\0"
        ],
        [
            "\\",
            "\\"
        ],
        [
            "e",
            "\x1b"
        ],
        [
            "a",
            "\x07"
        ]
    ]);
    function Bf(e) {
        return "u" === e[0] && 5 === e.length || "x" === e[0] && 3 === e.length ? String.fromCharCode(parseInt(e.slice(1), 16)) : Tf.get(e) || e;
    }
    function Nf(e, t50) {
        const n31 = [], r = t50.trim().split(/\s*,\s*/g);
        let o;
        for (const t49 of r)if (isNaN(t49)) {
            if (!(o = t49.match(Sf))) throw new Error("Invalid Chalk template style argument: ".concat(t49, " (in style '").concat(e, "')"));
            n31.push(o[2].replace(wf, (e, t, n)=>t ? Bf(t) : n
            ));
        } else n31.push(Number(t49));
        return n31;
    }
    function kf(e) {
        xf.lastIndex = 0;
        const t = [];
        let n;
        for(; null !== (n = xf.exec(e));){
            const e = n[1];
            if (n[2]) {
                const r = Nf(e, n[2]);
                t.push([
                    e
                ].concat(r));
            } else t.push([
                e
            ]);
        }
        return t;
    }
    function Pf(e, t) {
        const n = {
        };
        for (const e102 of t)for (const t51 of e102.styles)n[t51[0]] = e102.inverse ? null : t51.slice(1);
        let r = e;
        for (const e103 of Object.keys(n))if (Array.isArray(n[e103])) {
            if (!(e103 in r)) throw new Error("Unknown Chalk style: ".concat(e103));
            r = n[e103].length > 0 ? r[e103].apply(r, n[e103]) : r[e103];
        }
        return r;
    }
    var Of = (e, t52)=>{
        const n = [], r = [];
        let o = [];
        if (t52.replace(Ff, (t, i, u, s, a, c)=>{
            if (i) o.push(Bf(i));
            else if (s) {
                const t = o.join("");
                o = [], r.push(0 === n.length ? t : Pf(e, n)(t)), n.push({
                    inverse: u,
                    styles: kf(s)
                });
            } else if (a) {
                if (0 === n.length) throw new Error("Found extraneous } in Chalk template literal");
                r.push(Pf(e, n)(o.join(""))), o = [], n.pop();
            } else o.push(c);
        }), r.push(o.join("")), n.length > 0) {
            const e = "Chalk template literal is missing ".concat(n.length, " closing bracket").concat(1 === n.length ? "" : "s", " (`}`)");
            throw new Error(e);
        }
        return r.join("");
    };
    !function(e107) {
        const t53 = Lp, n32 = jp.exports, r19 = Af.stdout, o11 = Of, i = "win32" === ta.platform && !(ta.env.TERM || "").toLowerCase().startsWith("xterm"), u = [
            "ansi",
            "ansi",
            "ansi256",
            "ansi16m"
        ], s = new Set([
            "gray"
        ]), a = Object.create(null);
        function c(e, t) {
            t = t || {
            };
            const n = r19 ? r19.level : 0;
            e.level = void 0 === t.level ? n : t.level, e.enabled = "enabled" in t ? t.enabled : e.level > 0;
        }
        function l(e108) {
            if (!this || !(this instanceof l) || this.template) {
                const t = {
                };
                return c(t, e108), t.template = function() {
                    const e = [].slice.call(arguments);
                    return h.apply(null, [
                        t.template
                    ].concat(e));
                }, Object.setPrototypeOf(t, l.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = l, t.template;
            }
            c(this, e108);
        }
        i && (n32.blue.open = "\x1b[94m");
        for (const e104 of Object.keys(n32))n32[e104].closeRe = new RegExp(t53(n32[e104].close), "g"), a[e104] = {
            get () {
                const t = n32[e104];
                return f.call(this, this._styles ? this._styles.concat(t) : [
                    t
                ], this._empty, e104);
            }
        };
        a.visible = {
            get () {
                return f.call(this, this._styles || [], !0, "visible");
            }
        }, n32.color.closeRe = new RegExp(t53(n32.color.close), "g");
        for (const e105 of Object.keys(n32.color.ansi))s.has(e105) || (a[e105] = {
            get () {
                const t = this.level;
                return function() {
                    const r = n32.color[u[t]][e105].apply(null, arguments), o = {
                        open: r,
                        close: n32.color.close,
                        closeRe: n32.color.closeRe
                    };
                    return f.call(this, this._styles ? this._styles.concat(o) : [
                        o
                    ], this._empty, e105);
                };
            }
        });
        n32.bgColor.closeRe = new RegExp(t53(n32.bgColor.close), "g");
        for (const e106 of Object.keys(n32.bgColor.ansi)){
            if (s.has(e106)) continue;
            a["bg" + e106[0].toUpperCase() + e106.slice(1)] = {
                get () {
                    const t = this.level;
                    return function() {
                        const r = n32.bgColor[u[t]][e106].apply(null, arguments), o = {
                            open: r,
                            close: n32.bgColor.close,
                            closeRe: n32.bgColor.closeRe
                        };
                        return f.call(this, this._styles ? this._styles.concat(o) : [
                            o
                        ], this._empty, e106);
                    };
                }
            };
        }
        const p = Object.defineProperties(()=>{
        }, a);
        function f(e109, t, n) {
            const r = function() {
                return d.apply(r, arguments);
            };
            r._styles = e109, r._empty = t;
            const o = this;
            return Object.defineProperty(r, "level", {
                enumerable: !0,
                get: ()=>o.level
                ,
                set (e) {
                    o.level = e;
                }
            }), Object.defineProperty(r, "enabled", {
                enumerable: !0,
                get: ()=>o.enabled
                ,
                set (e) {
                    o.enabled = e;
                }
            }), r.hasGrey = this.hasGrey || "gray" === n || "grey" === n, r.__proto__ = p, r;
        }
        function d() {
            const e = arguments, t = e.length;
            let r = String(arguments[0]);
            if (0 === t) return "";
            if (t > 1) for(let n = 1; n < t; n++)r += " " + e[n];
            if (!this.enabled || this.level <= 0 || !r) return this._empty ? "" : r;
            const o = n32.dim.open;
            i && this.hasGrey && (n32.dim.open = "");
            for (const e110 of this._styles.slice().reverse())r = e110.open + r.replace(e110.closeRe, e110.open) + e110.close, r = r.replace(/\r?\n/g, "".concat(e110.close, "$&").concat(e110.open));
            return n32.dim.open = o, r;
        }
        function h(e, t) {
            if (!Array.isArray(t)) return [].slice.call(arguments, 1).join(" ");
            const n = [].slice.call(arguments, 2), r = [
                t.raw[0]
            ];
            for(let e111 = 1; e111 < t.length; e111++)r.push(String(n[e111 - 1]).replace(/[{}\\]/g, "\\$&")), r.push(String(t.raw[e111]));
            return o11(e, r.join(""));
        }
        Object.defineProperties(l.prototype, a), e107.exports = l(), e107.exports.supportsColor = r19, e107.exports.default = e107.exports;
    }(Op), Object.defineProperty(Pp, "__esModule", {
        value: !0
    });
    const If = Op.exports;
    Pp.commonDeprecatedHandler = (e, t, n)=>{
        let { descriptor: r  } = n;
        const o = [
            "".concat(If.default.yellow("string" == typeof e ? r.key(e) : r.pair(e)), " is deprecated")
        ];
        return t && o.push("we now treat it as ".concat(If.default.blue("string" == typeof t ? r.key(t) : r.pair(t)))), o.join("; ") + ".";
    }, (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        wp.__exportStar(Pp, e);
    })(kp);
    var Lf = {
    }, jf = {
    };
    Object.defineProperty(jf, "__esModule", {
        value: !0
    });
    const _f = Op.exports;
    jf.commonInvalidHandler = (e, t, n)=>[
            "Invalid ".concat(_f.default.red(n.descriptor.key(e)), " value."),
            "Expected ".concat(_f.default.blue(n.schemas[e].expected(n)), ","),
            "but received ".concat(_f.default.red(n.descriptor.value(t)), ".")
        ].join(" ")
    , (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        wp.__exportStar(jf, e);
    })(Lf);
    var Mf = {
    }, Rf = {
    }, Vf = [], $f = [];
    Object.defineProperty(Rf, "__esModule", {
        value: !0
    });
    const Wf = Op.exports, qf = function(e, t) {
        if (e === t) return 0;
        var n = e;
        e.length > t.length && (e = t, t = n);
        var r = e.length, o = t.length;
        if (0 === r) return o;
        if (0 === o) return r;
        for(; r > 0 && e.charCodeAt(~-r) === t.charCodeAt(~-o);)r--, o--;
        if (0 === r) return o;
        for(var i, u, s, a, c = 0; c < r && e.charCodeAt(c) === t.charCodeAt(c);)c++;
        if (o -= c, 0 === (r -= c)) return o;
        for(var l = 0, p = 0; l < r;)$f[c + l] = e.charCodeAt(c + l), Vf[l] = ++l;
        for(; p < o;)for(i = t.charCodeAt(c + p), s = p++, u = p, l = 0; l < r; l++)a = i === $f[c + l] ? s : s + 1, s = Vf[l], u = Vf[l] = s > u ? a > u ? u + 1 : a : a > s ? s + 1 : a;
        return u;
    };
    Rf.levenUnknownHandler = (e, t54, n)=>{
        let { descriptor: r , logger: o , schemas: i  } = n;
        const u = [
            "Ignored unknown option ".concat(Wf.default.yellow(r.pair({
                key: e,
                value: t54
            })), ".")
        ], s = Object.keys(i).sort().find((t)=>qf(e, t) < 3
        );
        s && u.push("Did you mean ".concat(Wf.default.blue(r.key(s)), "?")), o.warn(u.join(" "));
    }, (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        wp.__exportStar(Rf, e);
    })(Mf), (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        const t = wp;
        t.__exportStar(kp, e), t.__exportStar(Lf, e), t.__exportStar(Mf, e);
    })(Np);
    var Uf = {
    }, zf = {
    }, Gf = {
    };
    Object.defineProperty(Gf, "__esModule", {
        value: !0
    });
    const Hf = [
        "default",
        "expected",
        "validate",
        "deprecated",
        "forward",
        "redirect",
        "overlap",
        "preprocess",
        "postprocess"
    ];
    function Jf(e, t) {
        const n = new e(t), r = Object.create(n);
        for (const e112 of Hf)e112 in t && (r[e112] = Yf(t[e112], n, Xf.prototype[e112].length));
        return r;
    }
    Gf.createSchema = Jf;
    class Xf {
        constructor(e){
            this.name = e.name;
        }
        static create(e) {
            return Jf(this, e);
        }
        default(e) {
        }
        expected(e) {
            return "nothing";
        }
        validate(e, t) {
            return !1;
        }
        deprecated(e, t) {
            return !1;
        }
        forward(e, t) {
        }
        redirect(e, t) {
        }
        overlap(e, t, n) {
            return e;
        }
        preprocess(e, t) {
            return e;
        }
        postprocess(e, t) {
            return e;
        }
    }
    function Yf(e, t, n) {
        return "function" == typeof e ? function() {
            for(var r = arguments.length, o = new Array(r), i = 0; i < r; i++)o[i] = arguments[i];
            return e(...o.slice(0, n - 1), t, ...o.slice(n - 1));
        } : ()=>e
        ;
    }
    Gf.Schema = Xf, Object.defineProperty(zf, "__esModule", {
        value: !0
    });
    const Kf = Gf;
    class Qf extends Kf.Schema {
        constructor(e){
            super(e), this._sourceName = e.sourceName;
        }
        expected(e) {
            return e.schemas[this._sourceName].expected(e);
        }
        validate(e, t) {
            return t.schemas[this._sourceName].validate(e, t);
        }
        redirect(e, t) {
            return this._sourceName;
        }
    }
    zf.AliasSchema = Qf;
    var Zf = {
    };
    Object.defineProperty(Zf, "__esModule", {
        value: !0
    });
    const ed = Gf;
    class td extends ed.Schema {
        expected() {
            return "anything";
        }
        validate() {
            return !0;
        }
    }
    Zf.AnySchema = td;
    var nd = {
    };
    Object.defineProperty(nd, "__esModule", {
        value: !0
    });
    const rd = wp, od = Gf;
    class id extends od.Schema {
        constructor(e){
            var { valueSchema: t , name: n = t.name  } = e, r = rd.__rest(e, [
                "valueSchema",
                "name"
            ]);
            super(Object.assign({
            }, r, {
                name: n
            })), this._valueSchema = t;
        }
        expected(e) {
            return "an array of ".concat(this._valueSchema.expected(e));
        }
        validate(e, t) {
            if (!Array.isArray(e)) return !1;
            const n = [];
            for (const r of e){
                const e = t.normalizeValidateResult(this._valueSchema.validate(r, t), r);
                !0 !== e && n.push(e.value);
            }
            return 0 === n.length || {
                value: n
            };
        }
        deprecated(e, t55) {
            const n = [];
            for (const r of e){
                const e113 = t55.normalizeDeprecatedResult(this._valueSchema.deprecated(r, t55), r);
                !1 !== e113 && n.push(...e113.map((e)=>{
                    let { value: t  } = e;
                    return {
                        value: [
                            t
                        ]
                    };
                }));
            }
            return n;
        }
        forward(e, t) {
            const n = [];
            for (const r of e){
                const e = t.normalizeForwardResult(this._valueSchema.forward(r, t), r);
                n.push(...e.map(ud));
            }
            return n;
        }
        redirect(e, t) {
            const n = [], r = [];
            for (const o of e){
                const e = t.normalizeRedirectResult(this._valueSchema.redirect(o, t), o);
                "remain" in e && n.push(e.remain), r.push(...e.redirect.map(ud));
            }
            return 0 === n.length ? {
                redirect: r
            } : {
                redirect: r,
                remain: n
            };
        }
        overlap(e, t) {
            return e.concat(t);
        }
    }
    function ud(e) {
        let { from: t , to: n  } = e;
        return {
            from: [
                t
            ],
            to: n
        };
    }
    nd.ArraySchema = id;
    var sd = {
    };
    Object.defineProperty(sd, "__esModule", {
        value: !0
    });
    const ad = Gf;
    class cd extends ad.Schema {
        expected() {
            return "true or false";
        }
        validate(e) {
            return "boolean" == typeof e;
        }
    }
    sd.BooleanSchema = cd;
    var ld = {
    }, pd = {
    };
    function fd(e, t) {
        return "string" == typeof e || "key" in e ? {
            from: t,
            to: e
        } : "from" in e ? {
            from: e.from,
            to: e.to
        } : {
            from: t,
            to: e.to
        };
    }
    function dd(e114, t) {
        return void 0 === e114 ? [] : Array.isArray(e114) ? e114.map((e)=>fd(e, t)
        ) : [
            fd(e114, t)
        ];
    }
    Object.defineProperty(pd, "__esModule", {
        value: !0
    }), pd.recordFromArray = function(e, t) {
        const n = Object.create(null);
        for (const r of e){
            const e = r[t];
            if (n[e]) throw new Error("Duplicate ".concat(t, " ").concat(JSON.stringify(e)));
            n[e] = r;
        }
        return n;
    }, pd.mapFromArray = function(e, t) {
        const n = new Map;
        for (const r of e){
            const e = r[t];
            if (n.has(e)) throw new Error("Duplicate ".concat(t, " ").concat(JSON.stringify(e)));
            n.set(e, r);
        }
        return n;
    }, pd.createAutoChecklist = function() {
        const e = Object.create(null);
        return (t)=>{
            const n = JSON.stringify(t);
            return !!e[n] || (e[n] = !0, !1);
        };
    }, pd.partition = function(e, t) {
        const n = [], r = [];
        for (const o of e)t(o) ? n.push(o) : r.push(o);
        return [
            n,
            r
        ];
    }, pd.isInt = function(e) {
        return e === Math.floor(e);
    }, pd.comparePrimitive = function(e, t) {
        if (e === t) return 0;
        const n = typeof e, r = typeof t, o = [
            "undefined",
            "object",
            "boolean",
            "number",
            "string"
        ];
        return n !== r ? o.indexOf(n) - o.indexOf(r) : "string" !== n ? Number(e) - Number(t) : e.localeCompare(t);
    }, pd.normalizeDefaultResult = function(e) {
        return void 0 === e ? {
        } : e;
    }, pd.normalizeValidateResult = function(e, t) {
        return !0 === e || (!1 === e ? {
            value: t
        } : e);
    }, pd.normalizeDeprecatedResult = function(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return !1 !== e && (!0 === e ? !!n || [
            {
                value: t
            }
        ] : "value" in e ? [
            e
        ] : 0 !== e.length && e);
    }, pd.normalizeTransferResult = fd, pd.normalizeForwardResult = dd, pd.normalizeRedirectResult = function(e, t) {
        const n = dd("object" == typeof e && "redirect" in e ? e.redirect : e, t);
        return 0 === n.length ? {
            remain: t,
            redirect: n
        } : "object" == typeof e && "remain" in e ? {
            remain: e.remain,
            redirect: n
        } : {
            redirect: n
        };
    }, Object.defineProperty(ld, "__esModule", {
        value: !0
    });
    const hd = Gf, gd = pd;
    class md extends hd.Schema {
        constructor(e115){
            super(e115), this._choices = gd.mapFromArray(e115.choices.map((e)=>e && "object" == typeof e ? e : {
                    value: e
                }
            ), "value");
        }
        expected(e116) {
            let { descriptor: t  } = e116;
            const n = Array.from(this._choices.keys()).map((e)=>this._choices.get(e)
            ).filter((e)=>!e.deprecated
            ).map((e)=>e.value
            ).sort(gd.comparePrimitive).map(t.value), r = n.slice(0, -2), o = n.slice(-2);
            return r.concat(o.join(" or ")).join(", ");
        }
        validate(e) {
            return this._choices.has(e);
        }
        deprecated(e) {
            const t = this._choices.get(e);
            return !(!t || !t.deprecated) && {
                value: e
            };
        }
        forward(e) {
            const t = this._choices.get(e);
            return t ? t.forward : void 0;
        }
        redirect(e) {
            const t = this._choices.get(e);
            return t ? t.redirect : void 0;
        }
    }
    ld.ChoiceSchema = md;
    var yd = {
    }, Dd = {
    };
    Object.defineProperty(Dd, "__esModule", {
        value: !0
    });
    const Ed = Gf;
    class Cd extends Ed.Schema {
        expected() {
            return "a number";
        }
        validate(e, t) {
            return "number" == typeof e;
        }
    }
    Dd.NumberSchema = Cd, Object.defineProperty(yd, "__esModule", {
        value: !0
    });
    const bd = pd, vd = Dd;
    class Ad extends vd.NumberSchema {
        expected() {
            return "an integer";
        }
        validate(e, t) {
            return !0 === t.normalizeValidateResult(super.validate(e, t), e) && bd.isInt(e);
        }
    }
    yd.IntegerSchema = Ad;
    var Fd = {
    };
    Object.defineProperty(Fd, "__esModule", {
        value: !0
    });
    const xd = Gf;
    class Sd extends xd.Schema {
        expected() {
            return "a string";
        }
        validate(e) {
            return "string" == typeof e;
        }
    }
    Fd.StringSchema = Sd, (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        const t = wp;
        t.__exportStar(zf, e), t.__exportStar(Zf, e), t.__exportStar(nd, e), t.__exportStar(sd, e), t.__exportStar(ld, e), t.__exportStar(yd, e), t.__exportStar(Dd, e), t.__exportStar(Fd, e);
    })(Uf);
    var wd = {
    }, Td = {
    };
    Object.defineProperty(Td, "__esModule", {
        value: !0
    });
    const Bd = Bp, Nd = Pp, kd = Lf, Pd = Rf;
    Td.defaultDescriptor = Bd.apiDescriptor, Td.defaultUnknownHandler = Pd.levenUnknownHandler, Td.defaultInvalidHandler = kd.commonInvalidHandler, Td.defaultDeprecatedHandler = Nd.commonDeprecatedHandler, Object.defineProperty(wd, "__esModule", {
        value: !0
    });
    const Od = Td, Id = pd;
    wd.normalize = (e, t, n)=>new Ld(t, n).normalize(e)
    ;
    class Ld {
        constructor(e, t){
            const { logger: n = console , descriptor: r = Od.defaultDescriptor , unknown: o = Od.defaultUnknownHandler , invalid: i = Od.defaultInvalidHandler , deprecated: u = Od.defaultDeprecatedHandler  } = t || {
            };
            this._utils = {
                descriptor: r,
                logger: n || {
                    warn: ()=>{
                    }
                },
                schemas: Id.recordFromArray(e, "name"),
                normalizeDefaultResult: Id.normalizeDefaultResult,
                normalizeDeprecatedResult: Id.normalizeDeprecatedResult,
                normalizeForwardResult: Id.normalizeForwardResult,
                normalizeRedirectResult: Id.normalizeRedirectResult,
                normalizeValidateResult: Id.normalizeValidateResult
            }, this._unknownHandler = o, this._invalidHandler = i, this._deprecatedHandler = u, this.cleanHistory();
        }
        cleanHistory() {
            this._hasDeprecationWarned = Id.createAutoChecklist();
        }
        normalize(e119) {
            const t = {
            }, n = [
                e119
            ], r20 = ()=>{
                for(; 0 !== n.length;){
                    const e = n.shift(), r = this._applyNormalization(e, t);
                    n.push(...r);
                }
            };
            r20();
            for (const e117 of Object.keys(this._utils.schemas)){
                const r = this._utils.schemas[e117];
                if (!(e117 in t)) {
                    const t = Id.normalizeDefaultResult(r.default(this._utils));
                    "value" in t && n.push({
                        [e117]: t.value
                    });
                }
            }
            r20();
            for (const e118 of Object.keys(this._utils.schemas)){
                const n = this._utils.schemas[e118];
                e118 in t && (t[e118] = n.postprocess(t[e118], this._utils));
            }
            return t;
        }
        _applyNormalization(e120, t57) {
            const n33 = [], [r23, o] = Id.partition(Object.keys(e120), (e)=>e in this._utils.schemas
            );
            for (const o12 of r23){
                const r22 = this._utils.schemas[o12], i = r22.preprocess(e120[o12], this._utils), u6 = Id.normalizeValidateResult(r22.validate(i, this._utils), i);
                if (!0 !== u6) {
                    const { value: e  } = u6, t = this._invalidHandler(o12, e, this._utils);
                    throw "string" == typeof t ? new Error(t) : t;
                }
                const s = (e)=>{
                    let { from: t , to: r  } = e;
                    n33.push("string" == typeof r ? {
                        [r]: t
                    } : {
                        [r.key]: r.value
                    });
                }, a = (e)=>{
                    let { value: t , redirectTo: n  } = e;
                    const u = Id.normalizeDeprecatedResult(r22.deprecated(t, this._utils), i, !0);
                    if (!1 !== u) {
                        if (!0 === u) this._hasDeprecationWarned(o12) || this._utils.logger.warn(this._deprecatedHandler(o12, n, this._utils));
                        else for (const { value: e  } of u){
                            const t = {
                                key: o12,
                                value: e
                            };
                            if (!this._hasDeprecationWarned(t)) {
                                const r = "string" == typeof n ? {
                                    key: n,
                                    value: e
                                } : n;
                                this._utils.logger.warn(this._deprecatedHandler(t, r, this._utils));
                            }
                        }
                    }
                };
                Id.normalizeForwardResult(r22.forward(i, this._utils), i).forEach(s);
                const c = Id.normalizeRedirectResult(r22.redirect(i, this._utils), i);
                if (c.redirect.forEach(s), "remain" in c) {
                    const e = c.remain;
                    t57[o12] = o12 in t57 ? r22.overlap(t57[o12], e, this._utils) : e, a({
                        value: e
                    });
                }
                for (const { from: e121 , to: t56  } of c.redirect)a({
                    value: e121,
                    redirectTo: t56
                });
            }
            for (const r21 of o){
                const o = e120[r21], i = this._unknownHandler(r21, o, this._utils);
                if (i) for (const e of Object.keys(i)){
                    const r = {
                        [e]: i[e]
                    };
                    e in this._utils.schemas ? n33.push(r) : Object.assign(t57, r);
                }
            }
            return n33;
        }
    }
    wd.Normalizer = Ld, (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        const t = wp;
        t.__exportStar(Tp, e), t.__exportStar(Np, e), t.__exportStar(Uf, e), t.__exportStar(wd, e), t.__exportStar(Gf, e);
    })(bp);
    var jd = {
        exports: {
        }
    };
    const _d = [], Md = [], Rd = (e, t)=>{
        if (e === t) return 0;
        const n = e;
        e.length > t.length && (e = t, t = n);
        let r = e.length, o = t.length;
        for(; r > 0 && e.charCodeAt(~-r) === t.charCodeAt(~-o);)r--, o--;
        let i, u, s, a, c = 0;
        for(; c < r && e.charCodeAt(c) === t.charCodeAt(c);)c++;
        if (r -= c, o -= c, 0 === r) return o;
        let l = 0, p = 0;
        for(; l < r;)Md[l] = e.charCodeAt(c + l), _d[l] = ++l;
        for(; p < o;)for(i = t.charCodeAt(c + p), s = p++, u = p, l = 0; l < r; l++)a = i === Md[l] ? s : s + 1, s = _d[l], u = _d[l] = s > u ? a > u ? u + 1 : a : a > s ? s + 1 : a;
        return u;
    };
    jd.exports = Rd, jd.exports.default = Rd;
    var Vd = {
        exports: {
        }
    };
    const $d = {
        aliceblue: [
            240,
            248,
            255
        ],
        antiquewhite: [
            250,
            235,
            215
        ],
        aqua: [
            0,
            255,
            255
        ],
        aquamarine: [
            127,
            255,
            212
        ],
        azure: [
            240,
            255,
            255
        ],
        beige: [
            245,
            245,
            220
        ],
        bisque: [
            255,
            228,
            196
        ],
        black: [
            0,
            0,
            0
        ],
        blanchedalmond: [
            255,
            235,
            205
        ],
        blue: [
            0,
            0,
            255
        ],
        blueviolet: [
            138,
            43,
            226
        ],
        brown: [
            165,
            42,
            42
        ],
        burlywood: [
            222,
            184,
            135
        ],
        cadetblue: [
            95,
            158,
            160
        ],
        chartreuse: [
            127,
            255,
            0
        ],
        chocolate: [
            210,
            105,
            30
        ],
        coral: [
            255,
            127,
            80
        ],
        cornflowerblue: [
            100,
            149,
            237
        ],
        cornsilk: [
            255,
            248,
            220
        ],
        crimson: [
            220,
            20,
            60
        ],
        cyan: [
            0,
            255,
            255
        ],
        darkblue: [
            0,
            0,
            139
        ],
        darkcyan: [
            0,
            139,
            139
        ],
        darkgoldenrod: [
            184,
            134,
            11
        ],
        darkgray: [
            169,
            169,
            169
        ],
        darkgreen: [
            0,
            100,
            0
        ],
        darkgrey: [
            169,
            169,
            169
        ],
        darkkhaki: [
            189,
            183,
            107
        ],
        darkmagenta: [
            139,
            0,
            139
        ],
        darkolivegreen: [
            85,
            107,
            47
        ],
        darkorange: [
            255,
            140,
            0
        ],
        darkorchid: [
            153,
            50,
            204
        ],
        darkred: [
            139,
            0,
            0
        ],
        darksalmon: [
            233,
            150,
            122
        ],
        darkseagreen: [
            143,
            188,
            143
        ],
        darkslateblue: [
            72,
            61,
            139
        ],
        darkslategray: [
            47,
            79,
            79
        ],
        darkslategrey: [
            47,
            79,
            79
        ],
        darkturquoise: [
            0,
            206,
            209
        ],
        darkviolet: [
            148,
            0,
            211
        ],
        deeppink: [
            255,
            20,
            147
        ],
        deepskyblue: [
            0,
            191,
            255
        ],
        dimgray: [
            105,
            105,
            105
        ],
        dimgrey: [
            105,
            105,
            105
        ],
        dodgerblue: [
            30,
            144,
            255
        ],
        firebrick: [
            178,
            34,
            34
        ],
        floralwhite: [
            255,
            250,
            240
        ],
        forestgreen: [
            34,
            139,
            34
        ],
        fuchsia: [
            255,
            0,
            255
        ],
        gainsboro: [
            220,
            220,
            220
        ],
        ghostwhite: [
            248,
            248,
            255
        ],
        gold: [
            255,
            215,
            0
        ],
        goldenrod: [
            218,
            165,
            32
        ],
        gray: [
            128,
            128,
            128
        ],
        green: [
            0,
            128,
            0
        ],
        greenyellow: [
            173,
            255,
            47
        ],
        grey: [
            128,
            128,
            128
        ],
        honeydew: [
            240,
            255,
            240
        ],
        hotpink: [
            255,
            105,
            180
        ],
        indianred: [
            205,
            92,
            92
        ],
        indigo: [
            75,
            0,
            130
        ],
        ivory: [
            255,
            255,
            240
        ],
        khaki: [
            240,
            230,
            140
        ],
        lavender: [
            230,
            230,
            250
        ],
        lavenderblush: [
            255,
            240,
            245
        ],
        lawngreen: [
            124,
            252,
            0
        ],
        lemonchiffon: [
            255,
            250,
            205
        ],
        lightblue: [
            173,
            216,
            230
        ],
        lightcoral: [
            240,
            128,
            128
        ],
        lightcyan: [
            224,
            255,
            255
        ],
        lightgoldenrodyellow: [
            250,
            250,
            210
        ],
        lightgray: [
            211,
            211,
            211
        ],
        lightgreen: [
            144,
            238,
            144
        ],
        lightgrey: [
            211,
            211,
            211
        ],
        lightpink: [
            255,
            182,
            193
        ],
        lightsalmon: [
            255,
            160,
            122
        ],
        lightseagreen: [
            32,
            178,
            170
        ],
        lightskyblue: [
            135,
            206,
            250
        ],
        lightslategray: [
            119,
            136,
            153
        ],
        lightslategrey: [
            119,
            136,
            153
        ],
        lightsteelblue: [
            176,
            196,
            222
        ],
        lightyellow: [
            255,
            255,
            224
        ],
        lime: [
            0,
            255,
            0
        ],
        limegreen: [
            50,
            205,
            50
        ],
        linen: [
            250,
            240,
            230
        ],
        magenta: [
            255,
            0,
            255
        ],
        maroon: [
            128,
            0,
            0
        ],
        mediumaquamarine: [
            102,
            205,
            170
        ],
        mediumblue: [
            0,
            0,
            205
        ],
        mediumorchid: [
            186,
            85,
            211
        ],
        mediumpurple: [
            147,
            112,
            219
        ],
        mediumseagreen: [
            60,
            179,
            113
        ],
        mediumslateblue: [
            123,
            104,
            238
        ],
        mediumspringgreen: [
            0,
            250,
            154
        ],
        mediumturquoise: [
            72,
            209,
            204
        ],
        mediumvioletred: [
            199,
            21,
            133
        ],
        midnightblue: [
            25,
            25,
            112
        ],
        mintcream: [
            245,
            255,
            250
        ],
        mistyrose: [
            255,
            228,
            225
        ],
        moccasin: [
            255,
            228,
            181
        ],
        navajowhite: [
            255,
            222,
            173
        ],
        navy: [
            0,
            0,
            128
        ],
        oldlace: [
            253,
            245,
            230
        ],
        olive: [
            128,
            128,
            0
        ],
        olivedrab: [
            107,
            142,
            35
        ],
        orange: [
            255,
            165,
            0
        ],
        orangered: [
            255,
            69,
            0
        ],
        orchid: [
            218,
            112,
            214
        ],
        palegoldenrod: [
            238,
            232,
            170
        ],
        palegreen: [
            152,
            251,
            152
        ],
        paleturquoise: [
            175,
            238,
            238
        ],
        palevioletred: [
            219,
            112,
            147
        ],
        papayawhip: [
            255,
            239,
            213
        ],
        peachpuff: [
            255,
            218,
            185
        ],
        peru: [
            205,
            133,
            63
        ],
        pink: [
            255,
            192,
            203
        ],
        plum: [
            221,
            160,
            221
        ],
        powderblue: [
            176,
            224,
            230
        ],
        purple: [
            128,
            0,
            128
        ],
        rebeccapurple: [
            102,
            51,
            153
        ],
        red: [
            255,
            0,
            0
        ],
        rosybrown: [
            188,
            143,
            143
        ],
        royalblue: [
            65,
            105,
            225
        ],
        saddlebrown: [
            139,
            69,
            19
        ],
        salmon: [
            250,
            128,
            114
        ],
        sandybrown: [
            244,
            164,
            96
        ],
        seagreen: [
            46,
            139,
            87
        ],
        seashell: [
            255,
            245,
            238
        ],
        sienna: [
            160,
            82,
            45
        ],
        silver: [
            192,
            192,
            192
        ],
        skyblue: [
            135,
            206,
            235
        ],
        slateblue: [
            106,
            90,
            205
        ],
        slategray: [
            112,
            128,
            144
        ],
        slategrey: [
            112,
            128,
            144
        ],
        snow: [
            255,
            250,
            250
        ],
        springgreen: [
            0,
            255,
            127
        ],
        steelblue: [
            70,
            130,
            180
        ],
        tan: [
            210,
            180,
            140
        ],
        teal: [
            0,
            128,
            128
        ],
        thistle: [
            216,
            191,
            216
        ],
        tomato: [
            255,
            99,
            71
        ],
        turquoise: [
            64,
            224,
            208
        ],
        violet: [
            238,
            130,
            238
        ],
        wheat: [
            245,
            222,
            179
        ],
        white: [
            255,
            255,
            255
        ],
        whitesmoke: [
            245,
            245,
            245
        ],
        yellow: [
            255,
            255,
            0
        ],
        yellowgreen: [
            154,
            205,
            50
        ]
    }, Wd = {
    };
    for (const e1 of Object.keys($d))Wd[$d[e1]] = e1;
    const qd = {
        rgb: {
            channels: 3,
            labels: "rgb"
        },
        hsl: {
            channels: 3,
            labels: "hsl"
        },
        hsv: {
            channels: 3,
            labels: "hsv"
        },
        hwb: {
            channels: 3,
            labels: "hwb"
        },
        cmyk: {
            channels: 4,
            labels: "cmyk"
        },
        xyz: {
            channels: 3,
            labels: "xyz"
        },
        lab: {
            channels: 3,
            labels: "lab"
        },
        lch: {
            channels: 3,
            labels: "lch"
        },
        hex: {
            channels: 1,
            labels: [
                "hex"
            ]
        },
        keyword: {
            channels: 1,
            labels: [
                "keyword"
            ]
        },
        ansi16: {
            channels: 1,
            labels: [
                "ansi16"
            ]
        },
        ansi256: {
            channels: 1,
            labels: [
                "ansi256"
            ]
        },
        hcg: {
            channels: 3,
            labels: [
                "h",
                "c",
                "g"
            ]
        },
        apple: {
            channels: 3,
            labels: [
                "r16",
                "g16",
                "b16"
            ]
        },
        gray: {
            channels: 1,
            labels: [
                "gray"
            ]
        }
    };
    var Ud = qd;
    for (const e2 of Object.keys(qd)){
        if (!("channels" in qd[e2])) throw new Error("missing channels property: " + e2);
        if (!("labels" in qd[e2])) throw new Error("missing channel labels property: " + e2);
        if (qd[e2].labels.length !== qd[e2].channels) throw new Error("channel and label counts mismatch: " + e2);
        const { channels: t , labels: n  } = qd[e2];
        delete qd[e2].channels, delete qd[e2].labels, Object.defineProperty(qd[e2], "channels", {
            value: t
        }), Object.defineProperty(qd[e2], "labels", {
            value: n
        });
    }
    qd.rgb.hsl = function(e) {
        const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), i = Math.max(t, n, r), u = i - o;
        let s, a;
        i === o ? s = 0 : t === i ? s = (n - r) / u : n === i ? s = 2 + (r - t) / u : r === i && (s = 4 + (t - n) / u), s = Math.min(60 * s, 360), s < 0 && (s += 360);
        const c = (o + i) / 2;
        return a = i === o ? 0 : c <= 0.5 ? u / (i + o) : u / (2 - i - o), [
            s,
            100 * a,
            100 * c
        ];
    }, qd.rgb.hsv = function(e123) {
        let t, n, r, o, i;
        const u = e123[0] / 255, s = e123[1] / 255, a = e123[2] / 255, c = Math.max(u, s, a), l = c - Math.min(u, s, a), p = function(e) {
            return (c - e) / 6 / l + 0.5;
        };
        return 0 === l ? (o = 0, i = 0) : (i = l / c, t = p(u), n = p(s), r = p(a), u === c ? o = r - n : s === c ? o = 1 / 3 + t - r : a === c && (o = 2 / 3 + n - t), o < 0 ? o += 1 : o > 1 && (o -= 1)), [
            360 * o,
            100 * i,
            100 * c
        ];
    }, qd.rgb.hwb = function(e) {
        const t = e[0], n = e[1];
        let r = e[2];
        const o = qd.rgb.hsl(e)[0], i = 1 / 255 * Math.min(t, Math.min(n, r));
        return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [
            o,
            100 * i,
            100 * r
        ];
    }, qd.rgb.cmyk = function(e) {
        const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r);
        return [
            100 * ((1 - t - o) / (1 - o) || 0),
            100 * ((1 - n - o) / (1 - o) || 0),
            100 * ((1 - r - o) / (1 - o) || 0),
            100 * o
        ];
    }, qd.rgb.keyword = function(e) {
        const t = Wd[e];
        if (t) return t;
        let n, r = 1 / 0;
        for (const t58 of Object.keys($d)){
            const u = (i = $d[t58], ((o = e)[0] - i[0]) ** 2 + (o[1] - i[1]) ** 2 + (o[2] - i[2]) ** 2);
            u < r && (r = u, n = t58);
        }
        var o, i;
        return n;
    }, qd.keyword.rgb = function(e) {
        return $d[e];
    }, qd.rgb.xyz = function(e) {
        let t = e[0] / 255, n = e[1] / 255, r = e[2] / 255;
        t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92, n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92, r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
        return [
            100 * (0.4124 * t + 0.3576 * n + 0.1805 * r),
            100 * (0.2126 * t + 0.7152 * n + 0.0722 * r),
            100 * (0.0193 * t + 0.1192 * n + 0.9505 * r)
        ];
    }, qd.rgb.lab = function(e) {
        const t = qd.rgb.xyz(e);
        let n = t[0], r = t[1], o = t[2];
        n /= 95.047, r /= 100, o /= 108.883, n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
        return [
            116 * r - 16,
            500 * (n - r),
            200 * (r - o)
        ];
    }, qd.hsl.rgb = function(e) {
        const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
        let o, i, u;
        if (0 === n) return u = 255 * r, [
            u,
            u,
            u
        ];
        o = r < 0.5 ? r * (1 + n) : r + n - r * n;
        const s = 2 * r - o, a = [
            0,
            0,
            0
        ];
        for(let e124 = 0; e124 < 3; e124++)i = t + 1 / 3 * -(e124 - 1), i < 0 && i++, i > 1 && i--, u = 6 * i < 1 ? s + 6 * (o - s) * i : 2 * i < 1 ? o : 3 * i < 2 ? s + (o - s) * (2 / 3 - i) * 6 : s, a[e124] = 255 * u;
        return a;
    }, qd.hsl.hsv = function(e) {
        const t = e[0];
        let n = e[1] / 100, r = e[2] / 100, o = n;
        const i = Math.max(r, 0.01);
        r *= 2, n *= r <= 1 ? r : 2 - r, o *= i <= 1 ? i : 2 - i;
        return [
            t,
            100 * (0 === r ? 2 * o / (i + o) : 2 * n / (r + n)),
            100 * ((r + n) / 2)
        ];
    }, qd.hsv.rgb = function(e) {
        const t = e[0] / 60, n = e[1] / 100;
        let r = e[2] / 100;
        const o = Math.floor(t) % 6, i = t - Math.floor(t), u = 255 * r * (1 - n), s = 255 * r * (1 - n * i), a = 255 * r * (1 - n * (1 - i));
        switch(r *= 255, o){
            case 0:
                return [
                    r,
                    a,
                    u
                ];
            case 1:
                return [
                    s,
                    r,
                    u
                ];
            case 2:
                return [
                    u,
                    r,
                    a
                ];
            case 3:
                return [
                    u,
                    s,
                    r
                ];
            case 4:
                return [
                    a,
                    u,
                    r
                ];
            case 5:
                return [
                    r,
                    u,
                    s
                ];
        }
    }, qd.hsv.hsl = function(e) {
        const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, 0.01);
        let i, u;
        u = (2 - n) * r;
        const s = (2 - n) * o;
        return i = n * o, i /= s <= 1 ? s : 2 - s, i = i || 0, u /= 2, [
            t,
            100 * i,
            100 * u
        ];
    }, qd.hwb.rgb = function(e) {
        const t = e[0] / 360;
        let n = e[1] / 100, r = e[2] / 100;
        const o = n + r;
        let i;
        o > 1 && (n /= o, r /= o);
        const u = Math.floor(6 * t), s = 1 - r;
        i = 6 * t - u, 0 != (1 & u) && (i = 1 - i);
        const a = n + i * (s - n);
        let c, l, p;
        switch(u){
            default:
            case 6:
            case 0:
                c = s, l = a, p = n;
                break;
            case 1:
                c = a, l = s, p = n;
                break;
            case 2:
                c = n, l = s, p = a;
                break;
            case 3:
                c = n, l = a, p = s;
                break;
            case 4:
                c = a, l = n, p = s;
                break;
            case 5:
                c = s, l = n, p = a;
        }
        return [
            255 * c,
            255 * l,
            255 * p
        ];
    }, qd.cmyk.rgb = function(e) {
        const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100;
        return [
            255 * (1 - Math.min(1, t * (1 - o) + o)),
            255 * (1 - Math.min(1, n * (1 - o) + o)),
            255 * (1 - Math.min(1, r * (1 - o) + o))
        ];
    }, qd.xyz.rgb = function(e) {
        const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
        let o, i, u;
        return o = 3.2406 * t + -1.5372 * n + -0.4986 * r, i = -0.9689 * t + 1.8758 * n + 0.0415 * r, u = 0.0557 * t + -0.204 * n + 1.057 * r, o = o > 0.0031308 ? 1.055 * o ** (1 / 2.4) - 0.055 : 12.92 * o, i = i > 0.0031308 ? 1.055 * i ** (1 / 2.4) - 0.055 : 12.92 * i, u = u > 0.0031308 ? 1.055 * u ** (1 / 2.4) - 0.055 : 12.92 * u, o = Math.min(Math.max(0, o), 1), i = Math.min(Math.max(0, i), 1), u = Math.min(Math.max(0, u), 1), [
            255 * o,
            255 * i,
            255 * u
        ];
    }, qd.xyz.lab = function(e) {
        let t = e[0], n = e[1], r = e[2];
        t /= 95.047, n /= 100, r /= 108.883, t = t > 0.008856 ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116;
        return [
            116 * n - 16,
            500 * (t - n),
            200 * (n - r)
        ];
    }, qd.lab.xyz = function(e) {
        let t, n, r;
        n = (e[0] + 16) / 116, t = e[1] / 500 + n, r = n - e[2] / 200;
        const o = n ** 3, i = t ** 3, u = r ** 3;
        return n = o > 0.008856 ? o : (n - 16 / 116) / 7.787, t = i > 0.008856 ? i : (t - 16 / 116) / 7.787, r = u > 0.008856 ? u : (r - 16 / 116) / 7.787, t *= 95.047, n *= 100, r *= 108.883, [
            t,
            n,
            r
        ];
    }, qd.lab.lch = function(e) {
        const t = e[0], n = e[1], r = e[2];
        let o;
        o = 360 * Math.atan2(r, n) / 2 / Math.PI, o < 0 && (o += 360);
        return [
            t,
            Math.sqrt(n * n + r * r),
            o
        ];
    }, qd.lch.lab = function(e) {
        const t = e[0], n = e[1], r = e[2] / 360 * 2 * Math.PI;
        return [
            t,
            n * Math.cos(r),
            n * Math.sin(r)
        ];
    }, qd.rgb.ansi16 = function(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        const [n, r, o] = e;
        let i = null === t ? qd.rgb.hsv(e)[2] : t;
        if (i = Math.round(i / 50), 0 === i) return 30;
        let u = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
        return 2 === i && (u += 60), u;
    }, qd.hsv.ansi16 = function(e) {
        return qd.rgb.ansi16(qd.hsv.rgb(e), e[2]);
    }, qd.rgb.ansi256 = function(e) {
        const t = e[0], n = e[1], r = e[2];
        if (t === n && n === r) return t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232;
        return 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
    }, qd.ansi16.rgb = function(e) {
        let t = e % 10;
        if (0 === t || 7 === t) return e > 50 && (t += 3.5), t = t / 10.5 * 255, [
            t,
            t,
            t
        ];
        const n = 0.5 * (1 + ~~(e > 50));
        return [
            (1 & t) * n * 255,
            (t >> 1 & 1) * n * 255,
            (t >> 2 & 1) * n * 255
        ];
    }, qd.ansi256.rgb = function(e) {
        if (e >= 232) {
            const t = 10 * (e - 232) + 8;
            return [
                t,
                t,
                t
            ];
        }
        let t;
        e -= 16;
        return [
            Math.floor(e / 36) / 5 * 255,
            Math.floor((t = e % 36) / 6) / 5 * 255,
            t % 6 / 5 * 255
        ];
    }, qd.rgb.hex = function(e) {
        const t = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase();
        return "000000".substring(t.length) + t;
    }, qd.hex.rgb = function(e125) {
        const t = e125.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t) return [
            0,
            0,
            0
        ];
        let n = t[0];
        3 === t[0].length && (n = n.split("").map((e)=>e + e
        ).join(""));
        const r = parseInt(n, 16);
        return [
            r >> 16 & 255,
            r >> 8 & 255,
            255 & r
        ];
    }, qd.rgb.hcg = function(e) {
        const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), i = Math.min(Math.min(t, n), r), u = o - i;
        let s, a;
        return s = u < 1 ? i / (1 - u) : 0, a = u <= 0 ? 0 : o === t ? (n - r) / u % 6 : o === n ? 2 + (r - t) / u : 4 + (t - n) / u, a /= 6, a %= 1, [
            360 * a,
            100 * u,
            100 * s
        ];
    }, qd.hsl.hcg = function(e) {
        const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
        let o = 0;
        return r < 1 && (o = (n - 0.5 * r) / (1 - r)), [
            e[0],
            100 * r,
            100 * o
        ];
    }, qd.hsv.hcg = function(e) {
        const t = e[1] / 100, n = e[2] / 100, r = t * n;
        let o = 0;
        return r < 1 && (o = (n - r) / (1 - r)), [
            e[0],
            100 * r,
            100 * o
        ];
    }, qd.hcg.rgb = function(e) {
        const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
        if (0 === n) return [
            255 * r,
            255 * r,
            255 * r
        ];
        const o = [
            0,
            0,
            0
        ], i = t % 1 * 6, u = i % 1, s = 1 - u;
        let a = 0;
        switch(Math.floor(i)){
            case 0:
                o[0] = 1, o[1] = u, o[2] = 0;
                break;
            case 1:
                o[0] = s, o[1] = 1, o[2] = 0;
                break;
            case 2:
                o[0] = 0, o[1] = 1, o[2] = u;
                break;
            case 3:
                o[0] = 0, o[1] = s, o[2] = 1;
                break;
            case 4:
                o[0] = u, o[1] = 0, o[2] = 1;
                break;
            default:
                o[0] = 1, o[1] = 0, o[2] = s;
        }
        return a = (1 - n) * r, [
            255 * (n * o[0] + a),
            255 * (n * o[1] + a),
            255 * (n * o[2] + a)
        ];
    }, qd.hcg.hsv = function(e) {
        const t = e[1] / 100, n = t + e[2] / 100 * (1 - t);
        let r = 0;
        return n > 0 && (r = t / n), [
            e[0],
            100 * r,
            100 * n
        ];
    }, qd.hcg.hsl = function(e) {
        const t = e[1] / 100, n = e[2] / 100 * (1 - t) + 0.5 * t;
        let r = 0;
        return n > 0 && n < 0.5 ? r = t / (2 * n) : n >= 0.5 && n < 1 && (r = t / (2 * (1 - n))), [
            e[0],
            100 * r,
            100 * n
        ];
    }, qd.hcg.hwb = function(e) {
        const t = e[1] / 100, n = t + e[2] / 100 * (1 - t);
        return [
            e[0],
            100 * (n - t),
            100 * (1 - n)
        ];
    }, qd.hwb.hcg = function(e) {
        const t = e[1] / 100, n = 1 - e[2] / 100, r = n - t;
        let o = 0;
        return r < 1 && (o = (n - r) / (1 - r)), [
            e[0],
            100 * r,
            100 * o
        ];
    }, qd.apple.rgb = function(e) {
        return [
            e[0] / 65535 * 255,
            e[1] / 65535 * 255,
            e[2] / 65535 * 255
        ];
    }, qd.rgb.apple = function(e) {
        return [
            e[0] / 255 * 65535,
            e[1] / 255 * 65535,
            e[2] / 255 * 65535
        ];
    }, qd.gray.rgb = function(e) {
        return [
            e[0] / 100 * 255,
            e[0] / 100 * 255,
            e[0] / 100 * 255
        ];
    }, qd.gray.hsl = function(e) {
        return [
            0,
            0,
            e[0]
        ];
    }, qd.gray.hsv = qd.gray.hsl, qd.gray.hwb = function(e) {
        return [
            0,
            100,
            e[0]
        ];
    }, qd.gray.cmyk = function(e) {
        return [
            0,
            0,
            0,
            e[0]
        ];
    }, qd.gray.lab = function(e) {
        return [
            e[0],
            0,
            0
        ];
    }, qd.gray.hex = function(e) {
        const t = 255 & Math.round(e[0] / 100 * 255), n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
        return "000000".substring(n.length) + n;
    }, qd.rgb.gray = function(e) {
        return [
            (e[0] + e[1] + e[2]) / 3 / 255 * 100
        ];
    };
    const zd = Ud;
    function Gd(e126) {
        const t59 = function() {
            const e = {
            }, t = Object.keys(zd);
            for(let n = t.length, r = 0; r < n; r++)e[t[r]] = {
                distance: -1,
                parent: null
            };
            return e;
        }(), n34 = [
            e126
        ];
        for(t59[e126].distance = 0; n34.length;){
            const e = n34.pop(), r = Object.keys(zd[e]);
            for(let o = r.length, i = 0; i < o; i++){
                const o = r[i], u = t59[o];
                -1 === u.distance && (u.distance = t59[e].distance + 1, u.parent = e, n34.unshift(o));
            }
        }
        return t59;
    }
    function Hd(e, t) {
        return function(n) {
            return t(e(n));
        };
    }
    function Jd(e, t) {
        const n = [
            t[e].parent,
            e
        ];
        let r = zd[t[e].parent][e], o = t[e].parent;
        for(; t[o].parent;)n.unshift(t[o].parent), r = Hd(zd[t[o].parent][o], r), o = t[o].parent;
        return r.conversion = n, r;
    }
    const Xd = Ud, Yd = function(e) {
        const t = Gd(e), n = {
        }, r = Object.keys(t);
        for(let e127 = r.length, o = 0; o < e127; o++){
            const e127 = r[o];
            null !== t[e127].parent && (n[e127] = Jd(e127, t));
        }
        return n;
    }, Kd = {
    };
    Object.keys(Xd).forEach((e128)=>{
        Kd[e128] = {
        }, Object.defineProperty(Kd[e128], "channels", {
            value: Xd[e128].channels
        }), Object.defineProperty(Kd[e128], "labels", {
            value: Xd[e128].labels
        });
        const t61 = Yd(e128);
        Object.keys(t61).forEach((n35)=>{
            const r24 = t61[n35];
            Kd[e128][n35] = (function(e) {
                const t62 = function() {
                    for(var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r];
                    const o = n[0];
                    if (null == o) return o;
                    o.length > 1 && (n = o);
                    const i = e(n);
                    if ("object" == typeof i) for(let e129 = i.length, t60 = 0; t60 < e129; t60++)i[t60] = Math.round(i[t60]);
                    return i;
                };
                return "conversion" in e && (t62.conversion = e.conversion), t62;
            })(r24), Kd[e128][n35].raw = (function(e) {
                const t63 = function() {
                    for(var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r];
                    const o = n[0];
                    return null == o ? o : (o.length > 1 && (n = o), e(n));
                };
                return "conversion" in e && (t63.conversion = e.conversion), t63;
            })(r24);
        });
    });
    var Qd = Kd;
    function Zd() {
        return !1;
    }
    function eh() {
        throw new Error("tty.ReadStream is not implemented");
    }
    function th() {
        throw new Error("tty.ReadStream is not implemented");
    }
    !function(e130) {
        const t64 = (e, t)=>function() {
                const n = e(...arguments);
                return "\x1b[".concat(n + t, "m");
            }
        , n36 = (e, t)=>function() {
                const n = e(...arguments);
                return "\x1b[".concat(38 + t, ";5;").concat(n, "m");
            }
        , r25 = (e, t)=>function() {
                const n = e(...arguments);
                return "\x1b[".concat(38 + t, ";2;").concat(n[0], ";").concat(n[1], ";").concat(n[2], "m");
            }
        , o13 = (e)=>e
        , i10 = (e, t, n)=>[
                e,
                t,
                n
            ]
        , u8 = (e, t, n)=>{
            Object.defineProperty(e, t, {
                get: ()=>{
                    const r = n();
                    return Object.defineProperty(e, t, {
                        value: r,
                        enumerable: !0,
                        configurable: !0
                    }), r;
                },
                enumerable: !0,
                configurable: !0
            });
        };
        let s5;
        const a = (e, t, n, r)=>{
            void 0 === s5 && (s5 = Qd);
            const o = r ? 10 : 0, i = {
            };
            for (const [r26, u] of Object.entries(s5)){
                const s = "ansi16" === r26 ? "ansi" : r26;
                r26 === t ? i[s] = e(n, o) : "object" == typeof u && (i[s] = e(u[t], o));
            }
            return i;
        };
        Object.defineProperty(e130, "exports", {
            enumerable: !0,
            get: function() {
                const e = new Map, s = {
                    modifier: {
                        reset: [
                            0,
                            0
                        ],
                        bold: [
                            1,
                            22
                        ],
                        dim: [
                            2,
                            22
                        ],
                        italic: [
                            3,
                            23
                        ],
                        underline: [
                            4,
                            24
                        ],
                        inverse: [
                            7,
                            27
                        ],
                        hidden: [
                            8,
                            28
                        ],
                        strikethrough: [
                            9,
                            29
                        ]
                    },
                    color: {
                        black: [
                            30,
                            39
                        ],
                        red: [
                            31,
                            39
                        ],
                        green: [
                            32,
                            39
                        ],
                        yellow: [
                            33,
                            39
                        ],
                        blue: [
                            34,
                            39
                        ],
                        magenta: [
                            35,
                            39
                        ],
                        cyan: [
                            36,
                            39
                        ],
                        white: [
                            37,
                            39
                        ],
                        blackBright: [
                            90,
                            39
                        ],
                        redBright: [
                            91,
                            39
                        ],
                        greenBright: [
                            92,
                            39
                        ],
                        yellowBright: [
                            93,
                            39
                        ],
                        blueBright: [
                            94,
                            39
                        ],
                        magentaBright: [
                            95,
                            39
                        ],
                        cyanBright: [
                            96,
                            39
                        ],
                        whiteBright: [
                            97,
                            39
                        ]
                    },
                    bgColor: {
                        bgBlack: [
                            40,
                            49
                        ],
                        bgRed: [
                            41,
                            49
                        ],
                        bgGreen: [
                            42,
                            49
                        ],
                        bgYellow: [
                            43,
                            49
                        ],
                        bgBlue: [
                            44,
                            49
                        ],
                        bgMagenta: [
                            45,
                            49
                        ],
                        bgCyan: [
                            46,
                            49
                        ],
                        bgWhite: [
                            47,
                            49
                        ],
                        bgBlackBright: [
                            100,
                            49
                        ],
                        bgRedBright: [
                            101,
                            49
                        ],
                        bgGreenBright: [
                            102,
                            49
                        ],
                        bgYellowBright: [
                            103,
                            49
                        ],
                        bgBlueBright: [
                            104,
                            49
                        ],
                        bgMagentaBright: [
                            105,
                            49
                        ],
                        bgCyanBright: [
                            106,
                            49
                        ],
                        bgWhiteBright: [
                            107,
                            49
                        ]
                    }
                };
                s.color.gray = s.color.blackBright, s.bgColor.bgGray = s.bgColor.bgBlackBright, s.color.grey = s.color.blackBright, s.bgColor.bgGrey = s.bgColor.bgBlackBright;
                for (const [t, n] of Object.entries(s)){
                    for (const [t65, r] of Object.entries(n))s[t65] = {
                        open: "\x1b[".concat(r[0], "m"),
                        close: "\x1b[".concat(r[1], "m")
                    }, n[t65] = s[t65], e.set(r[0], r[1]);
                    Object.defineProperty(s, t, {
                        value: n,
                        enumerable: !1
                    });
                }
                return Object.defineProperty(s, "codes", {
                    value: e,
                    enumerable: !1
                }), s.color.close = "\x1b[39m", s.bgColor.close = "\x1b[49m", u8(s.color, "ansi", ()=>a(t64, "ansi16", o13, !1)
                ), u8(s.color, "ansi256", ()=>a(n36, "ansi256", o13, !1)
                ), u8(s.color, "ansi16m", ()=>a(r25, "rgb", i10, !1)
                ), u8(s.bgColor, "ansi", ()=>a(t64, "ansi16", o13, !0)
                ), u8(s.bgColor, "ansi256", ()=>a(n36, "ansi256", o13, !0)
                ), u8(s.bgColor, "ansi16m", ()=>a(r25, "rgb", i10, !0)
                ), s;
            }
        });
    }(Vd);
    var nh = {
        isatty: Zd,
        ReadStream: eh,
        WriteStream: th
    };
    const rh = yf, oh = t3(Object.freeze({
        __proto__: null,
        isatty: Zd,
        ReadStream: eh,
        WriteStream: th,
        default: nh
    })), ih = function(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ta.argv;
        const n = e.startsWith("-") ? "" : 1 === e.length ? "-" : "--", r = t.indexOf(n + e), o = t.indexOf("--");
        return -1 !== r && (-1 === o || r < o);
    }, { env: uh  } = ta;
    let sh;
    function ah(e) {
        return 0 !== e && {
            level: e,
            hasBasic: !0,
            has256: e >= 2,
            has16m: e >= 3
        };
    }
    function ch(e131, t) {
        if (0 === sh) return 0;
        if (ih("color=16m") || ih("color=full") || ih("color=truecolor")) return 3;
        if (ih("color=256")) return 2;
        if (e131 && !t && void 0 === sh) return 0;
        const n = sh || 0;
        if ("dumb" === uh.TERM) return n;
        if ("win32" === ta.platform) {
            const e = rh.release().split(".");
            return Number(e[0]) >= 10 && Number(e[2]) >= 10586 ? Number(e[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in uh) return [
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "GITHUB_ACTIONS",
            "BUILDKITE"
        ].some((e)=>e in uh
        ) || "codeship" === uh.CI_NAME ? 1 : n;
        if ("TEAMCITY_VERSION" in uh) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(uh.TEAMCITY_VERSION) ? 1 : 0;
        if ("truecolor" === uh.COLORTERM) return 3;
        if ("TERM_PROGRAM" in uh) {
            const e = parseInt((uh.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch(uh.TERM_PROGRAM){
                case "iTerm.app":
                    return e >= 3 ? 3 : 2;
                case "Apple_Terminal":
                    return 2;
            }
        }
        return /-256(color)?$/i.test(uh.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(uh.TERM) || "COLORTERM" in uh ? 1 : n;
    }
    ih("no-color") || ih("no-colors") || ih("color=false") || ih("color=never") ? sh = 0 : (ih("color") || ih("colors") || ih("color=true") || ih("color=always")) && (sh = 1), "FORCE_COLOR" in uh && (sh = "true" === uh.FORCE_COLOR ? 1 : "false" === uh.FORCE_COLOR ? 0 : 0 === uh.FORCE_COLOR.length ? 1 : Math.min(parseInt(uh.FORCE_COLOR, 10), 3));
    var lh = {
        supportsColor: function(e) {
            return ah(ch(e, e && e.isTTY));
        },
        stdout: ah(ch(!0, oh.isatty(1))),
        stderr: ah(ch(!0, oh.isatty(2)))
    };
    var ph = {
        stringReplaceAll: (e, t, n)=>{
            let r = e.indexOf(t);
            if (-1 === r) return e;
            const o = t.length;
            let i = 0, u = "";
            do u += e.substr(i, r - i) + t + n, i = r + o, r = e.indexOf(t, i);
            while (-1 !== r)
            return u += e.substr(i), u;
        },
        stringEncaseCRLFWithFirstIndex: (e, t, n, r)=>{
            let o = 0, i = "";
            do {
                const u = "\r" === e[r - 1];
                i += e.substr(o, (u ? r - 1 : r) - o) + t + (u ? "\r\n" : "\n") + n, o = r + 1, r = e.indexOf("\n", o);
            }while (-1 !== r)
            return i += e.substr(o), i;
        }
    };
    const fh = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, dh = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, hh = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, gh = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, mh = new Map([
        [
            "n",
            "\n"
        ],
        [
            "r",
            "\r"
        ],
        [
            "t",
            "\t"
        ],
        [
            "b",
            "\b"
        ],
        [
            "f",
            "\f"
        ],
        [
            "v",
            "\v"
        ],
        [
            "0",
            "\0"
        ],
        [
            "\\",
            "\\"
        ],
        [
            "e",
            "\x1b"
        ],
        [
            "a",
            "\x07"
        ]
    ]);
    function yh(e) {
        const t = "u" === e[0], n = "{" === e[1];
        return t && !n && 5 === e.length || "x" === e[0] && 3 === e.length ? String.fromCharCode(parseInt(e.slice(1), 16)) : t && n ? String.fromCodePoint(parseInt(e.slice(2, -1), 16)) : mh.get(e) || e;
    }
    function Dh(e, t67) {
        const n37 = [], r = t67.trim().split(/\s*,\s*/g);
        let o;
        for (const t66 of r){
            const r = Number(t66);
            if (Number.isNaN(r)) {
                if (!(o = t66.match(hh))) throw new Error("Invalid Chalk template style argument: ".concat(t66, " (in style '").concat(e, "')"));
                n37.push(o[2].replace(gh, (e, t, n)=>t ? yh(t) : n
                ));
            } else n37.push(r);
        }
        return n37;
    }
    function Eh(e) {
        dh.lastIndex = 0;
        const t = [];
        let n;
        for(; null !== (n = dh.exec(e));){
            const e = n[1];
            if (n[2]) {
                const r = Dh(e, n[2]);
                t.push([
                    e
                ].concat(r));
            } else t.push([
                e
            ]);
        }
        return t;
    }
    function Ch(e, t) {
        const n = {
        };
        for (const e132 of t)for (const t68 of e132.styles)n[t68[0]] = e132.inverse ? null : t68.slice(1);
        let r = e;
        for (const [e133, t69] of Object.entries(n))if (Array.isArray(t69)) {
            if (!(e133 in r)) throw new Error("Unknown Chalk style: ".concat(e133));
            r = t69.length > 0 ? r[e133](...t69) : r[e133];
        }
        return r;
    }
    var bh = (e, t70)=>{
        const n = [], r = [];
        let o = [];
        if (t70.replace(fh, (t, i, u, s, a, c)=>{
            if (i) o.push(yh(i));
            else if (s) {
                const t = o.join("");
                o = [], r.push(0 === n.length ? t : Ch(e, n)(t)), n.push({
                    inverse: u,
                    styles: Eh(s)
                });
            } else if (a) {
                if (0 === n.length) throw new Error("Found extraneous } in Chalk template literal");
                r.push(Ch(e, n)(o.join(""))), o = [], n.pop();
            } else o.push(c);
        }), r.push(o.join("")), n.length > 0) {
            const e = "Chalk template literal is missing ".concat(n.length, " closing bracket").concat(1 === n.length ? "" : "s", " (`}`)");
            throw new Error(e);
        }
        return r.join("");
    };
    const vh = Vd.exports, { stdout: Ah , stderr: Fh  } = lh, { stringReplaceAll: xh , stringEncaseCRLFWithFirstIndex: Sh  } = ph, { isArray: wh  } = Array, Th = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
    ], Bh = Object.create(null);
    class Nh {
        constructor(e){
            return kh(e);
        }
    }
    const kh = (e134)=>{
        const t71 = {
        };
        return (function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
            };
            if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
            const n = Ah ? Ah.level : 0;
            e.level = void 0 === t.level ? n : t.level;
        })(t71, e134), t71.template = function() {
            for(var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r];
            return Rh(t71.template, ...n);
        }, Object.setPrototypeOf(t71, Ph.prototype), Object.setPrototypeOf(t71.template, t71), t71.template.constructor = ()=>{
            throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        }, t71.template.Instance = Nh, t71.template;
    };
    function Ph(e) {
        return kh(e);
    }
    for (const [e3, t1] of Object.entries(vh))Bh[e3] = {
        get () {
            const n = jh(this, Lh(t1.open, t1.close, this._styler), this._isEmpty);
            return Object.defineProperty(this, e3, {
                value: n
            }), n;
        }
    };
    Bh.visible = {
        get () {
            const e = jh(this, this._styler, !0);
            return Object.defineProperty(this, "visible", {
                value: e
            }), e;
        }
    };
    const Oh = [
        "rgb",
        "hex",
        "keyword",
        "hsl",
        "hsv",
        "hwb",
        "ansi",
        "ansi256"
    ];
    for (const e4 of Oh)Bh[e4] = {
        get () {
            const { level: t  } = this;
            return function() {
                const n = Lh(vh.color[Th[t]][e4](...arguments), vh.color.close, this._styler);
                return jh(this, n, this._isEmpty);
            };
        }
    };
    for (const e5 of Oh)Bh["bg" + e5[0].toUpperCase() + e5.slice(1)] = {
        get () {
            const { level: t  } = this;
            return function() {
                const n = Lh(vh.bgColor[Th[t]][e5](...arguments), vh.bgColor.close, this._styler);
                return jh(this, n, this._isEmpty);
            };
        }
    };
    const Ih = Object.defineProperties(()=>{
    }, Object.assign(Object.assign({
    }, Bh), {
    }, {
        level: {
            enumerable: !0,
            get () {
                return this._generator.level;
            },
            set (e) {
                this._generator.level = e;
            }
        }
    })), Lh = (e, t, n)=>{
        let r, o;
        return void 0 === n ? (r = e, o = t) : (r = n.openAll + e, o = t + n.closeAll), {
            open: e,
            close: t,
            openAll: r,
            closeAll: o,
            parent: n
        };
    }, jh = (e135, t72, n38)=>{
        const r = function() {
            for(var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n];
            return wh(t[0]) && wh(t[0].raw) ? _h(r, Rh(r, ...t)) : _h(r, 1 === t.length ? "" + t[0] : t.join(" "));
        };
        return Object.setPrototypeOf(r, Ih), r._generator = e135, r._styler = t72, r._isEmpty = n38, r;
    }, _h = (e, t)=>{
        if (e.level <= 0 || !t) return e._isEmpty ? "" : t;
        let n = e._styler;
        if (void 0 === n) return t;
        const { openAll: r , closeAll: o  } = n;
        if (-1 !== t.indexOf("\x1b")) for(; void 0 !== n;)t = xh(t, n.close, n.open), n = n.parent;
        const i = t.indexOf("\n");
        return -1 !== i && (t = Sh(t, o, r, i)), r + t + o;
    };
    let Mh;
    const Rh = function(e) {
        for(var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r];
        const [o] = n;
        if (!wh(o) || !wh(o.raw)) return n.join(" ");
        const i = n.slice(1), u = [
            o.raw[0]
        ];
        for(let e136 = 1; e136 < o.length; e136++)u.push(String(i[e136 - 1]).replace(/[{}\\]/g, "\\$&"), String(o.raw[e136]));
        return void 0 === Mh && (Mh = bh), Mh(e, u.join(""));
    };
    Object.defineProperties(Ph.prototype, Bh);
    const Vh = Ph();
    Vh.supportsColor = Ah, Vh.stderr = Ph({
        level: Fh ? Fh.level : 0
    }), Vh.stderr.supportsColor = Fh;
    var $h = Vh;
    const Wh = [
        "_"
    ], qh = bp, Uh = jd.exports, zh = $h, Gh = au, Hh = {
        key: (e)=>1 === e.length ? "-".concat(e) : "--".concat(e)
        ,
        value: (e)=>qh.apiDescriptor.value(e)
        ,
        pair: (e)=>{
            let { key: t , value: n  } = e;
            return !1 === n ? "--no-".concat(t) : !0 === n ? Hh.key(t) : "" === n ? "".concat(Hh.key(t), " without an argument") : "".concat(Hh.key(t), "=").concat(n);
        }
    };
    class Jh extends qh.ChoiceSchema {
        constructor(e){
            let { name: t , flags: n  } = e;
            super({
                name: t,
                choices: n
            }), this._flags = [
                ...n
            ].sort();
        }
        preprocess(e, t73) {
            if ("string" == typeof e && e.length > 0 && !this._flags.includes(e)) {
                const n = this._flags.find((t)=>Uh(t, e) < 3
                );
                if (n) return t73.logger.warn([
                    "Unknown flag ".concat(zh.yellow(t73.descriptor.value(e)), ","),
                    "did you mean ".concat(zh.blue(t73.descriptor.value(n)), "?")
                ].join(" ")), n;
            }
            return e;
        }
        expected() {
            return "a flag";
        }
    }
    let Xh;
    function Yh(e137, t74) {
        let { logger: n39 , isCLI: r27 = !1 , passThrough: o = !1  } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
        };
        const i = o ? Array.isArray(o) ? (e, t)=>o.includes(e) ? {
                [e]: t
            } : void 0
         : (e, t)=>({
                [e]: t
            })
         : (e, t, n)=>{
            const r = cu(n.schemas, Wh);
            return qh.levenUnknownHandler(e, t, Object.assign(Object.assign({
            }, n), {
            }, {
                schemas: r
            }));
        }, u = r27 ? Hh : qh.apiDescriptor, s = Kh(t74, {
            isCLI: r27
        }), a = new qh.Normalizer(s, {
            logger: n39,
            unknown: i,
            descriptor: u
        }), c = !1 !== n39;
        c && Xh && (a._hasDeprecationWarned = Xh);
        const l = a.normalize(e137);
        return c && (Xh = a._hasDeprecationWarned), l;
    }
    function Kh(e, t) {
        let { isCLI: n  } = t;
        const r = [];
        n && r.push(qh.AnySchema.create({
            name: "_"
        }));
        for (const t75 of e)r.push(Qh(t75, {
            isCLI: n,
            optionInfos: e
        })), t75.alias && n && r.push(qh.AliasSchema.create({
            name: t75.alias,
            sourceName: t75.name
        }));
        return r;
    }
    function Qh(e138, t76) {
        let n40, { isCLI: r28 , optionInfos: o  } = t76;
        const i = {
            name: e138.name
        }, u = {
        };
        switch(e138.type){
            case "int":
                n40 = qh.IntegerSchema, r28 && (i.preprocess = (e)=>Number(e)
                );
                break;
            case "string":
            case "path":
                n40 = qh.StringSchema;
                break;
            case "choice":
                n40 = qh.ChoiceSchema, i.choices = e138.choices.map((t)=>"object" == typeof t && t.redirect ? Object.assign(Object.assign({
                    }, t), {
                    }, {
                        redirect: {
                            to: {
                                key: e138.name,
                                value: t.redirect
                            }
                        }
                    }) : t
                );
                break;
            case "boolean":
                n40 = qh.BooleanSchema;
                break;
            case "flag":
                n40 = Jh, i.flags = o.flatMap((e)=>[
                        e.alias,
                        e.description && e.name,
                        e.oppositeDescription && "no-".concat(e.name)
                    ].filter(Boolean)
                );
                break;
            default:
                throw new Error("Unexpected type ".concat(e138.type));
        }
        if (e138.exception ? i.validate = (t, n, r)=>e138.exception(t) || n.validate(t, r)
         : i.validate = (e, t, n)=>void 0 === e || t.validate(e, n)
        , e138.redirect && (u.redirect = (t)=>t ? {
                to: {
                    key: e138.redirect.option,
                    value: e138.redirect.value
                }
            } : void 0
        ), e138.deprecated && (u.deprecated = !0), r28 && !e138.array) {
            const e139 = i.preprocess || ((e)=>e
            );
            i.preprocess = (t, n, r)=>n.preprocess(e139(Array.isArray(t) ? Gh(t) : t), r)
            ;
        }
        return e138.array ? qh.ArraySchema.create(Object.assign(Object.assign(Object.assign({
        }, r28 ? {
            preprocess: (e)=>Array.isArray(e) ? e : [
                    e
                ]
        } : {
        }), u), {
        }, {
            valueSchema: n40.create(i)
        })) : n40.create(Object.assign(Object.assign({
        }, i), u));
    }
    var Zh = {
        normalizeApiOptions: function(e, t, n) {
            return Yh(e, t, n);
        },
        normalizeCliOptions: function(e, t, n) {
            return Yh(e, t, Object.assign({
                isCLI: !0
            }, n));
        }
    };
    const { isNonEmptyArray: eg  } = dc;
    function tg(e, t) {
        const { ignoreDecorators: n  } = t || {
        };
        if (!n) {
            const t = e.declaration && e.declaration.decorators || e.decorators;
            if (eg(t)) return tg(t[0]);
        }
        return e.range ? e.range[0] : e.start;
    }
    function ng(e) {
        return e.range ? e.range[1] : e.end;
    }
    function rg(e, t) {
        return tg(e) === tg(t);
    }
    var og = {
        locStart: tg,
        locEnd: ng,
        hasSameLocStart: rg,
        hasSameLoc: function(e141, t77) {
            return rg(e141, t77) && (function(e, t) {
                return ng(e) === ng(t);
            })(e141, t77);
        }
    }, ig = {
    }, ug = {
    }, sg = {
    };
    Object.defineProperty(sg, "__esModule", {
        value: !0
    }), sg.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, sg.matchToToken = function(e) {
        var t = {
            type: "invalid",
            value: e[0],
            closed: void 0
        };
        return e[1] ? (t.type = "string", t.closed = !(!e[3] && !e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
    };
    var ag = {
    }, cg = {
    };
    Object.defineProperty(cg, "__esModule", {
        value: !0
    }), cg.isIdentifierStart = yg, cg.isIdentifierChar = Dg, cg.isIdentifierName = function(e) {
        let t = !0;
        for(let n = 0; n < e.length; n++){
            let r = e.charCodeAt(n);
            if (55296 == (64512 & r) && n + 1 < e.length) {
                const t = e.charCodeAt(++n);
                56320 == (64512 & t) && (r = 65536 + ((1023 & r) << 10) + (1023 & t));
            }
            if (t) {
                if (t = !1, !yg(r)) return !1;
            } else if (!Dg(r)) return !1;
        }
        return !t;
    };
    let lg = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc", pg = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
    const fg = new RegExp("[" + lg + "]"), dg = new RegExp("[" + lg + pg + "]");
    lg = pg = null;
    const hg = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        13,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        2,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        68,
        310,
        10,
        21,
        11,
        7,
        25,
        5,
        2,
        41,
        2,
        8,
        70,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        43,
        17,
        47,
        20,
        28,
        22,
        13,
        52,
        58,
        1,
        3,
        0,
        14,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        38,
        6,
        186,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        19,
        72,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2637,
        96,
        16,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        18,
        78,
        18,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8936,
        3,
        2,
        6,
        2,
        1,
        2,
        290,
        46,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        1845,
        30,
        482,
        44,
        11,
        6,
        17,
        0,
        322,
        29,
        19,
        43,
        1269,
        6,
        2,
        3,
        2,
        1,
        2,
        14,
        2,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42719,
        33,
        4152,
        8,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
    ], gg = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        50,
        3,
        123,
        2,
        54,
        14,
        32,
        10,
        3,
        1,
        11,
        3,
        46,
        10,
        8,
        0,
        46,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        87,
        9,
        39,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        4706,
        45,
        3,
        22,
        543,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        357,
        0,
        62,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
    ];
    function mg(e, t) {
        let n = 65536;
        for(let r = 0, o = t.length; r < o; r += 2){
            if (n += t[r], n > e) return !1;
            if (n += t[r + 1], n >= e) return !0;
        }
        return !1;
    }
    function yg(e) {
        return e < 65 ? 36 === e : e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && fg.test(String.fromCharCode(e)) : mg(e, hg)));
    }
    function Dg(e) {
        return e < 48 ? 36 === e : e < 58 || !(e < 65) && (e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && dg.test(String.fromCharCode(e)) : mg(e, hg) || mg(e, gg))));
    }
    var Eg = {
    };
    Object.defineProperty(Eg, "__esModule", {
        value: !0
    }), Eg.isReservedWord = xg, Eg.isStrictReservedWord = Sg, Eg.isStrictBindOnlyReservedWord = wg, Eg.isStrictBindReservedWord = function(e, t) {
        return Sg(e, t) || wg(e);
    }, Eg.isKeyword = function(e) {
        return vg.has(e);
    };
    const Cg = [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ], bg = [
        "eval",
        "arguments"
    ], vg = new Set([
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ]), Ag = new Set(Cg), Fg = new Set(bg);
    function xg(e, t) {
        return t && "await" === e || "enum" === e;
    }
    function Sg(e, t) {
        return xg(e, t) || Ag.has(e);
    }
    function wg(e) {
        return Fg.has(e);
    }
    !function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), Object.defineProperty(e, "isIdentifierName", {
            enumerable: !0,
            get: function() {
                return t.isIdentifierName;
            }
        }), Object.defineProperty(e, "isIdentifierChar", {
            enumerable: !0,
            get: function() {
                return t.isIdentifierChar;
            }
        }), Object.defineProperty(e, "isIdentifierStart", {
            enumerable: !0,
            get: function() {
                return t.isIdentifierStart;
            }
        }), Object.defineProperty(e, "isReservedWord", {
            enumerable: !0,
            get: function() {
                return n.isReservedWord;
            }
        }), Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
            enumerable: !0,
            get: function() {
                return n.isStrictBindOnlyReservedWord;
            }
        }), Object.defineProperty(e, "isStrictBindReservedWord", {
            enumerable: !0,
            get: function() {
                return n.isStrictBindReservedWord;
            }
        }), Object.defineProperty(e, "isStrictReservedWord", {
            enumerable: !0,
            get: function() {
                return n.isStrictReservedWord;
            }
        }), Object.defineProperty(e, "isKeyword", {
            enumerable: !0,
            get: function() {
                return n.isKeyword;
            }
        });
        var t = cg, n = Eg;
    }(ag);
    var Tg = {
        exports: {
        }
    }, Bg = /[|\\{}()[\]^$+*?.]/g, Ng = function(e) {
        if ("string" != typeof e) throw new TypeError("Expected a string");
        return e.replace(Bg, "\\$&");
    };
    const kg = yf, Pg = (e, t)=>{
        t = t || ta.argv;
        const n = e.startsWith("-") ? "" : 1 === e.length ? "-" : "--", r = t.indexOf(n + e), o = t.indexOf("--");
        return -1 !== r && (-1 === o || r < o);
    }, Og = ta.env;
    let Ig;
    function Lg(e142) {
        const t78 = function(e143) {
            if (!1 === Ig) return 0;
            if (Pg("color=16m") || Pg("color=full") || Pg("color=truecolor")) return 3;
            if (Pg("color=256")) return 2;
            if (e143 && !e143.isTTY && !0 !== Ig) return 0;
            const t = Ig ? 1 : 0;
            if ("win32" === ta.platform) {
                const e = kg.release().split(".");
                return Number(ta.versions.node.split(".")[0]) >= 8 && Number(e[0]) >= 10 && Number(e[2]) >= 10586 ? Number(e[2]) >= 14931 ? 3 : 2 : 1;
            }
            if ("CI" in Og) return [
                "TRAVIS",
                "CIRCLECI",
                "APPVEYOR",
                "GITLAB_CI"
            ].some((e)=>e in Og
            ) || "codeship" === Og.CI_NAME ? 1 : t;
            if ("TEAMCITY_VERSION" in Og) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Og.TEAMCITY_VERSION) ? 1 : 0;
            if ("truecolor" === Og.COLORTERM) return 3;
            if ("TERM_PROGRAM" in Og) {
                const e = parseInt((Og.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
                switch(Og.TERM_PROGRAM){
                    case "iTerm.app":
                        return e >= 3 ? 3 : 2;
                    case "Apple_Terminal":
                        return 2;
                }
            }
            return /-256(color)?$/i.test(Og.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Og.TERM) || "COLORTERM" in Og ? 1 : (Og.TERM, t);
        }(e142);
        return (function(e) {
            return 0 !== e && {
                level: e,
                hasBasic: !0,
                has256: e >= 2,
                has16m: e >= 3
            };
        })(t78);
    }
    Pg("no-color") || Pg("no-colors") || Pg("color=false") ? Ig = !1 : (Pg("color") || Pg("colors") || Pg("color=true") || Pg("color=always")) && (Ig = !0), "FORCE_COLOR" in Og && (Ig = 0 === Og.FORCE_COLOR.length || 0 !== parseInt(Og.FORCE_COLOR, 10));
    var jg = {
        supportsColor: Lg,
        stdout: Lg(ta.stdout),
        stderr: Lg(ta.stderr)
    };
    const _g = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Mg = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Rg = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Vg = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, $g = new Map([
        [
            "n",
            "\n"
        ],
        [
            "r",
            "\r"
        ],
        [
            "t",
            "\t"
        ],
        [
            "b",
            "\b"
        ],
        [
            "f",
            "\f"
        ],
        [
            "v",
            "\v"
        ],
        [
            "0",
            "\0"
        ],
        [
            "\\",
            "\\"
        ],
        [
            "e",
            "\x1b"
        ],
        [
            "a",
            "\x07"
        ]
    ]);
    function Wg(e) {
        return "u" === e[0] && 5 === e.length || "x" === e[0] && 3 === e.length ? String.fromCharCode(parseInt(e.slice(1), 16)) : $g.get(e) || e;
    }
    function qg(e, t80) {
        const n41 = [], r = t80.trim().split(/\s*,\s*/g);
        let o;
        for (const t79 of r)if (isNaN(t79)) {
            if (!(o = t79.match(Rg))) throw new Error("Invalid Chalk template style argument: ".concat(t79, " (in style '").concat(e, "')"));
            n41.push(o[2].replace(Vg, (e, t, n)=>t ? Wg(t) : n
            ));
        } else n41.push(Number(t79));
        return n41;
    }
    function Ug(e) {
        Mg.lastIndex = 0;
        const t = [];
        let n;
        for(; null !== (n = Mg.exec(e));){
            const e = n[1];
            if (n[2]) {
                const r = qg(e, n[2]);
                t.push([
                    e
                ].concat(r));
            } else t.push([
                e
            ]);
        }
        return t;
    }
    function zg(e, t) {
        const n = {
        };
        for (const e144 of t)for (const t81 of e144.styles)n[t81[0]] = e144.inverse ? null : t81.slice(1);
        let r = e;
        for (const e145 of Object.keys(n))if (Array.isArray(n[e145])) {
            if (!(e145 in r)) throw new Error("Unknown Chalk style: ".concat(e145));
            r = n[e145].length > 0 ? r[e145].apply(r, n[e145]) : r[e145];
        }
        return r;
    }
    var Gg = (e, t82)=>{
        const n = [], r = [];
        let o = [];
        if (t82.replace(_g, (t, i, u, s, a, c)=>{
            if (i) o.push(Wg(i));
            else if (s) {
                const t = o.join("");
                o = [], r.push(0 === n.length ? t : zg(e, n)(t)), n.push({
                    inverse: u,
                    styles: Ug(s)
                });
            } else if (a) {
                if (0 === n.length) throw new Error("Found extraneous } in Chalk template literal");
                r.push(zg(e, n)(o.join(""))), o = [], n.pop();
            } else o.push(c);
        }), r.push(o.join("")), n.length > 0) {
            const e = "Chalk template literal is missing ".concat(n.length, " closing bracket").concat(1 === n.length ? "" : "s", " (`}`)");
            throw new Error(e);
        }
        return r.join("");
    };
    !function(e149) {
        const t83 = Ng, n42 = jp.exports, r29 = jg.stdout, o14 = Gg, i = "win32" === ta.platform && !(ta.env.TERM || "").toLowerCase().startsWith("xterm"), u = [
            "ansi",
            "ansi",
            "ansi256",
            "ansi16m"
        ], s = new Set([
            "gray"
        ]), a = Object.create(null);
        function c(e, t) {
            t = t || {
            };
            const n = r29 ? r29.level : 0;
            e.level = void 0 === t.level ? n : t.level, e.enabled = "enabled" in t ? t.enabled : e.level > 0;
        }
        function l(e150) {
            if (!this || !(this instanceof l) || this.template) {
                const t = {
                };
                return c(t, e150), t.template = function() {
                    const e = [].slice.call(arguments);
                    return h.apply(null, [
                        t.template
                    ].concat(e));
                }, Object.setPrototypeOf(t, l.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = l, t.template;
            }
            c(this, e150);
        }
        i && (n42.blue.open = "\x1b[94m");
        for (const e146 of Object.keys(n42))n42[e146].closeRe = new RegExp(t83(n42[e146].close), "g"), a[e146] = {
            get () {
                const t = n42[e146];
                return f.call(this, this._styles ? this._styles.concat(t) : [
                    t
                ], this._empty, e146);
            }
        };
        a.visible = {
            get () {
                return f.call(this, this._styles || [], !0, "visible");
            }
        }, n42.color.closeRe = new RegExp(t83(n42.color.close), "g");
        for (const e147 of Object.keys(n42.color.ansi))s.has(e147) || (a[e147] = {
            get () {
                const t = this.level;
                return function() {
                    const r = n42.color[u[t]][e147].apply(null, arguments), o = {
                        open: r,
                        close: n42.color.close,
                        closeRe: n42.color.closeRe
                    };
                    return f.call(this, this._styles ? this._styles.concat(o) : [
                        o
                    ], this._empty, e147);
                };
            }
        });
        n42.bgColor.closeRe = new RegExp(t83(n42.bgColor.close), "g");
        for (const e148 of Object.keys(n42.bgColor.ansi)){
            if (s.has(e148)) continue;
            a["bg" + e148[0].toUpperCase() + e148.slice(1)] = {
                get () {
                    const t = this.level;
                    return function() {
                        const r = n42.bgColor[u[t]][e148].apply(null, arguments), o = {
                            open: r,
                            close: n42.bgColor.close,
                            closeRe: n42.bgColor.closeRe
                        };
                        return f.call(this, this._styles ? this._styles.concat(o) : [
                            o
                        ], this._empty, e148);
                    };
                }
            };
        }
        const p = Object.defineProperties(()=>{
        }, a);
        function f(e151, t, n) {
            const r = function() {
                return d.apply(r, arguments);
            };
            r._styles = e151, r._empty = t;
            const o = this;
            return Object.defineProperty(r, "level", {
                enumerable: !0,
                get: ()=>o.level
                ,
                set (e) {
                    o.level = e;
                }
            }), Object.defineProperty(r, "enabled", {
                enumerable: !0,
                get: ()=>o.enabled
                ,
                set (e) {
                    o.enabled = e;
                }
            }), r.hasGrey = this.hasGrey || "gray" === n || "grey" === n, r.__proto__ = p, r;
        }
        function d() {
            const e = arguments, t = e.length;
            let r = String(arguments[0]);
            if (0 === t) return "";
            if (t > 1) for(let n = 1; n < t; n++)r += " " + e[n];
            if (!this.enabled || this.level <= 0 || !r) return this._empty ? "" : r;
            const o = n42.dim.open;
            i && this.hasGrey && (n42.dim.open = "");
            for (const e152 of this._styles.slice().reverse())r = e152.open + r.replace(e152.closeRe, e152.open) + e152.close, r = r.replace(/\r?\n/g, "".concat(e152.close, "$&").concat(e152.open));
            return n42.dim.open = o, r;
        }
        function h(e, t) {
            if (!Array.isArray(t)) return [].slice.call(arguments, 1).join(" ");
            const n = [].slice.call(arguments, 2), r = [
                t.raw[0]
            ];
            for(let e153 = 1; e153 < t.length; e153++)r.push(String(n[e153 - 1]).replace(/[{}\\]/g, "\\$&")), r.push(String(t.raw[e153]));
            return o14(e, r.join(""));
        }
        Object.defineProperties(l.prototype, a), e149.exports = l(), e149.exports.supportsColor = r29, e149.exports.default = e149.exports;
    }(Tg), Object.defineProperty(ug, "__esModule", {
        value: !0
    }), ug.default = function(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
        };
        if (nm(t)) {
            const n = rm(t);
            return tm(Kg(n), e);
        }
        return e;
    }, ug.getChalk = rm, ug.shouldHighlight = nm;
    var Hg = sg, Jg = ag, Xg = Tg.exports;
    const Yg = new Set([
        "as",
        "async",
        "from",
        "get",
        "of",
        "set"
    ]);
    function Kg(e) {
        return {
            keyword: e.cyan,
            capitalized: e.yellow,
            jsxIdentifier: e.yellow,
            punctuator: e.yellow,
            number: e.magenta,
            string: e.green,
            regex: e.magenta,
            comment: e.grey,
            invalid: e.white.bgRed.bold
        };
    }
    const Qg = /\r\n|[\n\r\u2028\u2029]/, Zg = /^[()[\]{}]$/;
    let em;
    {
        const e154 = /^[a-z][\w-]*$/i, t84 = function(t, n, r) {
            if ("name" === t.type) {
                if ((0, Jg.isKeyword)(t.value) || (0, Jg.isStrictReservedWord)(t.value, !0) || Yg.has(t.value)) return "keyword";
                if (e154.test(t.value) && ("<" === r[n - 1] || "</" == r.substr(n - 2, 2))) return "jsxIdentifier";
                if (t.value[0] !== t.value[0].toLowerCase()) return "capitalized";
            }
            return "punctuator" === t.type && Zg.test(t.value) ? "bracket" : "invalid" !== t.type || "@" !== t.value && "#" !== t.value ? t.type : "punctuator";
        };
        em = function*(e) {
            let n;
            for(; n = Hg.default.exec(e);){
                const r = Hg.matchToToken(n);
                yield {
                    type: t84(r, n.index, e),
                    value: r.value
                };
            }
        };
    }
    function tm(e156, t) {
        let n = "";
        for (const { type: r , value: o  } of em(t)){
            const t = e156[r];
            n += t ? o.split(Qg).map((e)=>t(e)
            ).join("\n") : o;
        }
        return n;
    }
    function nm(e) {
        return !!Xg.supportsColor || e.forceColor;
    }
    function rm(e) {
        return e.forceColor ? new Xg.constructor({
            enabled: !0,
            level: 1
        }) : Xg;
    }
    Object.defineProperty(ig, "__esModule", {
        value: !0
    }), ig.codeFrameColumns = cm, ig.default = function(e, t, n) {
        let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
        };
        if (!im) {
            im = !0;
            const e = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
            if (ta.emitWarning) ta.emitWarning(e, "DeprecationWarning");
            else new Error(e).name = "DeprecationWarning", console.warn(new Error(e));
        }
        const o = {
            start: {
                column: n = Math.max(n, 0),
                line: t
            }
        };
        return cm(e, o, r);
    };
    var om = ug;
    let im = !1;
    function um(e) {
        return {
            gutter: e.grey,
            marker: e.red.bold,
            message: e.red.bold
        };
    }
    const sm = /\r\n|[\n\r\u2028\u2029]/;
    function am(e, t, n) {
        const r = Object.assign({
            column: 0,
            line: -1
        }, e.start), o = Object.assign({
        }, r, e.end), { linesAbove: i = 2 , linesBelow: u = 3  } = n || {
        }, s = r.line, a = r.column, c = o.line, l = o.column;
        let p = Math.max(s - (i + 1), 0), f = Math.min(t.length, c + u);
        -1 === s && (p = 0), -1 === c && (f = t.length);
        const d = c - s, h = {
        };
        if (d) for(let e157 = 0; e157 <= d; e157++){
            const n = e157 + s;
            if (a) {
                if (0 === e157) {
                    const e = t[n - 1].length;
                    h[n] = [
                        a,
                        e - a + 1
                    ];
                } else if (e157 === d) h[n] = [
                    0,
                    l
                ];
                else {
                    const r = t[n - e157].length;
                    h[n] = [
                        0,
                        r
                    ];
                }
            } else h[n] = !0;
        }
        else h[s] = a === l ? !a || [
            a,
            0
        ] : [
            a,
            l - a
        ];
        return {
            start: p,
            end: f,
            markerLines: h
        };
    }
    function cm(e158, t86) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
        };
        const r30 = (n.highlightCode || n.forceColor) && (0, om.shouldHighlight)(n), o15 = (0, om.getChalk)(n), i = um(o15), u = (e, t)=>r30 ? e(t) : t
        , s6 = e158.split(sm), { start: a , end: c3 , markerLines: l  } = am(t86, s6, n), p4 = t86.start && "number" == typeof t86.start.column, f = String(c3).length, d = r30 ? (0, om.default)(e158, n) : e158;
        let h = d.split(sm, c3).slice(a, c3).map((e, t)=>{
            const r = a + 1 + t, o = " ".concat(r).slice(-f), s = " ".concat(o, " |"), c = l[r], p = !l[r + 1];
            if (c) {
                let t = "";
                if (Array.isArray(c)) {
                    const r = e.slice(0, Math.max(c[0] - 1, 0)).replace(/[^\t]/g, " "), o = c[1] || 1;
                    t = [
                        "\n ",
                        u(i.gutter, s.replace(/\d/g, " ")),
                        " ",
                        r,
                        u(i.marker, "^").repeat(o)
                    ].join(""), p && n.message && (t += " " + u(i.message, n.message));
                }
                return [
                    u(i.marker, ">"),
                    u(i.gutter, s),
                    e.length > 0 ? " ".concat(e) : "",
                    t
                ].join("");
            }
            return " ".concat(u(i.gutter, s)).concat(e.length > 0 ? " ".concat(e) : "");
        }).join("\n");
        return n.message && !p4 && (h = "".concat(" ".repeat(f + 1)).concat(n.message, "\n").concat(h)), r30 ? o15.reset(h) : h;
    }
    const { ConfigError: lm  } = Cp, pm = og, { locStart: fm , locEnd: dm  } = pm, hm = Object.getOwnPropertyNames, gm = Object.getOwnPropertyDescriptor;
    function mm(e) {
        const t = {
        };
        for (const n of e.plugins)if (n.parsers) for (const e159 of hm(n.parsers))Object.defineProperty(t, e159, gm(n.parsers, e159));
        return t;
    }
    function ym(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : mm(e);
        if ("function" == typeof e.parser) return {
            parse: e.parser,
            astFormat: "estree",
            locStart: fm,
            locEnd: dm
        };
        if ("string" == typeof e.parser) {
            if (Object.prototype.hasOwnProperty.call(t, e.parser)) return t[e.parser];
            throw new lm("Couldn't resolve parser \"".concat(e.parser, '". Parsers must be explicitly added to the standalone bundle.'));
        }
    }
    var Dm = {
        parse: function(e160, t) {
            const n = mm(t), r = Object.defineProperties({
            }, Object.fromEntries(Object.keys(n).map((e)=>[
                    e,
                    {
                        enumerable: !0,
                        get: ()=>n[e].parse
                    }
                ]
            ))), o = ym(t, n);
            try {
                return o.preprocess && (e160 = o.preprocess(e160, t)), {
                    text: e160,
                    ast: o.parse(e160, r, t)
                };
            } catch (t87) {
                const { loc: n  } = t87;
                if (n) {
                    const { codeFrameColumns: r  } = ig;
                    throw t87.codeFrame = r(e160, n, {
                        highlightCode: !0
                    }), t87.message += "\n" + t87.codeFrame, t87;
                }
                throw t87.stack;
            }
        },
        resolveParser: ym
    };
    const Em = el, Cm = gl, bm = gp, { UndefinedParserError: vm  } = Cp, { getSupportInfo: Am  } = za, Fm = Zh, { resolveParser: xm  } = Dm, Sm = {
        astFormat: "estree",
        printer: {
        },
        originalText: void 0,
        locStart: null,
        locEnd: null
    };
    function wm(e161) {
        const { astFormat: t  } = e161;
        if (!t) throw new Error("getPlugin() requires astFormat to be set");
        const n = e161.plugins.find((e)=>e.printers && e.printers[t]
        );
        if (!n) throw new Error("Couldn't find plugin for AST format \"".concat(t, '"'));
        return n;
    }
    function Tm(e162, t89) {
        const n43 = Cm.basename(e162).toLowerCase(), r31 = Am({
            plugins: t89
        }).languages.filter((e)=>null !== e.since
        );
        let o = r31.find((e163)=>e163.extensions && e163.extensions.some((e)=>n43.endsWith(e)
            ) || e163.filenames && e163.filenames.some((e)=>e.toLowerCase() === n43
            )
        );
        if (!o && !n43.includes(".")) {
            const t88 = function(e) {
                if ("string" != typeof e) return "";
                let t;
                try {
                    t = Em.openSync(e, "r");
                } catch  {
                    return "";
                }
                try {
                    const e = new bm(t).next().toString("utf8"), n = e.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
                    if (n) return n[1];
                    const r = e.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
                    return r ? r[1] : "";
                } catch  {
                    return "";
                } finally{
                    try {
                        Em.closeSync(t);
                    } catch  {
                    }
                }
            }(e162);
            o = r31.find((e)=>e.interpreters && e.interpreters.includes(t88)
            );
        }
        return o && o.parsers[0];
    }
    var Bm = {
        normalize: function(e165) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
            };
            const n = Object.assign({
            }, e165), r = Am({
                plugins: e165.plugins,
                showUnreleased: !0,
                showDeprecated: !0
            }).options, o = Object.assign(Object.assign({
            }, Sm), Object.fromEntries(r.filter((e)=>void 0 !== e.default
            ).map((e)=>[
                    e.name,
                    e.default
                ]
            )));
            if (!n.parser) {
                if (n.filepath) {
                    if (n.parser = Tm(n.filepath, n.plugins), !n.parser) throw new vm("No parser could be inferred for file: ".concat(n.filepath));
                } else (t.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n.parser = "babel";
            }
            const i = xm(Fm.normalizeApiOptions(n, [
                r.find((e)=>"parser" === e.name
                )
            ], {
                passThrough: !0,
                logger: !1
            }));
            n.astFormat = i.astFormat, n.locEnd = i.locEnd, n.locStart = i.locStart;
            const u = wm(n);
            n.printer = u.printers[n.astFormat];
            const s = Object.fromEntries(r.filter((e)=>e.pluginDefaults && void 0 !== e.pluginDefaults[u.name]
            ).map((e)=>[
                    e.name,
                    e.pluginDefaults[u.name]
                ]
            )), a = Object.assign(Object.assign({
            }, o), s);
            for (const [e164, t90] of Object.entries(a))null !== n[e164] && void 0 !== n[e164] || (n[e164] = t90);
            return "json" === n.parser && (n.trailingComma = "none"), Fm.normalizeApiOptions(n, r, Object.assign({
                passThrough: Object.keys(Sm)
            }, t));
        },
        hiddenDefaults: Sm,
        inferParser: Tm
    };
    var Nm = function e(t91, n, r) {
        if (Array.isArray(t91)) return t91.map((t)=>e(t, n, r)
        ).filter(Boolean);
        if (!t91 || "object" != typeof t91) return t91;
        const o = n.printer.massageAstNode;
        let i;
        i = o && o.ignoredProperties ? o.ignoredProperties : new Set;
        const u = {
        };
        for (const [r32, o16] of Object.entries(t91))i.has(r32) || "function" == typeof o16 || (u[r32] = e(o16, n, t91));
        if (o) {
            const e = o(t91, u, r);
            if (null === e) return;
            if (e) return e;
        }
        return u;
    }, km = "function" == typeof Object.create ? function(e, t) {
        e.super_ = t, e.prototype = Object.create(t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        });
    } : function(e, t) {
        e.super_ = t;
        var n = function() {
        };
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
    };
    function Pm(e, t) {
        var n = {
            seen: [],
            stylize: Im
        };
        return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), Mm(t) ? n.showHidden = t : t && Xm(n, t), $m(n.showHidden) && (n.showHidden = !1), $m(n.depth) && (n.depth = 2), $m(n.colors) && (n.colors = !1), $m(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = Om), Lm(n, e, n.depth);
    }
    function Om(e, t) {
        var n = Pm.styles[t];
        return n ? "\x1b[" + Pm.colors[n][0] + "m" + e + "\x1b[" + Pm.colors[n][1] + "m" : e;
    }
    function Im(e, t) {
        return e;
    }
    function Lm(e166, t92, n44) {
        if (e166.customInspect && t92 && Gm(t92.inspect) && t92.inspect !== Pm && (!t92.constructor || t92.constructor.prototype !== t92)) {
            var r = t92.inspect(n44, e166);
            return Vm(r) || (r = Lm(e166, r, n44)), r;
        }
        var o17 = function(e, t) {
            if ($m(t)) return e.stylize("undefined", "undefined");
            if (Vm(t)) {
                var n = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return e.stylize(n, "string");
            }
            if (r = t, "number" == typeof r) return e.stylize("" + t, "number");
            var r;
            if (Mm(t)) return e.stylize("" + t, "boolean");
            if (Rm(t)) return e.stylize("null", "null");
        }(e166, t92);
        if (o17) return o17;
        var i11 = Object.keys(t92), u9 = function(e) {
            var t = {
            };
            return e.forEach(function(e, n) {
                t[e] = !0;
            }), t;
        }(i11);
        if (e166.showHidden && (i11 = Object.getOwnPropertyNames(t92)), zm(t92) && (i11.indexOf("message") >= 0 || i11.indexOf("description") >= 0)) return jm(t92);
        if (0 === i11.length) {
            if (Gm(t92)) {
                var s = t92.name ? ": " + t92.name : "";
                return e166.stylize("[Function" + s + "]", "special");
            }
            if (Wm(t92)) return e166.stylize(RegExp.prototype.toString.call(t92), "regexp");
            if (Um(t92)) return e166.stylize(Date.prototype.toString.call(t92), "date");
            if (zm(t92)) return jm(t92);
        }
        var a, c, l = "", p = !1, f = [
            "{",
            "}"
        ];
        (a = t92, Array.isArray(a) && (p = !0, f = [
            "[",
            "]"
        ]), Gm(t92)) && (l = " [Function" + (t92.name ? ": " + t92.name : "") + "]");
        return Wm(t92) && (l = " " + RegExp.prototype.toString.call(t92)), Um(t92) && (l = " " + Date.prototype.toUTCString.call(t92)), zm(t92) && (l = " " + jm(t92)), 0 !== i11.length || p && 0 != t92.length ? n44 < 0 ? Wm(t92) ? e166.stylize(RegExp.prototype.toString.call(t92), "regexp") : e166.stylize("[Object]", "special") : (e166.seen.push(t92), c = p ? (function(e, t, n, r, o18) {
            for(var i = [], u = 0, s = t.length; u < s; ++u)Ym(t, String(u)) ? i.push(_m(e, t, n, r, String(u), !0)) : i.push("");
            return o18.forEach(function(o) {
                o.match(/^\d+$/) || i.push(_m(e, t, n, r, o, !0));
            }), i;
        })(e166, t92, n44, u9, i11) : i11.map(function(r) {
            return _m(e166, t92, n44, u9, r, p);
        }), e166.seen.pop(), (function(e167, t93, n) {
            if (e167.reduce(function(e, t) {
                return t.indexOf("\n"), e + t.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60) return n[0] + ("" === t93 ? "" : t93 + "\n ") + " " + e167.join(",\n  ") + " " + n[1];
            return n[0] + t93 + " " + e167.join(", ") + " " + n[1];
        })(c, l, f)) : f[0] + l + f[1];
    }
    function jm(e) {
        return "[" + Error.prototype.toString.call(e) + "]";
    }
    function _m(e168, t, n, r, o, i) {
        var u, s, a;
        if ((a = Object.getOwnPropertyDescriptor(t, o) || {
            value: t[o]
        }).get ? s = a.set ? e168.stylize("[Getter/Setter]", "special") : e168.stylize("[Getter]", "special") : a.set && (s = e168.stylize("[Setter]", "special")), Ym(r, o) || (u = "[" + o + "]"), s || (e168.seen.indexOf(a.value) < 0 ? (s = Rm(n) ? Lm(e168, a.value, null) : Lm(e168, a.value, n - 1)).indexOf("\n") > -1 && (s = i ? s.split("\n").map(function(e) {
            return "  " + e;
        }).join("\n").substr(2) : "\n" + s.split("\n").map(function(e) {
            return "   " + e;
        }).join("\n")) : s = e168.stylize("[Circular]", "special")), $m(u)) {
            if (i && o.match(/^\d+$/)) return s;
            (u = JSON.stringify("" + o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u = u.substr(1, u.length - 2), u = e168.stylize(u, "name")) : (u = u.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u = e168.stylize(u, "string"));
        }
        return u + ": " + s;
    }
    function Mm(e) {
        return "boolean" == typeof e;
    }
    function Rm(e) {
        return null === e;
    }
    function Vm(e) {
        return "string" == typeof e;
    }
    function $m(e) {
        return void 0 === e;
    }
    function Wm(e) {
        return qm(e) && "[object RegExp]" === Jm(e);
    }
    function qm(e) {
        return "object" == typeof e && null !== e;
    }
    function Um(e) {
        return qm(e) && "[object Date]" === Jm(e);
    }
    function zm(e) {
        return qm(e) && ("[object Error]" === Jm(e) || e instanceof Error);
    }
    function Gm(e) {
        return "function" == typeof e;
    }
    function Hm(e) {
        return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e;
    }
    function Jm(e) {
        return Object.prototype.toString.call(e);
    }
    function Xm(e, t) {
        if (!t || !qm(t)) return e;
        for(var n = Object.keys(t), r = n.length; r--;)e[n[r]] = t[n[r]];
        return e;
    }
    function Ym(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
    }
    function Km(e, t) {
        if (e === t) return 0;
        for(var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o)if (e[o] !== t[o]) {
            n = e[o], r = t[o];
            break;
        }
        return n < r ? -1 : r < n ? 1 : 0;
    }
    Pm.colors = {
        bold: [
            1,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        inverse: [
            7,
            27
        ],
        white: [
            37,
            39
        ],
        grey: [
            90,
            39
        ],
        black: [
            30,
            39
        ],
        blue: [
            34,
            39
        ],
        cyan: [
            36,
            39
        ],
        green: [
            32,
            39
        ],
        magenta: [
            35,
            39
        ],
        red: [
            31,
            39
        ],
        yellow: [
            33,
            39
        ]
    }, Pm.styles = {
        special: "cyan",
        number: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        date: "magenta",
        regexp: "red"
    };
    var Qm, Zm = Object.prototype.hasOwnProperty, ey = Object.keys || function(e) {
        var t = [];
        for(var n in e)Zm.call(e, n) && t.push(n);
        return t;
    }, ty = Array.prototype.slice;
    function ny() {
        return void 0 !== Qm ? Qm : Qm = "foo" === (function() {
        }).name;
    }
    function ry(e) {
        return Object.prototype.toString.call(e);
    }
    function oy(e) {
        return !fp(e) && "function" == typeof Ns.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : !!e && (e instanceof DataView || !!(e.buffer && e.buffer instanceof ArrayBuffer)));
    }
    function iy(e, t) {
        e || py(e, !0, t, "==", fy);
    }
    var uy = /\s*function\s+([^\(\s]*)\s*/;
    function sy(e) {
        if (Gm(e)) {
            if (ny()) return e.name;
            var t = e.toString().match(uy);
            return t && t[1];
        }
    }
    function ay(e169) {
        this.name = "AssertionError", this.actual = e169.actual, this.expected = e169.expected, this.operator = e169.operator, e169.message ? (this.message = e169.message, this.generatedMessage = !1) : (this.message = (function(e) {
            return cy(ly(e.actual), 128) + " " + e.operator + " " + cy(ly(e.expected), 128);
        })(this), this.generatedMessage = !0);
        var t = e169.stackStartFunction || py;
        if (Error.captureStackTrace) Error.captureStackTrace(this, t);
        else {
            var n = new Error;
            if (n.stack) {
                var r = n.stack, o = sy(t), i = r.indexOf("\n" + o);
                if (i >= 0) {
                    var u = r.indexOf("\n", i + 1);
                    r = r.substring(u + 1);
                }
                this.stack = r;
            }
        }
    }
    function cy(e, t) {
        return "string" == typeof e ? e.length < t ? e : e.slice(0, t) : e;
    }
    function ly(e) {
        if (ny() || !Gm(e)) return Pm(e);
        var t = sy(e);
        return "[Function" + (t ? ": " + t : "") + "]";
    }
    function py(e, t, n, r, o) {
        throw new ay({
            message: n,
            actual: e,
            expected: t,
            operator: r,
            stackStartFunction: o
        });
    }
    function fy(e, t) {
        e || py(e, !0, t, "==", fy);
    }
    function dy(e, t, n) {
        e != t && py(e, t, n, "==", dy);
    }
    function hy(e, t, n) {
        e == t && py(e, t, n, "!=", hy);
    }
    function gy(e, t, n) {
        yy(e, t, !1) || py(e, t, n, "deepEqual", gy);
    }
    function my(e, t, n) {
        yy(e, t, !0) || py(e, t, n, "deepStrictEqual", my);
    }
    function yy(e170, t94, n45, r33) {
        if (e170 === t94) return !0;
        if (fp(e170) && fp(t94)) return 0 === Km(e170, t94);
        if (Um(e170) && Um(t94)) return e170.getTime() === t94.getTime();
        if (Wm(e170) && Wm(t94)) return e170.source === t94.source && e170.global === t94.global && e170.multiline === t94.multiline && e170.lastIndex === t94.lastIndex && e170.ignoreCase === t94.ignoreCase;
        if (null !== e170 && "object" == typeof e170 || null !== t94 && "object" == typeof t94) {
            if (oy(e170) && oy(t94) && ry(e170) === ry(t94) && !(e170 instanceof Float32Array || e170 instanceof Float64Array)) return 0 === Km(new Uint8Array(e170.buffer), new Uint8Array(t94.buffer));
            if (fp(e170) !== fp(t94)) return !1;
            var o19 = (r33 = r33 || {
                actual: [],
                expected: []
            }).actual.indexOf(e170);
            return -1 !== o19 && o19 === r33.expected.indexOf(t94) || (r33.actual.push(e170), r33.expected.push(t94), (function(e, t, n, r) {
                if (null == e || null == t) return !1;
                if (Hm(e) || Hm(t)) return e === t;
                if (n && Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1;
                var o = Dy(e), i = Dy(t);
                if (o && !i || !o && i) return !1;
                if (o) return yy(e = ty.call(e), t = ty.call(t), n);
                var u, s, a = ey(e), c = ey(t);
                if (a.length !== c.length) return !1;
                for(a.sort(), c.sort(), s = a.length - 1; s >= 0; s--)if (a[s] !== c[s]) return !1;
                for(s = a.length - 1; s >= 0; s--)if (!yy(e[u = a[s]], t[u], n, r)) return !1;
                return !0;
            })(e170, t94, n45, r33));
        }
        return n45 ? e170 === t94 : e170 == t94;
    }
    function Dy(e) {
        return "[object Arguments]" == Object.prototype.toString.call(e);
    }
    function Ey(e, t, n) {
        yy(e, t, !1) && py(e, t, n, "notDeepEqual", Ey);
    }
    function Cy(e, t, n) {
        yy(e, t, !0) && py(e, t, n, "notDeepStrictEqual", Cy);
    }
    function by(e, t, n) {
        e !== t && py(e, t, n, "===", by);
    }
    function vy(e, t, n) {
        e === t && py(e, t, n, "!==", vy);
    }
    function Ay(e, t) {
        if (!e || !t) return !1;
        if ("[object RegExp]" == Object.prototype.toString.call(t)) return t.test(e);
        try {
            if (e instanceof t) return !0;
        } catch (e171) {
        }
        return !Error.isPrototypeOf(t) && !0 === t.call({
        }, e);
    }
    function Fy(e172, t95, n, r) {
        var o;
        if ("function" != typeof t95) throw new TypeError('"block" argument must be a function');
        "string" == typeof n && (r = n, n = null), o = (function(e) {
            var t;
            try {
                e();
            } catch (e173) {
                t = e173;
            }
            return t;
        })(t95), r = (n && n.name ? " (" + n.name + ")." : ".") + (r ? " " + r : "."), e172 && !o && py(o, n, "Missing expected exception" + r);
        var i = "string" == typeof r, u = !e172 && o && !n;
        if ((!e172 && zm(o) && i && Ay(o, n) || u) && py(o, n, "Got unwanted exception" + r), e172 && o && n && !Ay(o, n) || !e172 && o) throw o;
    }
    function xy(e, t, n) {
        Fy(!0, e, t, n);
    }
    function Sy(e, t, n) {
        Fy(!1, e, t, n);
    }
    function wy(e) {
        if (e) throw e;
    }
    iy.AssertionError = ay, km(ay, Error), iy.fail = py, iy.ok = fy, iy.equal = dy, iy.notEqual = hy, iy.deepEqual = gy, iy.deepStrictEqual = my, iy.notDeepEqual = Ey, iy.notDeepStrictEqual = Cy, iy.strictEqual = by, iy.notStrictEqual = vy, iy.throws = xy, iy.doesNotThrow = Sy, iy.ifError = wy;
    var Ty = t3(Object.freeze({
        __proto__: null,
        default: iy,
        AssertionError: ay,
        fail: py,
        ok: fy,
        assert: fy,
        equal: dy,
        notEqual: hy,
        deepEqual: gy,
        deepStrictEqual: my,
        notDeepEqual: Ey,
        notDeepStrictEqual: Cy,
        strictEqual: by,
        notStrictEqual: vy,
        throws: xy,
        doesNotThrow: Sy,
        ifError: wy
    }));
    const By = Ty, { builders: { line: Ny , hardline: ky , breakParent: Py , indent: Oy , lineSuffix: Iy , join: Ly , cursor: jy  }  } = Zc, { hasNewline: _y , skipNewline: My , skipSpaces: Ry , isPreviousLineEmpty: Vy , addLeadingComment: $y , addDanglingComment: Wy , addTrailingComment: qy  } = dc, Uy = new WeakMap;
    function zy(e174, t96, n) {
        if (!e174) return;
        const { printer: r , locStart: o , locEnd: i  } = t96;
        if (n) {
            if (r.canAttachComment && r.canAttachComment(e174)) {
                let t;
                for(t = n.length - 1; t >= 0 && !(o(n[t]) <= o(e174) && i(n[t]) <= i(e174)); --t);
                return void n.splice(t + 1, 0, e174);
            }
        } else if (Uy.has(e174)) return Uy.get(e174);
        const u = r.getCommentChildNodes && r.getCommentChildNodes(e174, t96) || "object" == typeof e174 && Object.entries(e174).filter((e)=>{
            let [t] = e;
            return "enclosingNode" !== t && "precedingNode" !== t && "followingNode" !== t && "tokens" !== t && "comments" !== t;
        }).map((e)=>{
            let [, t] = e;
            return t;
        });
        if (u) {
            n || (n = [], Uy.set(e174, n));
            for (const e of u)zy(e, t96, n);
            return n;
        }
    }
    function Gy(e, t, n, r) {
        const { locStart: o , locEnd: i  } = n, u = o(t), s = i(t), a = zy(e, n);
        let c, l, p = 0, f = a.length;
        for(; p < f;){
            const e = p + f >> 1, r = a[e], d = o(r), h = i(r);
            if (d <= u && s <= h) return Gy(r, t, n, r);
            if (h <= u) c = r, p = e + 1;
            else {
                if (!(s <= d)) throw new Error("Comment location overlaps with node location");
                l = r, f = e;
            }
        }
        if (r && "TemplateLiteral" === r.type) {
            const { quasis: e  } = r, o = Zy(e, t, n);
            c && Zy(e, c, n) !== o && (c = null), l && Zy(e, l, n) !== o && (l = null);
        }
        return {
            enclosingNode: r,
            precedingNode: c,
            followingNode: l
        };
    }
    const Hy = ()=>!1
    ;
    const Jy = (e)=>!/[\S\n\u2028\u2029]/.test(e)
    ;
    function Xy(e, t, n, r) {
        const { comment: o , precedingNode: i  } = n[r], { locStart: u , locEnd: s  } = t;
        let a = u(o);
        if (i) for(let t97 = r - 1; t97 >= 0; t97--){
            const { comment: r , precedingNode: o  } = n[t97];
            if (o !== i || !Jy(e.slice(s(r), a))) break;
            a = u(r);
        }
        return _y(e, a, {
            backwards: !0
        });
    }
    function Yy(e, t, n, r) {
        const { comment: o , followingNode: i  } = n[r], { locStart: u , locEnd: s  } = t;
        let a = s(o);
        if (i) for(let t98 = r + 1; t98 < n.length; t98++){
            const { comment: r , followingNode: o  } = n[t98];
            if (o !== i || !Jy(e.slice(a, u(r)))) break;
            a = s(r);
        }
        return _y(e, a);
    }
    function Ky(e176, t100, n) {
        const r = e176.length;
        if (0 === r) return;
        const { precedingNode: o , followingNode: i , enclosingNode: u  } = e176[0], s = n.printer.getGapRegex && n.printer.getGapRegex(u) || /^[\s(]*$/;
        let a, c = n.locStart(i);
        for(a = r; a > 0; --a){
            const { comment: r , precedingNode: u , followingNode: l  } = e176[a - 1];
            By.strictEqual(u, o), By.strictEqual(l, i);
            const p = t100.slice(n.locEnd(r), c);
            if (!s.test(p)) break;
            c = n.locStart(r);
        }
        for (const [t99, { comment: n46  }] of e176.entries())t99 < a ? qy(o, n46) : $y(i, n46);
        for (const e175 of [
            o,
            i
        ])e175.comments && e175.comments.length > 1 && e175.comments.sort((e, t)=>n.locStart(e) - n.locStart(t)
        );
        e176.length = 0;
    }
    function Qy(e, t) {
        return e.getValue().printed = !0, t.printer.printComment(e, t);
    }
    function Zy(e, t, n) {
        const r = n.locStart(t) - 1;
        for(let t101 = 1; t101 < e.length; ++t101)if (r < n.locStart(e[t101])) return t101 - 1;
        return 0;
    }
    function eD(e177, t102, n47) {
        const r34 = e177.getValue();
        if (!r34) return {
        };
        let o21 = r34.comments || [];
        n47 && (o21 = o21.filter((e)=>!n47.has(e)
        ));
        const i12 = r34 === t102.cursorNode;
        if (0 === o21.length) {
            const e = i12 ? jy : "";
            return {
                leading: e,
                trailing: e
            };
        }
        const u10 = [], s7 = [];
        return e177.each(()=>{
            const r35 = e177.getValue();
            if (n47 && n47.has(r35)) return;
            const { leading: o22 , trailing: i13  } = r35;
            o22 ? u10.push(function(e, t) {
                const n = e.getValue(), r = [
                    Qy(e, t)
                ], { printer: o , originalText: i , locStart: u , locEnd: s  } = t;
                if (o.isBlockComment && o.isBlockComment(n)) {
                    const e = _y(i, s(n)) ? _y(i, u(n), {
                        backwards: !0
                    }) ? ky : Ny : " ";
                    r.push(e);
                } else r.push(ky);
                const a = My(i, Ry(i, s(n)));
                return !1 !== a && _y(i, a) && r.push(ky), r;
            }(e177, t102)) : i13 && s7.push(function(e, t) {
                const n = e.getValue(), r = Qy(e, t), { printer: o , originalText: i , locStart: u  } = t, s = o.isBlockComment && o.isBlockComment(n);
                if (_y(i, u(n), {
                    backwards: !0
                })) {
                    const e = Vy(i, n, u);
                    return Iy([
                        ky,
                        e ? ky : "",
                        r
                    ]);
                }
                let a = [
                    " ",
                    r
                ];
                return s || (a = [
                    Iy(a),
                    Py
                ]), a;
            }(e177, t102));
        }, "comments"), i12 && (u10.unshift(jy), s7.push(jy)), {
            leading: u10,
            trailing: s7
        };
    }
    var tD = {
        attach: function(e, t, n, r) {
            if (!Array.isArray(e)) return;
            const o23 = [], { locStart: i14 , locEnd: u , printer: { handleComments: s = {
            }  }  } = r, { avoidAstMutation: a , ownLine: c = Hy , endOfLine: l = Hy , remaining: p = Hy  } = s, f = e.map((o, i)=>Object.assign(Object.assign({
                }, Gy(t, o, r)), {
                }, {
                    comment: o,
                    text: n,
                    options: r,
                    ast: t,
                    isLastComment: e.length - 1 === i
                })
            );
            for (const [e178, t103] of f.entries()){
                const { comment: n , precedingNode: r , enclosingNode: s , followingNode: d , text: h , options: g , ast: m , isLastComment: y  } = t103;
                if ("json" === g.parser || "json5" === g.parser || "__js_expression" === g.parser || "__vue_expression" === g.parser) {
                    if (i14(n) - i14(m) <= 0) {
                        $y(m, n);
                        continue;
                    }
                    if (u(n) - u(m) >= 0) {
                        qy(m, n);
                        continue;
                    }
                }
                let D;
                if (a ? D = [
                    t103
                ] : (n.enclosingNode = s, n.precedingNode = r, n.followingNode = d, D = [
                    n,
                    h,
                    g,
                    m,
                    y
                ]), Xy(h, g, f, e178)) n.placement = "ownLine", c(...D) || (d ? $y(d, n) : r ? qy(r, n) : Wy(s || m, n));
                else if (Yy(h, g, f, e178)) n.placement = "endOfLine", l(...D) || (r ? qy(r, n) : d ? $y(d, n) : Wy(s || m, n));
                else if (n.placement = "remaining", p(...D)) ;
                else if (r && d) {
                    const e = o23.length;
                    if (e > 0) o23[e - 1].followingNode !== d && Ky(o23, h, g);
                    o23.push(t103);
                } else r ? qy(r, n) : d ? $y(d, n) : Wy(s || m, n);
            }
            if (Ky(o23, n, r), !a) for (const t104 of e)delete t104.precedingNode, delete t104.enclosingNode, delete t104.followingNode;
        },
        printComments: function(e, t, n, r) {
            const { leading: o , trailing: i  } = eD(e, n, r);
            return o || i ? [
                o,
                t,
                i
            ] : t;
        },
        printCommentsSeparately: eD,
        printDanglingComments: function(e, t, n48, r) {
            const o = [], i = e.getValue();
            return i && i.comments ? (e.each(()=>{
                const n = e.getValue();
                n.leading || n.trailing || r && !r(n) || o.push(Qy(e, t));
            }, "comments"), 0 === o.length ? "" : n48 ? Ly(ky, o) : Oy([
                ky,
                Ly(ky, o)
            ])) : "";
        },
        getSortedChildNodes: zy,
        ensureAllCommentsPrinted: function(e) {
            if (e) for (const t of e){
                if (!t.printed) throw new Error('Comment "' + t.value.trim() + '" was not printed. Please report this error!');
                delete t.printed;
            }
        }
    };
    const nD = au;
    function rD(e, t) {
        const n = oD(e.stack, t);
        return -1 === n ? null : e.stack[n];
    }
    function oD(e, t) {
        for(let n = e.length - 1; n >= 0; n -= 2){
            const r = e[n];
            if (r && !Array.isArray(r) && --t < 0) return n;
        }
        return -1;
    }
    var iD = class {
        constructor(e){
            this.stack = [
                e
            ];
        }
        getName() {
            const { stack: e  } = this, { length: t  } = e;
            return t > 1 ? e[t - 2] : null;
        }
        getValue() {
            return nD(this.stack);
        }
        getNode() {
            return rD(this, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0);
        }
        getParentNode() {
            return rD(this, (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) + 1);
        }
        call(e) {
            const { stack: t  } = this, { length: n  } = t;
            let r = nD(t);
            for(var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)i[u - 1] = arguments[u];
            for (const e179 of i)r = r[e179], t.push(e179, r);
            const s = e(this);
            return t.length = n, s;
        }
        callParent(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            const n = oD(this.stack, t + 1), r = this.stack.splice(n + 1), o = e(this);
            return this.stack.push(...r), o;
        }
        each(e) {
            const { stack: t  } = this, { length: n  } = t;
            let r = nD(t);
            for(var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)i[u - 1] = arguments[u];
            for (const e180 of i)r = r[e180], t.push(e180, r);
            for(let n49 = 0; n49 < r.length; ++n49)t.push(n49, r[n49]), e(this, n49, r), t.length -= 2;
            t.length = n;
        }
        map(e) {
            const t = [];
            for(var n50 = arguments.length, r36 = new Array(n50 > 1 ? n50 - 1 : 0), o24 = 1; o24 < n50; o24++)r36[o24 - 1] = arguments[o24];
            return this.each((n, r, o)=>{
                t[r] = e(n, r, o);
            }, ...r36), t;
        }
        try(e) {
            const { stack: t  } = this, n = [
                ...t
            ];
            try {
                return e();
            } finally{
                t.length = 0, t.push(...n);
            }
        }
        match() {
            let e = this.stack.length - 1, t = null, n = this.stack[e--];
            for(var r = arguments.length, o = new Array(r), i = 0; i < r; i++)o[i] = arguments[i];
            for (const r37 of o){
                if (void 0 === n) return !1;
                let o = null;
                if ("number" == typeof t && (o = t, t = this.stack[e--], n = this.stack[e--]), r37 && !r37(n, t, o)) return !1;
                t = this.stack[e--], n = this.stack[e--];
            }
            return !0;
        }
        findAncestor(e) {
            let t = this.stack.length - 1, n = null, r = this.stack[t--];
            for(; r;){
                let o = null;
                if ("number" == typeof n && (o = n, n = this.stack[t--], r = this.stack[t--]), null !== n && e(r, n, o)) return r;
                n = this.stack[t--], r = this.stack[t--];
            }
        }
    };
    const { utils: { stripTrailingHardline: uD  }  } = Zc, { normalize: sD  } = Bm, aD = tD;
    var cD = {
        printSubtree: function(e181, t105, n51, r38) {
            if (n51.printer.embed && "auto" === n51.embeddedLanguageFormatting) return n51.printer.embed(e181, t105, (e182, t106, o25)=>(function(e, t, n, r) {
                    let { stripTrailingHardline: o = !1  } = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {
                    };
                    const i = sD(Object.assign(Object.assign(Object.assign({
                    }, n), t), {
                    }, {
                        parentParser: n.parser,
                        originalText: e
                    }), {
                        passThrough: !0
                    }), u = Dm.parse(e, i), { ast: s  } = u;
                    e = u.text;
                    const a = s.comments;
                    delete s.comments, aD.attach(a, s, e, i), i[Symbol.for("comments")] = a || [], i[Symbol.for("tokens")] = s.tokens || [];
                    const c = r(s, i);
                    if (aD.ensureAllCommentsPrinted(a), o) return "string" == typeof c ? c.replace(/(?:\r?\n)*$/, "") : uD(c);
                    return c;
                })(e182, t106, n51, r38, o25)
            , n51);
        }
    };
    const lD = iD, { builders: { hardline: pD , addAlignmentToDoc: fD  } , utils: { propagateBreaks: dD  }  } = Zc, { printComments: hD  } = tD, gD = cD;
    function mD(e183, t107) {
        let n52 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        const { printer: r39  } = t107;
        r39.preprocess && (e183 = r39.preprocess(e183, t107));
        const o = new Map, i = new lD(e183);
        let u11 = s();
        function s(e, t) {
            return void 0 === e || e === i ? a(t) : Array.isArray(e) ? i.call(()=>a(t)
            , ...e) : i.call(()=>a(t)
            , e);
        }
        function a(e) {
            const n = i.getValue(), r = n && "object" == typeof n && void 0 === e;
            if (r && o.has(n)) return o.get(n);
            const u = yD(i, t107, s, e);
            return r && o.set(n, u), u;
        }
        return n52 > 0 && (u11 = fD([
            pD,
            u11
        ], n52, t107.tabWidth)), dD(u11), u11;
    }
    function yD(t108, n53, r40, o26) {
        const i15 = t108.getValue(), { printer: u12  } = n53;
        let s8, a5;
        if (u12.hasPrettierIgnore && u12.hasPrettierIgnore(t108)) ({ doc: s8 , printedComments: a5  } = (function(e, t) {
            const { originalText: n , [Symbol.for("comments")]: r , locStart: o , locEnd: i  } = t, u = o(e), s = i(e), a = new Set;
            for (const e184 of r)o(e184) >= u && i(e184) <= s && (e184.printed = !0, a.add(e184));
            return {
                doc: n.slice(u, s),
                printedComments: a
            };
        })(i15, n53));
        else {
            if (i15) try {
                s8 = gD.printSubtree(t108, r40, n53, mD);
            } catch (t) {
                if (e7.PRETTIER_DEBUG) throw t;
            }
            s8 || (s8 = u12.print(t108, n53, r40, o26));
        }
        return u12.willPrintOwnComments && u12.willPrintOwnComments(t108, n53) || (s8 = hD(t108, s8, n53, a5)), s8;
    }
    var DD = mD;
    const ED = Ty, CD = tD;
    function bD(e) {
        let t = e.length - 1;
        for(;;){
            const n = e[t];
            if (!n || "Program" !== n.type && "File" !== n.type) break;
            t--;
        }
        return e.slice(0, t + 1);
    }
    function vD(e, t, n, r) {
        let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], i = arguments.length > 5 ? arguments[5] : void 0;
        const { locStart: u , locEnd: s  } = n, a = u(e), c = s(e);
        if (!(t > c || t < a || "rangeEnd" === i && t === a || "rangeStart" === i && t === c)) {
            for (const u of CD.getSortedChildNodes(e, n)){
                const s = vD(u, t, n, r, [
                    e,
                    ...o
                ], i);
                if (s) return s;
            }
            return !r || r(e, o[0]) ? {
                node: e,
                parentNodes: o
            } : void 0;
        }
    }
    const AD = new Set([
        "ObjectExpression",
        "ArrayExpression",
        "StringLiteral",
        "NumericLiteral",
        "BooleanLiteral",
        "NullLiteral",
        "UnaryExpression",
        "TemplateLiteral"
    ]), FD = new Set([
        "OperationDefinition",
        "FragmentDefinition",
        "VariableDefinition",
        "TypeExtensionDefinition",
        "ObjectTypeDefinition",
        "FieldDefinition",
        "DirectiveDefinition",
        "EnumTypeDefinition",
        "EnumValueDefinition",
        "InputValueDefinition",
        "InputObjectTypeDefinition",
        "SchemaDefinition",
        "OperationTypeDefinition",
        "InterfaceTypeDefinition",
        "UnionTypeDefinition",
        "ScalarTypeDefinition"
    ]);
    function xD(e185, t109, n) {
        if (!t109) return !1;
        switch(e185.parser){
            case "flow":
            case "babel":
            case "babel-flow":
            case "babel-ts":
            case "typescript":
            case "espree":
            case "meriyah":
            case "__babel_estree":
                return (function(e, t) {
                    return "DeclareExportDeclaration" !== t && "TypeParameterDeclaration" !== e && ("Directive" === e || "TypeAlias" === e || "TSExportAssignment" === e || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
                })(t109.type, n && n.type);
            case "json":
            case "json5":
            case "json-stringify":
                return AD.has(t109.type);
            case "graphql":
                return FD.has(t109.kind);
            case "vue":
                return "root" !== t109.tag;
        }
        return !1;
    }
    var SD = {
        calculateRange: function(e186, t110, n54) {
            let { rangeStart: r41 , rangeEnd: o27 , locStart: i16 , locEnd: u13  } = t110;
            ED.ok(o27 > r41);
            const s9 = e186.slice(r41, o27).search(/\S/), a6 = -1 === s9;
            if (!a6) for(r41 += s9; o27 > r41 && !/\S/.test(e186[o27 - 1]); --o27);
            const c = vD(n54, r41, t110, (e, n)=>xD(t110, e, n)
            , [], "rangeStart"), l = a6 ? c : vD(n54, o27, t110, (e)=>xD(t110, e)
            , [], "rangeEnd");
            if (!c || !l) return {
                rangeStart: 0,
                rangeEnd: 0
            };
            let p, f;
            if (((e)=>{
                let { parser: t  } = e;
                return "json" === t || "json5" === t || "json-stringify" === t;
            })(t110)) {
                const e187 = function(e189, t) {
                    const n = [
                        e189.node,
                        ...e189.parentNodes
                    ], r = new Set([
                        t.node,
                        ...t.parentNodes
                    ]);
                    return n.find((e)=>AD.has(e.type) && r.has(e)
                    );
                }(c, l);
                p = e187, f = e187;
            } else ({ startNode: p , endNode: f  } = (function(e, t, n) {
                let { locStart: r , locEnd: o  } = n, i = e.node, u = t.node;
                if (i === u) return {
                    startNode: i,
                    endNode: u
                };
                const s = r(e.node);
                for (const e190 of bD(t.parentNodes)){
                    if (!(r(e190) >= s)) break;
                    u = e190;
                }
                const a = o(t.node);
                for (const t111 of bD(e.parentNodes)){
                    if (!(o(t111) <= a)) break;
                    i = t111;
                }
                return {
                    startNode: i,
                    endNode: u
                };
            })(c, l, t110));
            return {
                rangeStart: Math.min(i16(p), i16(f)),
                rangeEnd: Math.max(u13(p), u13(f))
            };
        },
        findNodeAtOffset: vD
    };
    const wD = r1, { printer: { printDocToString: TD  } , debug: { printDocToDebug: BD  }  } = Zc, { getAlignmentSize: ND  } = dc, { guessEndOfLine: kD , convertEndOfLineToChars: PD , countEndOfLineChars: OD , normalizeEndOfLine: ID  } = hc, LD = Bm.normalize, jD = Nm, _D = tD, MD = Dm, RD = DD, VD = SD, $D = Symbol("cursor");
    function WD(e, t, n) {
        const r = t.comments;
        return r && (delete t.comments, _D.attach(r, t, e, n)), n[Symbol.for("comments")] = r || [], n[Symbol.for("tokens")] = t.tokens || [], n.originalText = e, r;
    }
    function qD(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        if (!e || 0 === e.trim().length) return {
            formatted: "",
            cursorOffset: -1,
            comments: []
        };
        const { ast: r , text: o  } = MD.parse(e, t);
        if (t.cursorOffset >= 0) {
            const e = VD.findNodeAtOffset(r, t.cursorOffset, t);
            e && e.node && (t.cursorNode = e.node);
        }
        const i = WD(o, r, t), u = RD(r, t, n), s = TD(u, t);
        if (_D.ensureAllCommentsPrinted(i), n > 0) {
            const e = s.formatted.trim();
            void 0 !== s.cursorNodeStart && (s.cursorNodeStart -= s.formatted.indexOf(e)), s.formatted = e + PD(t.endOfLine);
        }
        if (t.cursorOffset >= 0) {
            let e, n, r, u, a;
            if (t.cursorNode && s.cursorNodeText ? (e = t.locStart(t.cursorNode), n = o.slice(e, t.locEnd(t.cursorNode)), r = t.cursorOffset - e, u = s.cursorNodeStart, a = s.cursorNodeText) : (e = 0, n = o, r = t.cursorOffset, u = 0, a = s.formatted), n === a) return {
                formatted: s.formatted,
                cursorOffset: u + r,
                comments: i
            };
            const c = [
                ...n
            ];
            c.splice(r, 0, $D);
            const l = [
                ...a
            ], p = wD.diffArrays(c, l);
            let f = u;
            for (const e191 of p)if (e191.removed) {
                if (e191.value.includes($D)) break;
            } else f += e191.count;
            return {
                formatted: s.formatted,
                cursorOffset: f,
                comments: i
            };
        }
        return {
            formatted: s.formatted,
            cursorOffset: -1,
            comments: i
        };
    }
    function UD(e, t, n) {
        return "number" != typeof t || Number.isNaN(t) || t < 0 || t > e.length ? n : t;
    }
    function zD(e, t) {
        let { cursorOffset: n , rangeStart: r , rangeEnd: o  } = t;
        return n = UD(e, n, -1), r = UD(e, r, 0), o = UD(e, o, e.length), Object.assign(Object.assign({
        }, t), {
        }, {
            cursorOffset: n,
            rangeStart: r,
            rangeEnd: o
        });
    }
    function GD(e, t) {
        let { cursorOffset: n , rangeStart: r , rangeEnd: o , endOfLine: i  } = zD(e, t);
        const u = "\ufeff" === e.charAt(0);
        if (u && (e = e.slice(1), n--, r--, o--), "auto" === i && (i = kD(e)), e.includes("\r")) {
            const t112 = (t)=>OD(e.slice(0, Math.max(t, 0)), "\r\n")
            ;
            n -= t112(n), r -= t112(r), o -= t112(o), e = ID(e);
        }
        return {
            hasBOM: u,
            text: e,
            options: zD(e, Object.assign(Object.assign({
            }, t), {
            }, {
                cursorOffset: n,
                rangeStart: r,
                rangeEnd: o,
                endOfLine: i
            }))
        };
    }
    function HD(e, t) {
        const n = MD.resolveParser(t);
        return !n.hasPragma || n.hasPragma(e);
    }
    function JD(e192, t113) {
        let n55, { hasBOM: r42 , text: o28 , options: i17  } = GD(e192, LD(t113));
        return i17.rangeStart >= i17.rangeEnd && "" !== o28 || i17.requirePragma && !HD(o28, i17) ? {
            formatted: e192,
            cursorOffset: t113.cursorOffset,
            comments: []
        } : (i17.rangeStart > 0 || i17.rangeEnd < o28.length ? n55 = (function(e, t) {
            const { ast: n , text: r  } = MD.parse(e, t), { rangeStart: o , rangeEnd: i  } = VD.calculateRange(r, t, n), u = r.slice(o, i), s = Math.min(o, r.lastIndexOf("\n", o) + 1), a = r.slice(s, o).match(/^\s*/)[0], c = ND(a, t.tabWidth), l = qD(u, Object.assign(Object.assign({
            }, t), {
            }, {
                rangeStart: 0,
                rangeEnd: Number.POSITIVE_INFINITY,
                cursorOffset: t.cursorOffset > o && t.cursorOffset <= i ? t.cursorOffset - o : -1,
                endOfLine: "lf"
            }), c), p = l.formatted.trimEnd();
            let { cursorOffset: f  } = t;
            f > i ? f += p.length - u.length : l.cursorOffset >= 0 && (f = l.cursorOffset + o);
            let d = r.slice(0, o) + p + r.slice(i);
            if ("lf" !== t.endOfLine) {
                const e = PD(t.endOfLine);
                f >= 0 && "\r\n" === e && (f += OD(d.slice(0, f), "\n")), d = d.replace(/\n/g, e);
            }
            return {
                formatted: d,
                cursorOffset: f,
                comments: l.comments
            };
        })(o28, i17) : (!i17.requirePragma && i17.insertPragma && i17.printer.insertPragma && !HD(o28, i17) && (o28 = i17.printer.insertPragma(o28)), n55 = qD(o28, i17)), r42 && (n55.formatted = "\ufeff" + n55.formatted, n55.cursorOffset >= 0 && n55.cursorOffset++), n55);
    }
    var XD = {
        formatWithCursor: JD,
        parse (e, t, n) {
            const { text: r , options: o  } = GD(e, LD(t)), i = MD.parse(r, o);
            return n && (i.ast = jD(i.ast, o)), i;
        },
        formatAST (e, t) {
            t = LD(t);
            const n = RD(e, t);
            return TD(n, t);
        },
        formatDoc: (e, t)=>JD(BD(e), Object.assign(Object.assign({
            }, t), {
            }, {
                parser: "__js_expression"
            })).formatted
        ,
        printToDoc (e, t) {
            t = LD(t);
            const { ast: n , text: r  } = MD.parse(e, t);
            return WD(r, n, t), RD(n, t);
        },
        printDocToString: (e, t)=>TD(e, LD(t))
    };
    const { getMaxContinuousCount: YD , getStringWidth: KD , getAlignmentSize: QD , getIndentSize: ZD , skip: eE , skipWhitespace: tE , skipSpaces: nE , skipNewline: rE , skipToLineEnd: oE , skipEverythingButNewLine: iE , skipInlineComment: uE , skipTrailingComment: sE , hasNewline: aE , hasNewlineInRange: cE , hasSpaces: lE , isNextLineEmpty: pE , isNextLineEmptyAfterIndex: fE , isPreviousLineEmpty: dE , getNextNonSpaceNonCommentCharacterIndex: hE , makeString: gE , addLeadingComment: mE , addDanglingComment: yE , addTrailingComment: DE  } = dc;
    var EE = {
        getMaxContinuousCount: YD,
        getStringWidth: KD,
        getAlignmentSize: QD,
        getIndentSize: ZD,
        skip: eE,
        skipWhitespace: tE,
        skipSpaces: nE,
        skipNewline: rE,
        skipToLineEnd: oE,
        skipEverythingButNewLine: iE,
        skipInlineComment: uE,
        skipTrailingComment: sE,
        hasNewline: aE,
        hasNewlineInRange: cE,
        hasSpaces: lE,
        isNextLineEmpty: pE,
        isNextLineEmptyAfterIndex: fE,
        isPreviousLineEmpty: dE,
        getNextNonSpaceNonCommentCharacterIndex: hE,
        makeString: gE,
        addLeadingComment: mE,
        addDanglingComment: yE,
        addTrailingComment: DE
    };
    const CE = [
        "languageId"
    ];
    var bE = function(e, t) {
        const { languageId: n  } = e, r = cu(e, CE);
        return Object.assign(Object.assign({
            linguistLanguageId: n
        }, r), t(e));
    }, vE = {
    }, AE = {
        exports: {
        }
    };
    !function() {
        function e193(e) {
            if (null == e) return !1;
            switch(e.type){
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                    return !0;
            }
            return !1;
        }
        function t114(e) {
            switch(e.type){
                case "IfStatement":
                    return null != e.alternate ? e.alternate : e.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                    return e.body;
            }
            return null;
        }
        AE.exports = {
            isExpression: function(e) {
                if (null == e) return !1;
                switch(e.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "CallExpression":
                    case "ConditionalExpression":
                    case "FunctionExpression":
                    case "Identifier":
                    case "Literal":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ObjectExpression":
                    case "SequenceExpression":
                    case "ThisExpression":
                    case "UnaryExpression":
                    case "UpdateExpression":
                        return !0;
                }
                return !1;
            },
            isStatement: e193,
            isIterationStatement: function(e) {
                if (null == e) return !1;
                switch(e.type){
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "WhileStatement":
                        return !0;
                }
                return !1;
            },
            isSourceElement: function(t) {
                return e193(t) || null != t && "FunctionDeclaration" === t.type;
            },
            isProblematicIfStatement: function(e) {
                var n;
                if ("IfStatement" !== e.type) return !1;
                if (null == e.alternate) return !1;
                n = e.consequent;
                do {
                    if ("IfStatement" === n.type && null == n.alternate) return !0;
                    n = t114(n);
                }while (n)
                return !1;
            },
            trailingStatement: t114
        };
    }();
    var FE = {
        exports: {
        }
    };
    !function() {
        var e194, t115, n, r, o, i;
        function u(e) {
            return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(Math.floor((e - 65536) / 1024) + 55296) + String.fromCharCode((e - 65536) % 1024 + 56320);
        }
        for(t115 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
        }, e194 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        }, n = [
            5760,
            8192,
            8193,
            8194,
            8195,
            8196,
            8197,
            8198,
            8199,
            8200,
            8201,
            8202,
            8239,
            8287,
            12288,
            65279
        ], r = new Array(128), i = 0; i < 128; ++i)r[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || 36 === i || 95 === i;
        for(o = new Array(128), i = 0; i < 128; ++i)o[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || 36 === i || 95 === i;
        FE.exports = {
            isDecimalDigit: function(e) {
                return 48 <= e && e <= 57;
            },
            isHexDigit: function(e) {
                return 48 <= e && e <= 57 || 97 <= e && e <= 102 || 65 <= e && e <= 70;
            },
            isOctalDigit: function(e) {
                return e >= 48 && e <= 55;
            },
            isWhiteSpace: function(e) {
                return 32 === e || 9 === e || 11 === e || 12 === e || 160 === e || e >= 5760 && n.indexOf(e) >= 0;
            },
            isLineTerminator: function(e) {
                return 10 === e || 13 === e || 8232 === e || 8233 === e;
            },
            isIdentifierStartES5: function(e) {
                return e < 128 ? r[e] : t115.NonAsciiIdentifierStart.test(u(e));
            },
            isIdentifierPartES5: function(e) {
                return e < 128 ? o[e] : t115.NonAsciiIdentifierPart.test(u(e));
            },
            isIdentifierStartES6: function(t) {
                return t < 128 ? r[t] : e194.NonAsciiIdentifierStart.test(u(t));
            },
            isIdentifierPartES6: function(t) {
                return t < 128 ? o[t] : e194.NonAsciiIdentifierPart.test(u(t));
            }
        };
    }();
    var xE = {
        exports: {
        }
    };
    !function() {
        var e195 = FE.exports;
        function t116(e, t) {
            return !(!t && "yield" === e) && n56(e, t);
        }
        function n56(e196, t) {
            if (t && (function(e) {
                switch(e){
                    case "implements":
                    case "interface":
                    case "package":
                    case "private":
                    case "protected":
                    case "public":
                    case "static":
                    case "let":
                        return !0;
                    default:
                        return !1;
                }
            })(e196)) return !0;
            switch(e196.length){
                case 2:
                    return "if" === e196 || "in" === e196 || "do" === e196;
                case 3:
                    return "var" === e196 || "for" === e196 || "new" === e196 || "try" === e196;
                case 4:
                    return "this" === e196 || "else" === e196 || "case" === e196 || "void" === e196 || "with" === e196 || "enum" === e196;
                case 5:
                    return "while" === e196 || "break" === e196 || "catch" === e196 || "throw" === e196 || "const" === e196 || "yield" === e196 || "class" === e196 || "super" === e196;
                case 6:
                    return "return" === e196 || "typeof" === e196 || "delete" === e196 || "switch" === e196 || "export" === e196 || "import" === e196;
                case 7:
                    return "default" === e196 || "finally" === e196 || "extends" === e196;
                case 8:
                    return "function" === e196 || "continue" === e196 || "debugger" === e196;
                case 10:
                    return "instanceof" === e196;
                default:
                    return !1;
            }
        }
        function r43(e, n) {
            return "null" === e || "true" === e || "false" === e || t116(e, n);
        }
        function o29(e, t) {
            return "null" === e || "true" === e || "false" === e || n56(e, t);
        }
        function i18(t) {
            var n, r, o;
            if (0 === t.length) return !1;
            if (o = t.charCodeAt(0), !e195.isIdentifierStartES5(o)) return !1;
            for(n = 1, r = t.length; n < r; ++n)if (o = t.charCodeAt(n), !e195.isIdentifierPartES5(o)) return !1;
            return !0;
        }
        function u14(t) {
            var n, r, o, i, u;
            if (0 === t.length) return !1;
            for(u = e195.isIdentifierStartES6, n = 0, r = t.length; n < r; ++n){
                if (55296 <= (o = t.charCodeAt(n)) && o <= 56319) {
                    if (++n >= r) return !1;
                    if (!(56320 <= (i = t.charCodeAt(n)) && i <= 57343)) return !1;
                    o = 1024 * (o - 55296) + (i - 56320) + 65536;
                }
                if (!u(o)) return !1;
                u = e195.isIdentifierPartES6;
            }
            return !0;
        }
        xE.exports = {
            isKeywordES5: t116,
            isKeywordES6: n56,
            isReservedWordES5: r43,
            isReservedWordES6: o29,
            isRestrictedWord: function(e) {
                return "eval" === e || "arguments" === e;
            },
            isIdentifierNameES5: i18,
            isIdentifierNameES6: u14,
            isIdentifierES5: function(e, t) {
                return i18(e) && !r43(e, t);
            },
            isIdentifierES6: function(e, t) {
                return u14(e) && !o29(e, t);
            }
        };
    }(), vE.ast = AE.exports, vE.code = FE.exports, vE.keyword = xE.exports;
    const SE = vE.keyword.isIdentifierNameES5, { getLast: wE , hasNewline: TE , skipWhitespace: BE , isNonEmptyArray: NE , isNextLineEmptyAfterIndex: kE , getStringWidth: PE  } = dc, { locStart: OE , locEnd: IE , hasSameLocStart: LE  } = og, jE = "(?:(?=.)\\s)", _E = new RegExp("^".concat(jE, "*:")), ME = new RegExp("^".concat(jE, "*::"));
    function RE(e) {
        return "Block" === e.type || "CommentBlock" === e.type || "MultiLine" === e.type;
    }
    function VE(e) {
        return "Line" === e.type || "CommentLine" === e.type || "SingleLine" === e.type || "HashbangComment" === e.type || "HTMLOpen" === e.type || "HTMLClose" === e.type;
    }
    const $E = new Set([
        "ExportDefaultDeclaration",
        "ExportDefaultSpecifier",
        "DeclareExportDeclaration",
        "ExportNamedDeclaration",
        "ExportAllDeclaration"
    ]);
    function WE(e) {
        return e && $E.has(e.type);
    }
    function qE(e) {
        return "NumericLiteral" === e.type || "Literal" === e.type && "number" == typeof e.value;
    }
    function UE(e) {
        return "StringLiteral" === e.type || "Literal" === e.type && "string" == typeof e.value;
    }
    function zE(e) {
        return "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type;
    }
    function GE(e) {
        return ZE(e) && "Identifier" === e.callee.type && ("async" === e.callee.name || "inject" === e.callee.name || "fakeAsync" === e.callee.name);
    }
    function HE(e) {
        return "JSXElement" === e.type || "JSXFragment" === e.type;
    }
    function JE(e) {
        return "get" === e.kind || "set" === e.kind;
    }
    function XE(e) {
        return JE(e) || LE(e, e.value);
    }
    const YE = new Set([
        "BinaryExpression",
        "LogicalExpression",
        "NGPipeExpression"
    ]);
    const KE = new Set([
        "AnyTypeAnnotation",
        "TSAnyKeyword",
        "NullLiteralTypeAnnotation",
        "TSNullKeyword",
        "ThisTypeAnnotation",
        "TSThisType",
        "NumberTypeAnnotation",
        "TSNumberKeyword",
        "VoidTypeAnnotation",
        "TSVoidKeyword",
        "BooleanTypeAnnotation",
        "TSBooleanKeyword",
        "BigIntTypeAnnotation",
        "TSBigIntKeyword",
        "SymbolTypeAnnotation",
        "TSSymbolKeyword",
        "StringTypeAnnotation",
        "TSStringKeyword",
        "BooleanLiteralTypeAnnotation",
        "StringLiteralTypeAnnotation",
        "BigIntLiteralTypeAnnotation",
        "NumberLiteralTypeAnnotation",
        "TSLiteralType",
        "TSTemplateLiteralType",
        "EmptyTypeAnnotation",
        "MixedTypeAnnotation",
        "TSNeverKeyword",
        "TSObjectKeyword",
        "TSUndefinedKeyword",
        "TSUnknownKeyword"
    ]);
    const QE = /^(?:skip|[fx]?(?:it|describe|test))$/;
    function ZE(e) {
        return e && ("CallExpression" === e.type || "OptionalCallExpression" === e.type);
    }
    function eC(e) {
        return e && ("MemberExpression" === e.type || "OptionalMemberExpression" === e.type);
    }
    function tC(e) {
        return /^(?:\d+|\d+\.\d+)$/.test(e);
    }
    function nC(e197) {
        return e197.quasis.some((e)=>e.value.raw.includes("\n")
        );
    }
    function rC(e) {
        return e.extra ? e.extra.raw : e.raw;
    }
    const oC = {
        "==": !0,
        "!=": !0,
        "===": !0,
        "!==": !0
    }, iC = {
        "*": !0,
        "/": !0,
        "%": !0
    }, uC = {
        ">>": !0,
        ">>>": !0,
        "<<": !0
    };
    const sC = {
    };
    for (const [e6, t2] of [
        [
            "|>"
        ],
        [
            "??"
        ],
        [
            "||"
        ],
        [
            "&&"
        ],
        [
            "|"
        ],
        [
            "^"
        ],
        [
            "&"
        ],
        [
            "==",
            "===",
            "!=",
            "!=="
        ],
        [
            "<",
            ">",
            "<=",
            ">=",
            "in",
            "instanceof"
        ],
        [
            ">>",
            "<<",
            ">>>"
        ],
        [
            "+",
            "-"
        ],
        [
            "*",
            "/",
            "%"
        ],
        [
            "**"
        ]
    ].entries())for (const n1 of t2)sC[n1] = e6;
    function aC(e) {
        return sC[e];
    }
    const cC = new WeakMap;
    function lC(e) {
        if (cC.has(e)) return cC.get(e);
        const t = [];
        return e.this && t.push(e.this), Array.isArray(e.parameters) ? t.push(...e.parameters) : Array.isArray(e.params) && t.push(...e.params), e.rest && t.push(e.rest), cC.set(e, t), t;
    }
    const pC = new WeakMap;
    function fC(e) {
        if (pC.has(e)) return pC.get(e);
        let t = e.arguments;
        return "ImportExpression" === e.type && (t = [
            e.source
        ], e.attributes && t.push(e.attributes)), pC.set(e, t), t;
    }
    function dC(e) {
        return "prettier-ignore" === e.value.trim() && !e.unignore;
    }
    function hC(e) {
        return e && (e.prettierIgnore || yC(e, gC.PrettierIgnore));
    }
    const gC = {
        Leading: 2,
        Trailing: 4,
        Dangling: 8,
        Block: 16,
        Line: 32,
        PrettierIgnore: 64,
        First: 128,
        Last: 256
    }, mC = (e, t)=>{
        if ("function" == typeof e && (t = e, e = 0), e || t) return (n, r, o)=>!(e & gC.Leading && !n.leading || e & gC.Trailing && !n.trailing || e & gC.Dangling && (n.leading || n.trailing) || e & gC.Block && !RE(n) || e & gC.Line && !VE(n) || e & gC.First && 0 !== r || e & gC.Last && r !== o.length - 1 || e & gC.PrettierIgnore && !dC(n) || t && !t(n))
        ;
    };
    function yC(e, t, n) {
        if (!e || !NE(e.comments)) return !1;
        const r = mC(t, n);
        return !r || e.comments.some(r);
    }
    function DC(e, t, n) {
        if (!e || !Array.isArray(e.comments)) return [];
        const r = mC(t, n);
        return r ? e.comments.filter(r) : e.comments;
    }
    function EC(e) {
        return ZE(e) || "NewExpression" === e.type || "ImportExpression" === e.type;
    }
    var CC = {
        getFunctionParameters: lC,
        iterateFunctionParametersPath: function(e198, t) {
            const n = e198.getValue();
            let r = 0;
            const o = (e)=>t(e, r++)
            ;
            n.this && e198.call(o, "this"), Array.isArray(n.parameters) ? e198.each(o, "parameters") : Array.isArray(n.params) && e198.each(o, "params"), n.rest && e198.call(o, "rest");
        },
        getCallArguments: fC,
        iterateCallArgumentsPath: function(e199, t) {
            const n = e199.getValue();
            "ImportExpression" === n.type ? (e199.call((e)=>t(e, 0)
            , "source"), n.attributes && e199.call((e)=>t(e, 1)
            , "attributes")) : e199.each(t, "arguments");
        },
        hasRestParameter: function(e) {
            if (e.rest) return !0;
            const t = lC(e);
            return t.length > 0 && "RestElement" === wE(t).type;
        },
        getLeftSide: function(e) {
            return e.expressions ? e.expressions[0] : e.left || e.test || e.callee || e.object || e.tag || e.argument || e.expression;
        },
        getLeftSidePathName: function(e, t) {
            if (t.expressions) return [
                "expressions",
                0
            ];
            if (t.left) return [
                "left"
            ];
            if (t.test) return [
                "test"
            ];
            if (t.object) return [
                "object"
            ];
            if (t.callee) return [
                "callee"
            ];
            if (t.tag) return [
                "tag"
            ];
            if (t.argument) return [
                "argument"
            ];
            if (t.expression) return [
                "expression"
            ];
            throw new Error("Unexpected node has no left side.");
        },
        getParentExportDeclaration: function(e) {
            const t = e.getParentNode();
            return "declaration" === e.getName() && WE(t) ? t : null;
        },
        getTypeScriptMappedTypeModifier: function(e, t) {
            return "+" === e ? "+" + t : "-" === e ? "-" + t : t;
        },
        hasFlowAnnotationComment: function(e) {
            return NE(e) && RE(e[0]) && ME.test(e[0].value);
        },
        hasFlowShorthandAnnotationComment: function(e) {
            return e.extra && e.extra.parenthesized && NE(e.trailingComments) && RE(e.trailingComments[0]) && _E.test(e.trailingComments[0].value);
        },
        hasLeadingOwnLineComment: function(e, t117) {
            return HE(t117) ? hC(t117) : yC(t117, gC.Leading, (t)=>TE(e, IE(t))
            );
        },
        hasNakedLeftSide: function(e) {
            return "AssignmentExpression" === e.type || "BinaryExpression" === e.type || "LogicalExpression" === e.type || "NGPipeExpression" === e.type || "ConditionalExpression" === e.type || ZE(e) || eC(e) || "SequenceExpression" === e.type || "TaggedTemplateExpression" === e.type || "BindExpression" === e.type || "UpdateExpression" === e.type && !e.prefix || "TSAsExpression" === e.type || "TSNonNullExpression" === e.type;
        },
        hasNode: function e(t118, n) {
            if (!t118 || "object" != typeof t118) return !1;
            if (Array.isArray(t118)) return t118.some((t)=>e(t, n)
            );
            const r = n(t118);
            return "boolean" == typeof r ? r : Object.values(t118).some((t)=>e(t, n)
            );
        },
        hasIgnoreComment: function(e) {
            return hC(e.getValue());
        },
        hasNodeIgnoreComment: hC,
        identity: function(e) {
            return e;
        },
        isBinaryish: function(e) {
            return YE.has(e.type);
        },
        isBlockComment: RE,
        isCallLikeExpression: EC,
        isEnabledHackPipeline: function(e) {
            return Boolean(e.__isUsingHackPipeline);
        },
        isLineComment: VE,
        isPrettierIgnoreComment: dC,
        isCallExpression: ZE,
        isMemberExpression: eC,
        isExportDeclaration: WE,
        isFlowAnnotationComment: function(e, t) {
            const n = OE(t), r = BE(e, IE(t));
            return !1 !== r && "/*" === e.slice(n, n + 2) && "*/" === e.slice(r, r + 2);
        },
        isFunctionCompositionArgs: function(e) {
            if (e.length <= 1) return !1;
            let t = 0;
            for (const n of e)if (zE(n)) {
                if (t += 1, t > 1) return !0;
            } else if (ZE(n)) {
                for (const e200 of n.arguments)if (zE(e200)) return !0;
            }
            return !1;
        },
        isFunctionNotation: XE,
        isFunctionOrArrowExpression: zE,
        isGetterOrSetter: JE,
        isJestEachTemplateLiteral: function(e, t) {
            const n = /^[fx]?(?:describe|it|test)$/;
            return "TaggedTemplateExpression" === t.type && t.quasi === e && "MemberExpression" === t.tag.type && "Identifier" === t.tag.property.type && "each" === t.tag.property.name && ("Identifier" === t.tag.object.type && n.test(t.tag.object.name) || "MemberExpression" === t.tag.object.type && "Identifier" === t.tag.object.property.type && ("only" === t.tag.object.property.name || "skip" === t.tag.object.property.name) && "Identifier" === t.tag.object.object.type && n.test(t.tag.object.object.name));
        },
        isJsxNode: HE,
        isLiteral: function(e) {
            return "BooleanLiteral" === e.type || "DirectiveLiteral" === e.type || "Literal" === e.type || "NullLiteral" === e.type || "NumericLiteral" === e.type || "BigIntLiteral" === e.type || "DecimalLiteral" === e.type || "RegExpLiteral" === e.type || "StringLiteral" === e.type || "TemplateLiteral" === e.type || "TSTypeLiteral" === e.type || "JSXText" === e.type;
        },
        isLongCurriedCallExpression: function(e) {
            const t = e.getValue(), n = e.getParentNode();
            return ZE(t) && ZE(n) && n.callee === t && t.arguments.length > n.arguments.length && n.arguments.length > 0;
        },
        isSimpleCallArgument: function e201(t119, n) {
            if (n >= 2) return !1;
            const r = (t)=>e201(t, n + 1)
            , o = "Literal" === t119.type && "regex" in t119 && t119.regex.pattern || "RegExpLiteral" === t119.type && t119.pattern;
            return !(o && PE(o) > 5) && ("Literal" === t119.type || "BigIntLiteral" === t119.type || "DecimalLiteral" === t119.type || "BooleanLiteral" === t119.type || "NullLiteral" === t119.type || "NumericLiteral" === t119.type || "RegExpLiteral" === t119.type || "StringLiteral" === t119.type || "Identifier" === t119.type || "ThisExpression" === t119.type || "Super" === t119.type || "PrivateName" === t119.type || "PrivateIdentifier" === t119.type || "ArgumentPlaceholder" === t119.type || "Import" === t119.type || ("TemplateLiteral" === t119.type ? t119.quasis.every((e)=>!e.value.raw.includes("\n")
            ) && t119.expressions.every(r) : "ObjectExpression" === t119.type ? t119.properties.every((e)=>!e.computed && (e.shorthand || e.value && r(e.value))
            ) : "ArrayExpression" === t119.type ? t119.elements.every((e)=>null === e || r(e)
            ) : EC(t119) ? ("ImportExpression" === t119.type || e201(t119.callee, n)) && fC(t119).every(r) : eC(t119) ? e201(t119.object, n) && e201(t119.property, n) : "UnaryExpression" !== t119.type || "!" !== t119.operator && "-" !== t119.operator ? "TSNonNullExpression" === t119.type && e201(t119.expression, n) : e201(t119.argument, n)));
        },
        isMemberish: function(e) {
            return eC(e) || "BindExpression" === e.type && Boolean(e.object);
        },
        isNumericLiteral: qE,
        isSignedNumericLiteral: function(e) {
            return "UnaryExpression" === e.type && ("+" === e.operator || "-" === e.operator) && qE(e.argument);
        },
        isObjectProperty: function(e) {
            return e && ("ObjectProperty" === e.type || "Property" === e.type && !e.method && "init" === e.kind);
        },
        isObjectType: function(e) {
            return "ObjectTypeAnnotation" === e.type || "TSTypeLiteral" === e.type || "TSMappedType" === e.type;
        },
        isObjectTypePropertyAFunction: function(e) {
            return !("ObjectTypeProperty" !== e.type && "ObjectTypeInternalSlot" !== e.type || "FunctionTypeAnnotation" !== e.value.type || e.static || XE(e));
        },
        isSimpleType: function(e) {
            return !!e && (!("GenericTypeAnnotation" !== e.type && "TSTypeReference" !== e.type || e.typeParameters) || !!KE.has(e.type));
        },
        isSimpleNumber: tC,
        isSimpleTemplateLiteral: function(e202) {
            let t120 = "expressions";
            "TSTemplateLiteralType" === e202.type && (t120 = "types");
            const n = e202[t120];
            return 0 !== n.length && n.every((e)=>{
                if (yC(e)) return !1;
                if ("Identifier" === e.type || "ThisExpression" === e.type) return !0;
                if (eC(e)) {
                    let t = e;
                    for(; eC(t);){
                        if ("Identifier" !== t.property.type && "Literal" !== t.property.type && "StringLiteral" !== t.property.type && "NumericLiteral" !== t.property.type) return !1;
                        if (t = t.object, yC(t)) return !1;
                    }
                    return "Identifier" === t.type || "ThisExpression" === t.type;
                }
                return !1;
            });
        },
        isStringLiteral: UE,
        isStringPropSafeToUnquote: function(e, t) {
            return "json" !== t.parser && UE(e.key) && rC(e.key).slice(1, -1) === e.key.value && (SE(e.key.value) && !("babel-ts" === t.parser && "ClassProperty" === e.type || "typescript" === t.parser && "PropertyDefinition" === e.type) || tC(e.key.value) && String(Number(e.key.value)) === e.key.value && ("babel" === t.parser || "espree" === t.parser || "meriyah" === t.parser || "__babel_estree" === t.parser));
        },
        isTemplateOnItsOwnLine: function(e, t) {
            return ("TemplateLiteral" === e.type && nC(e) || "TaggedTemplateExpression" === e.type && nC(e.quasi)) && !TE(t, OE(e), {
                backwards: !0
            });
        },
        isTestCall: function e203(t, n) {
            if ("CallExpression" !== t.type) return !1;
            if (1 === t.arguments.length) {
                if (GE(t) && n && e203(n)) return zE(t.arguments[0]);
                if ((function(e) {
                    return "Identifier" === e.callee.type && /^(?:before|after)(?:Each|All)$/.test(e.callee.name) && 1 === e.arguments.length;
                })(t)) return GE(t.arguments[0]);
            } else if ((2 === t.arguments.length || 3 === t.arguments.length) && ("Identifier" === t.callee.type && QE.test(t.callee.name) || (function(e) {
                return eC(e.callee) && "Identifier" === e.callee.object.type && "Identifier" === e.callee.property.type && QE.test(e.callee.object.name) && ("only" === e.callee.property.name || "skip" === e.callee.property.name);
            })(t)) && ((function(e) {
                return "TemplateLiteral" === e.type;
            })(t.arguments[0]) || UE(t.arguments[0]))) return !(t.arguments[2] && !qE(t.arguments[2])) && ((2 === t.arguments.length ? zE(t.arguments[1]) : (function(e) {
                return "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type && "BlockStatement" === e.body.type;
            })(t.arguments[1]) && lC(t.arguments[1]).length <= 1) || GE(t.arguments[1]));
            return !1;
        },
        isTheOnlyJsxElementInMarkdown: function(e, t) {
            if ("markdown" !== e.parentParser && "mdx" !== e.parentParser) return !1;
            const n = t.getNode();
            if (!n.expression || !HE(n.expression)) return !1;
            const r = t.getParentNode();
            return "Program" === r.type && 1 === r.body.length;
        },
        isTSXFile: function(e) {
            return e.filepath && /\.tsx$/i.test(e.filepath);
        },
        isTypeAnnotationAFunction: function(e) {
            return !("TypeAnnotation" !== e.type && "TSTypeAnnotation" !== e.type || "FunctionTypeAnnotation" !== e.typeAnnotation.type || e.static || LE(e, e.typeAnnotation));
        },
        isNextLineEmpty: (e, t)=>{
            let { originalText: n  } = t;
            return kE(n, IE(e));
        },
        needsHardlineAfterDanglingComment: function(e) {
            if (!yC(e)) return !1;
            const t = wE(DC(e, gC.Dangling));
            return t && !RE(t);
        },
        rawText: rC,
        shouldPrintComma: function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "es5";
            return "es5" === e.trailingComma && "es5" === t || "all" === e.trailingComma && ("all" === t || "es5" === t);
        },
        isBitwiseOperator: function(e) {
            return Boolean(uC[e]) || "|" === e || "^" === e || "&" === e;
        },
        shouldFlatten: function(e, t) {
            return aC(t) === aC(e) && "**" !== e && (!oC[e] || !oC[t]) && !("%" === t && iC[e] || "%" === e && iC[t]) && (t === e || !iC[t] || !iC[e]) && (!uC[e] || !uC[t]);
        },
        startsWithNoLookaheadToken: function e204(t, n) {
            switch((t = (function(e) {
                for(; e.left;)e = e.left;
                return e;
            })(t)).type){
                case "FunctionExpression":
                case "ClassExpression":
                case "DoExpression":
                    return n;
                case "ObjectExpression":
                    return !0;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return e204(t.object, n);
                case "TaggedTemplateExpression":
                    return "FunctionExpression" !== t.tag.type && e204(t.tag, n);
                case "CallExpression":
                case "OptionalCallExpression":
                    return "FunctionExpression" !== t.callee.type && e204(t.callee, n);
                case "ConditionalExpression":
                    return e204(t.test, n);
                case "UpdateExpression":
                    return !t.prefix && e204(t.argument, n);
                case "BindExpression":
                    return t.object && e204(t.object, n);
                case "SequenceExpression":
                    return e204(t.expressions[0], n);
                case "TSAsExpression":
                case "TSNonNullExpression":
                    return e204(t.expression, n);
                default:
                    return !1;
            }
        },
        getPrecedence: aC,
        hasComment: yC,
        getComments: DC,
        CommentCheckFlags: gC
    };
    const bC = au, { getStringWidth: vC , getIndentSize: AC  } = dc, { builders: { join: FC , hardline: xC , softline: SC , group: wC , indent: TC , align: BC , lineSuffixBoundary: NC , addAlignmentToDoc: kC  } , printer: { printDocToString: PC  } , utils: { mapDoc: OC  }  } = Zc, { isBinaryish: IC , isJestEachTemplateLiteral: LC , isSimpleTemplateLiteral: jC , hasComment: _C , isMemberExpression: MC  } = CC;
    function RC(e) {
        return e.replace(/([\\`]|\${)/g, "\\$1");
    }
    var VC = {
        printTemplateLiteral: function(e205, t121, n57) {
            const r45 = e205.getValue();
            if ("TemplateLiteral" === r45.type && LC(r45, e205.getParentNode())) {
                const r44 = function(e206, t123, n) {
                    const r = e206.getNode(), o = r.quasis[0].value.raw.trim().split(/\s*\|\s*/);
                    if (o.length > 1 || o.some((e)=>e.length > 0
                    )) {
                        t123.__inJestEach = !0;
                        const i = e206.map(n, "expressions");
                        t123.__inJestEach = !1;
                        const u = [], s = i.map((e)=>"${" + PC(e, Object.assign(Object.assign({
                            }, t123), {
                            }, {
                                printWidth: Number.POSITIVE_INFINITY,
                                endOfLine: "lf"
                            })).formatted + "}"
                        ), a = [
                            {
                                hasLineBreak: !1,
                                cells: []
                            }
                        ];
                        for(let e208 = 1; e208 < r.quasis.length; e208++){
                            const t = bC(a), n = s[e208 - 1];
                            t.cells.push(n), n.includes("\n") && (t.hasLineBreak = !0), r.quasis[e208].value.raw.includes("\n") && a.push({
                                hasLineBreak: !1,
                                cells: []
                            });
                        }
                        const c = Math.max(o.length, ...a.map((e)=>e.cells.length
                        )), l = Array.from({
                            length: c
                        }).fill(0), p = [
                            {
                                cells: o
                            },
                            ...a.filter((e)=>e.cells.length > 0
                            )
                        ];
                        for (const { cells: e207  } of p.filter((e)=>!e.hasLineBreak
                        ))for (const [t122, n58] of e207.entries())l[t122] = Math.max(l[t122], vC(n58));
                        return u.push(NC, "`", TC([
                            xC,
                            FC(xC, p.map((e)=>FC(" | ", e.cells.map((t, n)=>e.hasLineBreak ? t : t + " ".repeat(l[n] - vC(t))
                                ))
                            ))
                        ]), xC, "`"), u;
                    }
                }(e205, n57, t121);
                if (r44) return r44;
            }
            let o30 = "expressions";
            "TSTemplateLiteralType" === r45.type && (o30 = "types");
            const i19 = [];
            let u15 = e205.map(t121, o30);
            const s10 = jC(r45);
            return s10 && (u15 = u15.map((e)=>PC(e, Object.assign(Object.assign({
                }, n57), {
                }, {
                    printWidth: Number.POSITIVE_INFINITY
                })).formatted
            )), i19.push(NC, "`"), e205.each((e)=>{
                const a = e.getName();
                if (i19.push(t121()), a < u15.length) {
                    const { tabWidth: t  } = n57, c = e.getValue(), l = AC(c.value.raw, t);
                    let p = u15[a];
                    if (!s10) {
                        const e = r45[o30][a];
                        (_C(e) || MC(e) || "ConditionalExpression" === e.type || "SequenceExpression" === e.type || "TSAsExpression" === e.type || IC(e)) && (p = [
                            TC([
                                SC,
                                p
                            ]),
                            SC
                        ]);
                    }
                    const f = 0 === l && c.value.raw.endsWith("\n") ? BC(Number.NEGATIVE_INFINITY, p) : kC(p, l, t);
                    i19.push(wC([
                        "${",
                        f,
                        NC,
                        "}"
                    ]));
                }
            }, "quasis"), i19.push("`"), i19;
        },
        printTemplateExpressions: function(e210, t124) {
            return e210.map((e211)=>(function(e, t) {
                    const n = e.getValue();
                    let r = t();
                    return _C(n) && (r = wC([
                        TC([
                            SC,
                            r
                        ]),
                        SC
                    ])), [
                        "${",
                        r,
                        NC,
                        "}"
                    ];
                })(e211, t124)
            , "expressions");
        },
        escapeTemplateCharacters: function(e212, t) {
            return OC(e212, (e)=>"string" == typeof e ? t ? e.replace(/(\\*)`/g, "$1$1\\`") : RC(e) : e
            );
        },
        uncookTemplateElementValue: RC
    };
    const { builders: { indent: $C , softline: WC , literalline: qC , dedentToRoot: UC  }  } = Zc, { escapeTemplateCharacters: zC  } = VC;
    var GC = function(e213, t125, n) {
        let r = e213.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e, t)=>"\\".repeat(t.length / 2) + "`"
        );
        const o = function(e) {
            const t = e.match(/^([^\S\n]*)\S/m);
            return null === t ? "" : t[1];
        }(r), i = "" !== o;
        i && (r = r.replace(new RegExp("^".concat(o), "gm"), ""));
        const u = zC(n(r, {
            parser: "markdown",
            __inJsTemplate: !0
        }, {
            stripTrailingHardline: !0
        }), !0);
        return [
            "`",
            i ? $C([
                WC,
                u
            ]) : [
                qC,
                UC(u)
            ],
            WC,
            "`"
        ];
    };
    const { isNonEmptyArray: HC  } = dc, { builders: { indent: JC , hardline: XC , softline: YC  } , utils: { mapDoc: KC , replaceEndOfLine: QC , cleanDoc: ZC  }  } = Zc, { printTemplateExpressions: eb  } = VC;
    var tb = function(e214, t126, n59) {
        const r46 = e214.getValue(), o = r46.quasis.map((e)=>e.value.raw
        );
        let i = 0;
        return (function(e215, t127, n60) {
            if (1 === t127.quasis.length && !t127.quasis[0].value.raw.trim()) return "``";
            const r47 = function(e216, t) {
                if (!HC(t)) return e216;
                let n = 0;
                const r48 = KC(ZC(e216), (e217)=>"string" == typeof e217 && e217.includes("@prettier-placeholder") ? e217.split(/@prettier-placeholder-(\d+)-id/).map((e, r)=>r % 2 == 0 ? QC(e) : (n++, t[e])
                    ) : e217
                );
                return t.length === n ? r48 : null;
            }(e215, n60);
            if (!r47) throw new Error("Couldn't insert all the expressions");
            return [
                "`",
                JC([
                    XC,
                    r47
                ]),
                YC,
                "`"
            ];
        })(n59(o.reduce((e, t, n)=>0 === n ? t : e + "@prettier-placeholder-" + i++ + "-id" + t
        , ""), {
            parser: "scss"
        }, {
            stripTrailingHardline: !0
        }), r46, eb(e214, t126));
    };
    const { builders: { indent: nb , join: rb , hardline: ob  }  } = Zc, { escapeTemplateCharacters: ib , printTemplateExpressions: ub  } = VC;
    function sb(e219) {
        const t = [];
        let n = !1;
        const r = e219.map((e)=>e.trim()
        );
        for (const [e218, o] of r.entries())"" !== o && ("" === r[e218 - 1] && n ? t.push([
            ob,
            o
        ]) : t.push(o), n = !0);
        return 0 === t.length ? null : rb(ob, t);
    }
    var ab = function(e221, t, n) {
        const r = e221.getValue(), o = r.quasis.length;
        if (1 === o && "" === r.quasis[0].value.raw.trim()) return "``";
        const i = ub(e221, t), u = [];
        for(let e220 = 0; e220 < o; e220++){
            const t = 0 === e220, s = e220 === o - 1, a = r.quasis[e220].value.cooked, c = a.split("\n"), l = c.length, p = i[e220], f = l > 2 && "" === c[0].trim() && "" === c[1].trim(), d = l > 2 && "" === c[l - 1].trim() && "" === c[l - 2].trim(), h = c.every((e)=>/^\s*(?:#[^\n\r]*)?$/.test(e)
            );
            if (!s && /#[^\n\r]*$/.test(c[l - 1])) return null;
            let g = null;
            g = h ? sb(c) : n(a, {
                parser: "graphql"
            }, {
                stripTrailingHardline: !0
            }), g ? (g = ib(g, !1), !t && f && u.push(""), u.push(g), !s && d && u.push("")) : t || s || !f || u.push(""), p && u.push(p);
        }
        return [
            "`",
            nb([
                ob,
                rb(ob, u)
            ]),
            ob,
            "`"
        ];
    };
    const { builders: { indent: cb , line: lb , hardline: pb , group: fb  } , utils: { mapDoc: db  }  } = Zc, { printTemplateExpressions: hb , uncookTemplateElementValue: gb  } = VC;
    let mb = 0;
    var yb = function(e222, t128, n61, r, o31) {
        let { parser: i  } = o31;
        const u = e222.getValue(), s = mb;
        mb = mb + 1 >>> 0;
        const a = (e)=>"PRETTIER_HTML_PLACEHOLDER_".concat(e, "_").concat(s, "_IN_JS")
        , c = u.quasis.map((e, t, n)=>t === n.length - 1 ? e.value.cooked : e.value.cooked + a(t)
        ).join(""), l = hb(e222, t128);
        if (0 === l.length && 0 === c.trim().length) return "``";
        const p = new RegExp(a("(\\d+)"), "g");
        let f = 0;
        const d = n61(c, {
            parser: i,
            __onHtmlRoot (e) {
                f = e.children.length;
            }
        }, {
            stripTrailingHardline: !0
        }), h = db(d, (e)=>{
            if ("string" != typeof e) return e;
            const t = [], n = e.split(p);
            for(let e223 = 0; e223 < n.length; e223++){
                let o = n[e223];
                if (e223 % 2 == 0) {
                    o && (o = gb(o), r.__embeddedInHtml && (o = o.replace(/<\/(script)\b/gi, "<\\/$1")), t.push(o));
                    continue;
                }
                const i = Number(o);
                t.push(l[i]);
            }
            return t;
        }), g = /^\s/.test(c) ? " " : "", m = /\s$/.test(c) ? " " : "", y = "ignore" === r.htmlWhitespaceSensitivity ? pb : g && m ? lb : null;
        return fb(y ? [
            "`",
            cb([
                y,
                fb(h)
            ]),
            y,
            "`"
        ] : [
            "`",
            g,
            f > 1 ? cb(fb(h)) : fb(h),
            m,
            "`"
        ]);
    };
    const { hasComment: Db , CommentCheckFlags: Eb , isObjectProperty: Cb  } = CC, bb = GC, vb = tb, Ab = ab, Fb = yb;
    function xb(e224) {
        return (function(e225) {
            const t = e225.getValue(), n = e225.getParentNode(), r = e225.getParentNode(1);
            return r && t.quasis && "JSXExpressionContainer" === n.type && "JSXElement" === r.type && "style" === r.openingElement.name.name && r.openingElement.attributes.some((e)=>"jsx" === e.name.name
            ) || n && "TaggedTemplateExpression" === n.type && "Identifier" === n.tag.type && "css" === n.tag.name || n && "TaggedTemplateExpression" === n.type && "MemberExpression" === n.tag.type && "css" === n.tag.object.name && ("global" === n.tag.property.name || "resolve" === n.tag.property.name);
        })(e224) || (function(e) {
            const t = e.getParentNode();
            if (!t || "TaggedTemplateExpression" !== t.type) return !1;
            const n = "ParenthesizedExpression" === t.tag.type ? t.tag.expression : t.tag;
            switch(n.type){
                case "MemberExpression":
                    return wb(n.object) || Tb(n);
                case "CallExpression":
                    return wb(n.callee) || "MemberExpression" === n.callee.type && ("MemberExpression" === n.callee.object.type && (wb(n.callee.object.object) || Tb(n.callee.object)) || "CallExpression" === n.callee.object.type && wb(n.callee.object.callee));
                case "Identifier":
                    return "css" === n.name;
                default:
                    return !1;
            }
        })(e224) || (function(e) {
            const t = e.getParentNode(), n = e.getParentNode(1);
            return n && "JSXExpressionContainer" === t.type && "JSXAttribute" === n.type && "JSXIdentifier" === n.name.type && "css" === n.name.name;
        })(e224) || (function(e226) {
            return e226.match((e)=>"TemplateLiteral" === e.type
            , (e, t)=>"ArrayExpression" === e.type && "elements" === t
            , (e, t)=>Cb(e) && "Identifier" === e.key.type && "styles" === e.key.name && "value" === t
            , ...Sb);
        })(e224) ? "css" : (function(e) {
            const t = e.getValue(), n = e.getParentNode();
            return Bb(t, "GraphQL") || n && ("TaggedTemplateExpression" === n.type && ("MemberExpression" === n.tag.type && "graphql" === n.tag.object.name && "experimental" === n.tag.property.name || "Identifier" === n.tag.type && ("gql" === n.tag.name || "graphql" === n.tag.name)) || "CallExpression" === n.type && "Identifier" === n.callee.type && "graphql" === n.callee.name);
        })(e224) ? "graphql" : (function(e227) {
            return Bb(e227.getValue(), "HTML") || e227.match((e)=>"TemplateLiteral" === e.type
            , (e, t)=>"TaggedTemplateExpression" === e.type && "Identifier" === e.tag.type && "html" === e.tag.name && "quasi" === t
            );
        })(e224) ? "html" : (function(e228) {
            return e228.match((e)=>"TemplateLiteral" === e.type
            , (e, t)=>Cb(e) && "Identifier" === e.key.type && "template" === e.key.name && "value" === t
            , ...Sb);
        })(e224) ? "angular" : (function(e) {
            const t = e.getValue(), n = e.getParentNode();
            return n && "TaggedTemplateExpression" === n.type && 1 === t.quasis.length && "Identifier" === n.tag.type && ("md" === n.tag.name || "markdown" === n.tag.name);
        })(e224) ? "markdown" : void 0;
    }
    const Sb = [
        (e, t)=>"ObjectExpression" === e.type && "properties" === t
        ,
        (e, t)=>"CallExpression" === e.type && "Identifier" === e.callee.type && "Component" === e.callee.name && "arguments" === t
        ,
        (e, t)=>"Decorator" === e.type && "expression" === t
    ];
    function wb(e) {
        return "Identifier" === e.type && "styled" === e.name;
    }
    function Tb(e) {
        return /^[A-Z]/.test(e.object.name) && "extend" === e.property.name;
    }
    function Bb(e229, t) {
        return Db(e229, Eb.Block | Eb.Leading, (e)=>{
            let { value: n  } = e;
            return n === " ".concat(t, " ");
        });
    }
    var Nb = function(e230, t129, n, r) {
        const o = e230.getValue();
        if ("TemplateLiteral" !== o.type || (function(e231) {
            let { quasis: t130  } = e231;
            return t130.some((e)=>{
                let { value: { cooked: t  }  } = e;
                return null === t;
            });
        })(o)) return;
        const i = xb(e230);
        return i ? "markdown" === i ? bb(e230, t129, n) : "css" === i ? vb(e230, t129, n) : "graphql" === i ? Ab(e230, t129, n) : "html" === i || "angular" === i ? Fb(e230, t129, n, r, {
            parser: i
        }) : void 0 : void 0;
    };
    const { isBlockComment: kb  } = CC, Pb = new Set([
        "range",
        "raw",
        "comments",
        "leadingComments",
        "trailingComments",
        "innerComments",
        "extra",
        "start",
        "end",
        "loc",
        "flags",
        "errors",
        "tokens"
    ]), Ob = (e)=>{
        for (const t of e.quasis)delete t.value;
    };
    function Ib(e233, t131, n) {
        if ("Program" === e233.type && delete t131.sourceType, "BigIntLiteral" !== e233.type && "BigIntLiteralTypeAnnotation" !== e233.type || t131.value && (t131.value = t131.value.toLowerCase()), "BigIntLiteral" !== e233.type && "Literal" !== e233.type || t131.bigint && (t131.bigint = t131.bigint.toLowerCase()), "DecimalLiteral" === e233.type && (t131.value = Number(t131.value)), "Literal" === e233.type && t131.decimal && (t131.decimal = Number(t131.decimal)), "EmptyStatement" === e233.type) return null;
        if ("JSXText" === e233.type) return null;
        if ("JSXExpressionContainer" === e233.type && ("Literal" === e233.expression.type || "StringLiteral" === e233.expression.type) && " " === e233.expression.value) return null;
        if ("Property" !== e233.type && "ObjectProperty" !== e233.type && "MethodDefinition" !== e233.type && "ClassProperty" !== e233.type && "ClassMethod" !== e233.type && "PropertyDefinition" !== e233.type && "TSDeclareMethod" !== e233.type && "TSPropertySignature" !== e233.type && "ObjectTypeProperty" !== e233.type || "object" != typeof e233.key || !e233.key || "Literal" !== e233.key.type && "NumericLiteral" !== e233.key.type && "StringLiteral" !== e233.key.type && "Identifier" !== e233.key.type || delete t131.key, "JSXElement" === e233.type && "style" === e233.openingElement.name.name && e233.openingElement.attributes.some((e)=>"jsx" === e.name.name
        )) for (const { type: e232 , expression: n62  } of t131.children)"JSXExpressionContainer" === e232 && "TemplateLiteral" === n62.type && Ob(n62);
        "JSXAttribute" === e233.type && "css" === e233.name.name && "JSXExpressionContainer" === e233.value.type && "TemplateLiteral" === e233.value.expression.type && Ob(t131.value.expression), "JSXAttribute" === e233.type && e233.value && "Literal" === e233.value.type && /["']|&quot;|&apos;/.test(e233.value.value) && (t131.value.value = t131.value.value.replace(/["']|&quot;|&apos;/g, '"'));
        const r = e233.expression || e233.callee;
        if ("Decorator" === e233.type && "CallExpression" === r.type && "Component" === r.callee.name && 1 === r.arguments.length) {
            const n = e233.expression.arguments[0].properties;
            for (const [e, r] of t131.expression.arguments[0].properties.entries())switch(n[e].key.name){
                case "styles":
                    "ArrayExpression" === r.value.type && Ob(r.value.elements[0]);
                    break;
                case "template":
                    "TemplateLiteral" === r.value.type && Ob(r.value);
            }
        }
        if ("TaggedTemplateExpression" !== e233.type || "MemberExpression" !== e233.tag.type && ("Identifier" !== e233.tag.type || "gql" !== e233.tag.name && "graphql" !== e233.tag.name && "css" !== e233.tag.name && "md" !== e233.tag.name && "markdown" !== e233.tag.name && "html" !== e233.tag.name) && "CallExpression" !== e233.tag.type || Ob(t131.quasi), "TemplateLiteral" === e233.type) {
            const r = e233.leadingComments && e233.leadingComments.some((e)=>kb(e) && [
                    "GraphQL",
                    "HTML"
                ].some((t)=>e.value === " ".concat(t, " ")
                )
            );
            (r || "CallExpression" === n.type && "graphql" === n.callee.name || !e233.leadingComments) && Ob(t131);
        }
        return "InterpreterDirective" === e233.type && (t131.value = t131.value.trimEnd()), "TSIntersectionType" !== e233.type && "TSUnionType" !== e233.type || 1 !== e233.types.length ? void 0 : t131.types[0];
    }
    Ib.ignoredProperties = Pb;
    var Lb = Ib, jb = {
    }, _b = {
        exports: {
        }
    };
    const Mb = (e234)=>{
        if ("string" != typeof e234) throw new TypeError("Expected a string");
        const t = e234.match(/(?:\r?\n)/g) || [];
        if (0 === t.length) return;
        const n = t.filter((e)=>"\r\n" === e
        ).length;
        return n > t.length - n ? "\r\n" : "\n";
    };
    function Rb() {
        const e = yf;
        return Rb = function() {
            return e;
        }, e;
    }
    function Vb() {
        const e235 = function(e) {
            return e && e.__esModule ? e : {
                default: e
            };
        }(_b.exports);
        return Vb = function() {
            return e235;
        }, e235;
    }
    _b.exports = Mb, _b.exports.graceful = (e)=>"string" == typeof e && Mb(e) || "\n"
    , Object.defineProperty(jb, "__esModule", {
        value: !0
    }), jb.extract = function(e) {
        const t = e.match(qb);
        return t ? t[0].trimLeft() : "";
    }, jb.strip = function(e) {
        const t = e.match(qb);
        return t && t[0] ? e.substring(t[0].length) : e;
    }, jb.parse = function(e) {
        return Yb(e).pragmas;
    }, jb.parseWithComments = Yb, jb.print = function(e236) {
        let { comments: t132 = "" , pragmas: n = {
        }  } = e236;
        const r = (0, Vb().default)(t132) || Rb().EOL, o = " *", i = Object.keys(n), u = i.map((e)=>Kb(e, n[e])
        ).reduce((e, t)=>e.concat(t)
        , []).map((e)=>" * " + e + r
        ).join("");
        if (!t132) {
            if (0 === i.length) return "";
            if (1 === i.length && !Array.isArray(n[i[0]])) {
                const e = n[i[0]];
                return "".concat("/**", " ").concat(Kb(i[0], e)[0]).concat(" */");
            }
        }
        const s = t132.split(r).map((e)=>"".concat(o, " ").concat(e)
        ).join(r) + r;
        return "/**" + r + (t132 ? s : "") + (t132 && i.length ? o + r : "") + u + " */";
    };
    const $b = /\*\/$/, Wb = /^\/\*\*/, qb = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Ub = /(^|\s+)\/\/([^\r\n]*)/g, zb = /^(\r?\n)+/, Gb = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Hb = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Jb = /(\r?\n|^) *\* ?/g, Xb = [];
    function Yb(e) {
        const t = (0, Vb().default)(e) || Rb().EOL;
        e = e.replace(Wb, "").replace($b, "").replace(Jb, "$1");
        let n = "";
        for(; n !== e;)n = e, e = e.replace(Gb, "".concat(t, "$1 $2").concat(t));
        e = e.replace(zb, "").trimRight();
        const r = Object.create(null), o = e.replace(Hb, "").replace(zb, "").trimRight();
        let i;
        for(; i = Hb.exec(e);){
            const e = i[2].replace(Ub, "");
            "string" == typeof r[i[1]] || Array.isArray(r[i[1]]) ? r[i[1]] = Xb.concat(r[i[1]], e) : r[i[1]] = e;
        }
        return {
            comments: o,
            pragmas: r
        };
    }
    function Kb(e, t133) {
        return Xb.concat(t133).map((t)=>"@".concat(e, " ").concat(t).trim()
        );
    }
    const { parseWithComments: Qb , strip: Zb , extract: ev , print: tv  } = jb, { getShebang: nv  } = dc, { normalizeEndOfLine: rv  } = hc;
    function ov(e) {
        const t = nv(e);
        t && (e = e.slice(t.length + 1));
        const n = ev(e), { pragmas: r , comments: o  } = Qb(n);
        return {
            shebang: t,
            text: e,
            pragmas: r,
            comments: o
        };
    }
    var iv = {
        hasPragma: function(e) {
            const t = Object.keys(ov(e).pragmas);
            return t.includes("prettier") || t.includes("format");
        },
        insertPragma: function(e) {
            const { shebang: t , text: n , pragmas: r , comments: o  } = ov(e), i = Zb(n), u = tv({
                pragmas: Object.assign({
                    format: ""
                }, r),
                comments: o.trimStart()
            });
            return (t ? "".concat(t, "\n") : "") + rv(u) + (i.startsWith("\n") ? "\n" : "\n\n") + i;
        }
    };
    const { getLast: uv , hasNewline: sv , getNextNonSpaceNonCommentCharacterIndexWithStartIndex: av , getNextNonSpaceNonCommentCharacter: cv , hasNewlineInRange: lv , addLeadingComment: pv , addTrailingComment: fv , addDanglingComment: dv , getNextNonSpaceNonCommentCharacterIndex: hv , isNonEmptyArray: gv  } = dc, { isBlockComment: mv , getFunctionParameters: yv , isPrettierIgnoreComment: Dv , isJsxNode: Ev , hasFlowShorthandAnnotationComment: Cv , hasFlowAnnotationComment: bv , hasIgnoreComment: vv , isCallLikeExpression: Av , getCallArguments: Fv , isCallExpression: xv , isMemberExpression: Sv , isObjectProperty: wv , getComments: Tv , CommentCheckFlags: Bv  } = CC, { locStart: Nv , locEnd: kv  } = og;
    function Pv(e237, t134) {
        const n = (e237.body || e237.properties).find((e)=>{
            let { type: t  } = e;
            return "EmptyStatement" !== t;
        });
        n ? pv(n, t134) : dv(e237, t134);
    }
    function Ov(e, t) {
        "BlockStatement" === e.type ? Pv(e, t) : pv(e, t);
    }
    function Iv(e) {
        let { comment: t , followingNode: n  } = e;
        return !(!n || !cA(t)) && (pv(n, t), !0);
    }
    function Lv(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , followingNode: o , text: i  } = e;
        if (!r || "IfStatement" !== r.type || !o) return !1;
        return ")" === cv(i, t, kv) ? (fv(n, t), !0) : n === r.consequent && o === r.alternate ? ("BlockStatement" === n.type ? fv(n, t) : dv(r, t), !0) : "BlockStatement" === o.type ? (Pv(o, t), !0) : "IfStatement" === o.type ? (Ov(o.consequent, t), !0) : r.consequent === o && (pv(o, t), !0);
    }
    function jv(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , followingNode: o , text: i  } = e;
        if (!r || "WhileStatement" !== r.type || !o) return !1;
        return ")" === cv(i, t, kv) ? (fv(n, t), !0) : "BlockStatement" === o.type ? (Pv(o, t), !0) : r.body === o && (pv(o, t), !0);
    }
    function _v(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , followingNode: o  } = e;
        return !(!r || "TryStatement" !== r.type && "CatchClause" !== r.type || !o) && ("CatchClause" === r.type && n ? (fv(n, t), !0) : "BlockStatement" === o.type ? (Pv(o, t), !0) : "TryStatement" === o.type ? (Ov(o.finalizer, t), !0) : "CatchClause" === o.type && (Ov(o.body, t), !0));
    }
    function Mv(e) {
        let { comment: t , enclosingNode: n , followingNode: r  } = e;
        return !(!Sv(n) || !r || "Identifier" !== r.type) && (pv(n, t), !0);
    }
    function Rv(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , followingNode: o , text: i  } = e;
        const u = n && !lv(i, kv(n), Nv(t));
        return !(n && u || !r || "ConditionalExpression" !== r.type && "TSConditionalType" !== r.type || !o) && (pv(o, t), !0);
    }
    function Vv(e) {
        let { comment: t , precedingNode: n , enclosingNode: r  } = e;
        return !(!wv(r) || !r.shorthand || r.key !== n || "AssignmentPattern" !== r.value.type) && (fv(r.value.left, t), !0);
    }
    function $v(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , followingNode: o  } = e;
        if (r && ("ClassDeclaration" === r.type || "ClassExpression" === r.type || "DeclareClass" === r.type || "DeclareInterface" === r.type || "InterfaceDeclaration" === r.type || "TSInterfaceDeclaration" === r.type)) {
            if (gv(r.decorators) && (!o || "Decorator" !== o.type)) return fv(uv(r.decorators), t), !0;
            if (r.body && o === r.body) return Pv(r.body, t), !0;
            if (o) {
                for (const e of [
                    "implements",
                    "extends",
                    "mixins"
                ])if (r[e] && o === r[e][0]) return !n || n !== r.id && n !== r.typeParameters && n !== r.superClass ? dv(r, t, e) : fv(n, t), !0;
            }
        }
        return !1;
    }
    function Wv(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , text: o  } = e;
        return (r && n && ("Property" === r.type || "TSDeclareMethod" === r.type || "TSAbstractMethodDefinition" === r.type) && "Identifier" === n.type && r.key === n && ":" !== cv(o, n, kv) || !(!n || !r || "Decorator" !== n.type || "ClassMethod" !== r.type && "ClassProperty" !== r.type && "PropertyDefinition" !== r.type && "TSAbstractPropertyDefinition" !== r.type && "TSAbstractMethodDefinition" !== r.type && "TSDeclareMethod" !== r.type && "MethodDefinition" !== r.type)) && (fv(n, t), !0);
    }
    function qv(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , text: o  } = e;
        return "(" === cv(o, t, kv) && !(!n || !r || "FunctionDeclaration" !== r.type && "FunctionExpression" !== r.type && "ClassMethod" !== r.type && "MethodDefinition" !== r.type && "ObjectMethod" !== r.type) && (fv(n, t), !0);
    }
    function Uv(e) {
        let { comment: t , enclosingNode: n , text: r  } = e;
        if (!n || "ArrowFunctionExpression" !== n.type) return !1;
        const o = hv(r, t, kv);
        return !1 !== o && "=>" === r.slice(o, o + 2) && (dv(n, t), !0);
    }
    function zv(e) {
        let { comment: t , enclosingNode: n , text: r  } = e;
        return ")" === cv(r, t, kv) && (n && (aA(n) && 0 === yv(n).length || Av(n) && 0 === Fv(n).length) ? (dv(n, t), !0) : !(!n || "MethodDefinition" !== n.type && "TSAbstractMethodDefinition" !== n.type || 0 !== yv(n.value).length) && (dv(n.value, t), !0));
    }
    function Gv(e239) {
        let { comment: t135 , precedingNode: n , enclosingNode: r , followingNode: o , text: i  } = e239;
        if (n && "FunctionTypeParam" === n.type && r && "FunctionTypeAnnotation" === r.type && o && "FunctionTypeParam" !== o.type) return fv(n, t135), !0;
        if (n && ("Identifier" === n.type || "AssignmentPattern" === n.type) && r && aA(r) && ")" === cv(i, t135, kv)) return fv(n, t135), !0;
        if (r && "FunctionDeclaration" === r.type && o && "BlockStatement" === o.type) {
            const e238 = (()=>{
                const e = yv(r);
                if (e.length > 0) return av(i, kv(uv(e)));
                const t = av(i, kv(r.id));
                return !1 !== t && av(i, t + 1);
            })();
            if (Nv(t135) > e238) return Pv(o, t135), !0;
        }
        return !1;
    }
    function Hv(e) {
        let { comment: t , enclosingNode: n  } = e;
        return !(!n || "ImportSpecifier" !== n.type) && (pv(n, t), !0);
    }
    function Jv(e) {
        let { comment: t , enclosingNode: n  } = e;
        return !(!n || "LabeledStatement" !== n.type) && (pv(n, t), !0);
    }
    function Xv(e) {
        let { comment: t , enclosingNode: n  } = e;
        return !(!n || "ContinueStatement" !== n.type && "BreakStatement" !== n.type || n.label) && (fv(n, t), !0);
    }
    function Yv(e) {
        let { comment: t , precedingNode: n , enclosingNode: r  } = e;
        return !!(xv(r) && n && r.callee === n && r.arguments.length > 0) && (pv(r.arguments[0], t), !0);
    }
    function Kv(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , followingNode: o  } = e;
        return !r || "UnionTypeAnnotation" !== r.type && "TSUnionType" !== r.type ? (o && ("UnionTypeAnnotation" === o.type || "TSUnionType" === o.type) && Dv(t) && (o.types[0].prettierIgnore = !0, t.unignore = !0), !1) : (Dv(t) && (o.prettierIgnore = !0, t.unignore = !0), !!n && (fv(n, t), !0));
    }
    function Qv(e) {
        let { comment: t , enclosingNode: n  } = e;
        return !!wv(n) && (pv(n, t), !0);
    }
    function Zv(e) {
        let { comment: t , enclosingNode: n , followingNode: r , ast: o , isLastComment: i  } = e;
        return o && o.body && 0 === o.body.length ? (i ? dv(o, t) : pv(o, t), !0) : n && "Program" === n.type && 0 === n.body.length && !gv(n.directives) ? (i ? dv(n, t) : pv(n, t), !0) : !(!r || "Program" !== r.type || 0 !== r.body.length || !n || "ModuleExpression" !== n.type) && (dv(r, t), !0);
    }
    function eA(e) {
        let { comment: t , enclosingNode: n  } = e;
        return !(!n || "ForInStatement" !== n.type && "ForOfStatement" !== n.type) && (pv(n, t), !0);
    }
    function tA(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , text: o  } = e;
        return !!(n && "ImportSpecifier" === n.type && r && "ImportDeclaration" === r.type && sv(o, kv(t))) && (fv(n, t), !0);
    }
    function nA(e) {
        let { comment: t , enclosingNode: n  } = e;
        return !(!n || "AssignmentPattern" !== n.type) && (pv(n, t), !0);
    }
    function rA(e) {
        let { comment: t , enclosingNode: n  } = e;
        return !(!n || "TypeAlias" !== n.type) && (pv(n, t), !0);
    }
    function oA(e) {
        let { comment: t , enclosingNode: n , followingNode: r  } = e;
        return !(!n || "VariableDeclarator" !== n.type && "AssignmentExpression" !== n.type || !r || "ObjectExpression" !== r.type && "ArrayExpression" !== r.type && "TemplateLiteral" !== r.type && "TaggedTemplateExpression" !== r.type && !mv(t)) && (pv(r, t), !0);
    }
    function iA(e) {
        let { comment: t , enclosingNode: n , followingNode: r , text: o  } = e;
        return !(r || !n || "TSMethodSignature" !== n.type && "TSDeclareFunction" !== n.type && "TSAbstractMethodDefinition" !== n.type || ";" !== cv(o, t, kv)) && (fv(n, t), !0);
    }
    function uA(e) {
        let { comment: t , enclosingNode: n , followingNode: r  } = e;
        if (Dv(t) && n && "TSMappedType" === n.type && r && "TSTypeParameter" === r.type && r.constraint) return n.prettierIgnore = !0, t.unignore = !0, !0;
    }
    function sA(e) {
        let { comment: t , precedingNode: n , enclosingNode: r , followingNode: o  } = e;
        return !(!r || "TSMappedType" !== r.type) && (o && "TSTypeParameter" === o.type && o.name ? (pv(o.name, t), !0) : !(!n || "TSTypeParameter" !== n.type || !n.constraint) && (fv(n.constraint, t), !0));
    }
    function aA(e) {
        return "ArrowFunctionExpression" === e.type || "FunctionExpression" === e.type || "FunctionDeclaration" === e.type || "ObjectMethod" === e.type || "ClassMethod" === e.type || "TSDeclareFunction" === e.type || "TSCallSignatureDeclaration" === e.type || "TSConstructSignatureDeclaration" === e.type || "TSMethodSignature" === e.type || "TSConstructorType" === e.type || "TSFunctionType" === e.type || "TSDeclareMethod" === e.type;
    }
    function cA(e) {
        return mv(e) && "*" === e.value[0] && /@type\b/.test(e.value);
    }
    var lA = {
        handleOwnLineComment: function(e) {
            return [
                uA,
                Gv,
                Mv,
                Lv,
                jv,
                _v,
                $v,
                Hv,
                eA,
                Kv,
                Zv,
                tA,
                nA,
                Wv,
                Jv
            ].some((t)=>t(e)
            );
        },
        handleEndOfLineComment: function(e) {
            return [
                Iv,
                Gv,
                Rv,
                Hv,
                Lv,
                jv,
                _v,
                $v,
                Jv,
                Yv,
                Qv,
                Zv,
                rA,
                oA
            ].some((t)=>t(e)
            );
        },
        handleRemainingComment: function(e) {
            return [
                uA,
                Lv,
                jv,
                Vv,
                zv,
                Wv,
                Zv,
                Uv,
                qv,
                sA,
                Xv,
                iA
            ].some((t)=>t(e)
            );
        },
        isTypeCastComment: cA,
        getCommentChildNodes: function(e, t) {
            if (("typescript" === t.parser || "flow" === t.parser || "espree" === t.parser || "meriyah" === t.parser || "__babel_estree" === t.parser) && "MethodDefinition" === e.type && e.value && "FunctionExpression" === e.value.type && 0 === yv(e.value).length && !e.value.returnType && !gv(e.value.typeParameters) && e.value.body) return [
                ...e.decorators || [],
                e.key,
                e.value.body
            ];
        },
        willPrintOwnComments: function(e240) {
            const t = e240.getValue(), n = e240.getParentNode();
            return (t && (Ev(t) || Cv(t) || xv(n) && ((e)=>bv(Tv(e, Bv.Leading)) || bv(Tv(e, Bv.Trailing))
            )(t)) || n && ("JSXSpreadAttribute" === n.type || "JSXSpreadChild" === n.type || "UnionTypeAnnotation" === n.type || "TSUnionType" === n.type || ("ClassDeclaration" === n.type || "ClassExpression" === n.type) && n.superClass === t)) && (!vv(e240) || "UnionTypeAnnotation" === n.type || "TSUnionType" === n.type);
        }
    };
    const pA = au, { getFunctionParameters: fA , getLeftSidePathName: dA , hasFlowShorthandAnnotationComment: hA , hasNakedLeftSide: gA , hasNode: mA , isBitwiseOperator: yA , startsWithNoLookaheadToken: DA , shouldFlatten: EA , getPrecedence: CA , isCallExpression: bA , isMemberExpression: vA , isObjectProperty: AA  } = CC;
    function FA(e241, t136) {
        const n63 = e241.getParentNode();
        if (!n63) return !1;
        const r49 = e241.getName(), o = e241.getNode();
        if (t136.__isInHtmlInterpolation && !t136.bracketSpacing && (function(e) {
            if ("ObjectExpression" === e.type) return !0;
            return !1;
        })(o) && xA(e241)) return !0;
        if ((function(e) {
            return "BlockStatement" === e.type || "BreakStatement" === e.type || "ClassBody" === e.type || "ClassDeclaration" === e.type || "ClassMethod" === e.type || "ClassProperty" === e.type || "PropertyDefinition" === e.type || "ClassPrivateProperty" === e.type || "ContinueStatement" === e.type || "DebuggerStatement" === e.type || "DeclareClass" === e.type || "DeclareExportAllDeclaration" === e.type || "DeclareExportDeclaration" === e.type || "DeclareFunction" === e.type || "DeclareInterface" === e.type || "DeclareModule" === e.type || "DeclareModuleExports" === e.type || "DeclareVariable" === e.type || "DoWhileStatement" === e.type || "EnumDeclaration" === e.type || "ExportAllDeclaration" === e.type || "ExportDefaultDeclaration" === e.type || "ExportNamedDeclaration" === e.type || "ExpressionStatement" === e.type || "ForInStatement" === e.type || "ForOfStatement" === e.type || "ForStatement" === e.type || "FunctionDeclaration" === e.type || "IfStatement" === e.type || "ImportDeclaration" === e.type || "InterfaceDeclaration" === e.type || "LabeledStatement" === e.type || "MethodDefinition" === e.type || "ReturnStatement" === e.type || "SwitchStatement" === e.type || "ThrowStatement" === e.type || "TryStatement" === e.type || "TSDeclareFunction" === e.type || "TSEnumDeclaration" === e.type || "TSImportEqualsDeclaration" === e.type || "TSInterfaceDeclaration" === e.type || "TSModuleDeclaration" === e.type || "TSNamespaceExportDeclaration" === e.type || "TypeAlias" === e.type || "VariableDeclaration" === e.type || "WhileStatement" === e.type || "WithStatement" === e.type;
        })(o)) return !1;
        if ("flow" !== t136.parser && hA(e241.getValue())) return !0;
        if ("Identifier" === o.type) return !!(o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name)) || "left" === r49 && "async" === o.name && "ForOfStatement" === n63.type && !n63.await;
        switch(n63.type){
            case "ParenthesizedExpression":
                return !1;
            case "ClassDeclaration":
            case "ClassExpression":
                if ("superClass" === r49 && ("ArrowFunctionExpression" === o.type || "AssignmentExpression" === o.type || "AwaitExpression" === o.type || "BinaryExpression" === o.type || "ConditionalExpression" === o.type || "LogicalExpression" === o.type || "NewExpression" === o.type || "ObjectExpression" === o.type || "ParenthesizedExpression" === o.type || "SequenceExpression" === o.type || "TaggedTemplateExpression" === o.type || "UnaryExpression" === o.type || "UpdateExpression" === o.type || "YieldExpression" === o.type || "TSNonNullExpression" === o.type)) return !0;
                break;
            case "ExportDefaultDeclaration":
                return SA(e241, t136) || "SequenceExpression" === o.type;
            case "Decorator":
                if ("expression" === r49) {
                    let e = !1, n = !1, r = o;
                    for(; r;)switch(r.type){
                        case "MemberExpression":
                            n = !0, r = r.object;
                            break;
                        case "CallExpression":
                            if (n || e) return "typescript" !== t136.parser;
                            e = !0, r = r.callee;
                            break;
                        case "Identifier":
                            return !1;
                        case "TaggedTemplateExpression":
                            return "typescript" !== t136.parser;
                        default:
                            return !0;
                    }
                    return !0;
                }
                break;
            case "ExpressionStatement":
                if (DA(o, !0)) return !0;
                break;
            case "ArrowFunctionExpression":
                if ("body" === r49 && "SequenceExpression" !== o.type && DA(o, !1)) return !0;
        }
        switch(o.type){
            case "UpdateExpression":
                if ("UnaryExpression" === n63.type) return o.prefix && ("++" === o.operator && "+" === n63.operator || "--" === o.operator && "-" === n63.operator);
            case "UnaryExpression":
                switch(n63.type){
                    case "UnaryExpression":
                        return o.operator === n63.operator && ("+" === o.operator || "-" === o.operator);
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "TSNonNullExpression":
                        return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                        return "object" === r49;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                        return "callee" === r49;
                    case "BinaryExpression":
                        return "left" === r49 && "**" === n63.operator;
                    default:
                        return !1;
                }
            case "BinaryExpression":
                if ("UpdateExpression" === n63.type) return !0;
                if ("in" === o.operator && (function(e) {
                    let t = 0, n = e.getValue();
                    for(; n;){
                        const r = e.getParentNode(t++);
                        if (r && "ForStatement" === r.type && r.init === n) return !0;
                        n = r;
                    }
                    return !1;
                })(e241)) return !0;
                if ("|>" === o.operator && o.extra && o.extra.parenthesized) {
                    const t = e241.getParentNode(1);
                    if ("BinaryExpression" === t.type && "|>" === t.operator) return !0;
                }
            case "TSTypeAssertion":
            case "TSAsExpression":
            case "LogicalExpression":
                switch(n63.type){
                    case "TSAsExpression":
                        return "TSAsExpression" !== o.type;
                    case "ConditionalExpression":
                        return "TSAsExpression" === o.type;
                    case "CallExpression":
                    case "NewExpression":
                    case "OptionalCallExpression":
                        return "callee" === r49;
                    case "ClassExpression":
                    case "ClassDeclaration":
                        return "superClass" === r49;
                    case "TSTypeAssertion":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "JSXSpreadAttribute":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BindExpression":
                    case "AwaitExpression":
                    case "TSNonNullExpression":
                    case "UpdateExpression":
                        return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                        return "object" === r49;
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                        return "left" === r49 && ("TSTypeAssertion" === o.type || "TSAsExpression" === o.type);
                    case "LogicalExpression":
                        if ("LogicalExpression" === o.type) return n63.operator !== o.operator;
                    case "BinaryExpression":
                        {
                            const { operator: e , type: t  } = o;
                            if (!e && "TSTypeAssertion" !== t) return !0;
                            const i = CA(e), u = n63.operator, s = CA(u);
                            return s > i || "right" === r49 && s === i || s === i && !EA(u, e) || (s < i && "%" === e ? "+" === u || "-" === u : !!yA(u));
                        }
                    default:
                        return !1;
                }
            case "SequenceExpression":
                switch(n63.type){
                    case "ReturnStatement":
                    case "ForStatement":
                        return !1;
                    case "ExpressionStatement":
                        return "expression" !== r49;
                    case "ArrowFunctionExpression":
                        return "body" !== r49;
                    default:
                        return !0;
                }
            case "YieldExpression":
                if ("UnaryExpression" === n63.type || "AwaitExpression" === n63.type || "TSAsExpression" === n63.type || "TSNonNullExpression" === n63.type) return !0;
            case "AwaitExpression":
                switch(n63.type){
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                        return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                        return "object" === r49;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                        return "callee" === r49;
                    case "ConditionalExpression":
                        return "test" === r49;
                    case "BinaryExpression":
                        return !(!o.argument && "|>" === n63.operator);
                    default:
                        return !1;
                }
            case "TSConditionalType":
                if ("extendsType" === r49 && "TSConditionalType" === n63.type) return !0;
            case "TSFunctionType":
            case "TSConstructorType":
                if ("checkType" === r49 && "TSConditionalType" === n63.type) return !0;
            case "TSUnionType":
            case "TSIntersectionType":
                if (("TSUnionType" === n63.type || "TSIntersectionType" === n63.type) && n63.types.length > 1 && (!o.types || o.types.length > 1)) return !0;
            case "TSInferType":
                if ("TSInferType" === o.type && "TSRestType" === n63.type) return !1;
            case "TSTypeOperator":
                return "TSArrayType" === n63.type || "TSOptionalType" === n63.type || "TSRestType" === n63.type || "objectType" === r49 && "TSIndexedAccessType" === n63.type || "TSTypeOperator" === n63.type || "TSTypeAnnotation" === n63.type && e241.getParentNode(1).type.startsWith("TSJSDoc");
            case "ArrayTypeAnnotation":
                return "NullableTypeAnnotation" === n63.type;
            case "IntersectionTypeAnnotation":
            case "UnionTypeAnnotation":
                return "ArrayTypeAnnotation" === n63.type || "NullableTypeAnnotation" === n63.type || "IntersectionTypeAnnotation" === n63.type || "UnionTypeAnnotation" === n63.type || "objectType" === r49 && ("IndexedAccessType" === n63.type || "OptionalIndexedAccessType" === n63.type);
            case "NullableTypeAnnotation":
                return "ArrayTypeAnnotation" === n63.type || "objectType" === r49 && ("IndexedAccessType" === n63.type || "OptionalIndexedAccessType" === n63.type);
            case "FunctionTypeAnnotation":
                {
                    const t = "NullableTypeAnnotation" === n63.type ? e241.getParentNode(1) : n63;
                    return "UnionTypeAnnotation" === t.type || "IntersectionTypeAnnotation" === t.type || "ArrayTypeAnnotation" === t.type || "objectType" === r49 && ("IndexedAccessType" === t.type || "OptionalIndexedAccessType" === t.type) || "NullableTypeAnnotation" === t.type || "FunctionTypeParam" === n63.type && null === n63.name && fA(o).some((e)=>e.typeAnnotation && "NullableTypeAnnotation" === e.typeAnnotation.type
                    );
                }
            case "OptionalIndexedAccessType":
                return "objectType" === r49 && "IndexedAccessType" === n63.type;
            case "TypeofTypeAnnotation":
                return "objectType" === r49 && ("IndexedAccessType" === n63.type || "OptionalIndexedAccessType" === n63.type);
            case "StringLiteral":
            case "NumericLiteral":
            case "Literal":
                if ("string" == typeof o.value && "ExpressionStatement" === n63.type && !n63.directive) {
                    const t = e241.getParentNode(1);
                    return "Program" === t.type || "BlockStatement" === t.type;
                }
                return "object" === r49 && "MemberExpression" === n63.type && "number" == typeof o.value;
            case "AssignmentExpression":
                {
                    const t = e241.getParentNode(1);
                    return "body" === r49 && "ArrowFunctionExpression" === n63.type || ("key" !== r49 || "ClassProperty" !== n63.type && "PropertyDefinition" !== n63.type || !n63.computed) && ("init" !== r49 && "update" !== r49 || "ForStatement" !== n63.type) && ("ExpressionStatement" === n63.type ? "ObjectPattern" === o.left.type : ("key" !== r49 || "TSPropertySignature" !== n63.type) && "AssignmentExpression" !== n63.type && ("SequenceExpression" !== n63.type || !t || "ForStatement" !== t.type || t.init !== n63 && t.update !== n63) && ("value" !== r49 || "Property" !== n63.type || !t || "ObjectPattern" !== t.type || !t.properties.includes(n63)) && "NGChainedExpression" !== n63.type);
                }
            case "ConditionalExpression":
                switch(n63.type){
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression":
                    case "ExportDefaultDeclaration":
                    case "AwaitExpression":
                    case "JSXSpreadAttribute":
                    case "TSTypeAssertion":
                    case "TypeCastExpression":
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                        return !0;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                        return "callee" === r49;
                    case "ConditionalExpression":
                        return "test" === r49;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                        return "object" === r49;
                    default:
                        return !1;
                }
            case "FunctionExpression":
                switch(n63.type){
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                        return "callee" === r49;
                    case "TaggedTemplateExpression":
                        return !0;
                    default:
                        return !1;
                }
            case "ArrowFunctionExpression":
                switch(n63.type){
                    case "BinaryExpression":
                        return "|>" !== n63.operator || o.extra && o.extra.parenthesized;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                        return "callee" === r49;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                        return "object" === r49;
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "AwaitExpression":
                    case "TSTypeAssertion":
                        return !0;
                    case "ConditionalExpression":
                        return "test" === r49;
                    default:
                        return !1;
                }
            case "ClassExpression":
                return "NewExpression" === n63.type && "callee" === r49;
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
                {
                    const t = e241.getParentNode(1);
                    if ("object" === r49 && "MemberExpression" === n63.type || "callee" === r49 && ("CallExpression" === n63.type || "NewExpression" === n63.type) || "TSNonNullExpression" === n63.type && "MemberExpression" === t.type && t.object === n63) return !0;
                }
            case "CallExpression":
            case "MemberExpression":
            case "TaggedTemplateExpression":
            case "TSNonNullExpression":
                if ("callee" === r49 && ("BindExpression" === n63.type || "NewExpression" === n63.type)) {
                    let e = o;
                    for(; e;)switch(e.type){
                        case "CallExpression":
                        case "OptionalCallExpression":
                            return !0;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "BindExpression":
                            e = e.object;
                            break;
                        case "TaggedTemplateExpression":
                            e = e.tag;
                            break;
                        case "TSNonNullExpression":
                            e = e.expression;
                            break;
                        default:
                            return !1;
                    }
                }
                return !1;
            case "BindExpression":
                return "callee" === r49 && ("BindExpression" === n63.type || "NewExpression" === n63.type) || "object" === r49 && vA(n63);
            case "NGPipeExpression":
                return !("NGRoot" === n63.type || "NGMicrosyntaxExpression" === n63.type || "ObjectProperty" === n63.type && (!o.extra || !o.extra.parenthesized) || "ArrayExpression" === n63.type || bA(n63) && n63.arguments[r49] === o || "right" === r49 && "NGPipeExpression" === n63.type || "property" === r49 && "MemberExpression" === n63.type || "AssignmentExpression" === n63.type);
            case "JSXFragment":
            case "JSXElement":
                return "callee" === r49 || "left" === r49 && "BinaryExpression" === n63.type && "<" === n63.operator || "ArrayExpression" !== n63.type && "ArrowFunctionExpression" !== n63.type && "AssignmentExpression" !== n63.type && "AssignmentPattern" !== n63.type && "BinaryExpression" !== n63.type && "NewExpression" !== n63.type && "ConditionalExpression" !== n63.type && "ExpressionStatement" !== n63.type && "JsExpressionRoot" !== n63.type && "JSXAttribute" !== n63.type && "JSXElement" !== n63.type && "JSXExpressionContainer" !== n63.type && "JSXFragment" !== n63.type && "LogicalExpression" !== n63.type && !bA(n63) && !AA(n63) && "ReturnStatement" !== n63.type && "ThrowStatement" !== n63.type && "TypeCastExpression" !== n63.type && "VariableDeclarator" !== n63.type && "YieldExpression" !== n63.type;
            case "TypeAnnotation":
                return "returnType" === r49 && "ArrowFunctionExpression" === n63.type && (function(e242) {
                    return mA(e242, (e243)=>"ObjectTypeAnnotation" === e243.type && mA(e243, (e)=>"FunctionTypeAnnotation" === e.type || void 0
                        ) || void 0
                    );
                })(o);
        }
        return !1;
    }
    function xA(e) {
        const t = e.getValue(), n = e.getParentNode(), r = e.getName();
        switch(n.type){
            case "NGPipeExpression":
                if ("number" == typeof r && n.arguments[r] === t && n.arguments.length - 1 === r) return e.callParent(xA);
                break;
            case "ObjectProperty":
                if ("value" === r) {
                    const t = e.getParentNode(1);
                    return pA(t.properties) === n;
                }
                break;
            case "BinaryExpression":
            case "LogicalExpression":
                if ("right" === r) return e.callParent(xA);
                break;
            case "ConditionalExpression":
                if ("alternate" === r) return e.callParent(xA);
                break;
            case "UnaryExpression":
                if (n.prefix) return e.callParent(xA);
        }
        return !1;
    }
    function SA(e244, t) {
        const n = e244.getValue(), r = e244.getParentNode();
        return "FunctionExpression" === n.type || "ClassExpression" === n.type ? "ExportDefaultDeclaration" === r.type || !FA(e244, t) : !(!gA(n) || "ExportDefaultDeclaration" !== r.type && FA(e244, t)) && e244.call((e)=>SA(e, t)
        , ...dA(e244, n));
    }
    var wA = FA;
    var TA = function(e, t) {
        switch(t.parser){
            case "json":
            case "json5":
            case "json-stringify":
            case "__js_expression":
            case "__vue_expression":
                return Object.assign(Object.assign({
                }, e), {
                }, {
                    type: t.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
                    node: e,
                    comments: [],
                    rootMarker: t.rootMarker
                });
            default:
                return e;
        }
    };
    const { builders: { join: BA , line: NA , group: kA , softline: PA , indent: OA  }  } = Zc;
    var IA = {
        isVueEventBindingExpression: function e(t) {
            switch(t.type){
                case "MemberExpression":
                    switch(t.property.type){
                        case "Identifier":
                        case "NumericLiteral":
                        case "StringLiteral":
                            return e(t.object);
                    }
                    return !1;
                case "Identifier":
                    return !0;
                default:
                    return !1;
            }
        },
        printHtmlBinding: function(e245, t137, n) {
            const r50 = e245.getValue();
            if (t137.__onHtmlBindingRoot && null === e245.getName() && t137.__onHtmlBindingRoot(r50, t137), "File" === r50.type) return t137.__isVueForBindingLeft ? e245.call((e)=>{
                const t = BA([
                    ",",
                    NA
                ], e.map(n, "params")), { params: r  } = e.getValue();
                return 1 === r.length ? t : [
                    "(",
                    OA([
                        PA,
                        kA(t)
                    ]),
                    PA,
                    ")"
                ];
            }, "program", "body", 0) : t137.__isVueBindings ? e245.call((e)=>BA([
                    ",",
                    NA
                ], e.map(n, "params"))
            , "program", "body", 0) : void 0;
        }
    };
    const { printComments: LA  } = tD, { getLast: jA  } = dc, { builders: { join: _A , line: MA , softline: RA , group: VA , indent: $A , align: WA , ifBreak: qA , indentIfBreak: UA  } , utils: { cleanDoc: zA , getDocParts: GA , isConcat: HA  }  } = Zc, { hasLeadingOwnLineComment: JA , isBinaryish: XA , isJsxNode: YA , shouldFlatten: KA , hasComment: QA , CommentCheckFlags: ZA , isCallExpression: eF , isMemberExpression: tF , isObjectProperty: nF , isEnabledHackPipeline: rF  } = CC;
    let oF = 0;
    function iF(e246, t, n, r, o) {
        const i = e246.getValue();
        if (!XA(i)) return [
            VA(t())
        ];
        let u = [];
        KA(i.operator, i.left.operator) ? u = e246.call((e)=>iF(e, t, n, !0, o)
        , "left") : u.push(VA(t("left")));
        const s = uF(i), a = ("|>" === i.operator || "NGPipeExpression" === i.type || "|" === i.operator && "__vue_expression" === n.parser) && !JA(n.originalText, i.right), c = "NGPipeExpression" === i.type ? "|" : i.operator, l = "NGPipeExpression" === i.type && i.arguments.length > 0 ? VA($A([
            RA,
            ": ",
            _A([
                RA,
                ":",
                qA(" ")
            ], e246.map(t, "arguments").map((e)=>WA(2, VA(e))
            ))
        ])) : "";
        let p;
        if (s) p = [
            c,
            " ",
            t("right"),
            l
        ];
        else {
            const r = rF(n) && "|>" === c ? e246.call((e)=>iF(e, t, n, !0, o)
            , "right") : t("right");
            p = [
                a ? MA : "",
                c,
                a ? " " : MA,
                r,
                l
            ];
        }
        const f = e246.getParentNode(), d = QA(i.left, ZA.Trailing | ZA.Line), h = d || !(o && "LogicalExpression" === i.type) && f.type !== i.type && i.left.type !== i.type && i.right.type !== i.type;
        if (u.push(a ? "" : " ", h ? VA(p, {
            shouldBreak: d
        }) : p), r && QA(i)) {
            const t = zA(LA(e246, u, n));
            return HA(t) || "fill" === t.type ? GA(t) : [
                t
            ];
        }
        return u;
    }
    function uF(e) {
        return "LogicalExpression" === e.type && ("ObjectExpression" === e.right.type && e.right.properties.length > 0 || "ArrayExpression" === e.right.type && e.right.elements.length > 0 || !!YA(e.right));
    }
    var sF = {
        printBinaryishExpression: function(e247, t, n) {
            const r = e247.getValue(), o = e247.getParentNode(), i = e247.getParentNode(1), u = r !== o.body && ("IfStatement" === o.type || "WhileStatement" === o.type || "SwitchStatement" === o.type || "DoWhileStatement" === o.type), s = rF(t) && "|>" === r.operator, a = iF(e247, n, t, !1, u);
            if (u) return a;
            if (s) return VA(a);
            if (eF(o) && o.callee === r || "UnaryExpression" === o.type || tF(o) && !o.computed) return VA([
                $A([
                    RA,
                    ...a
                ]),
                RA
            ]);
            const c = "ReturnStatement" === o.type || "ThrowStatement" === o.type || "JSXExpressionContainer" === o.type && "JSXAttribute" === i.type || "|" !== r.operator && "JsExpressionRoot" === o.type || "NGPipeExpression" !== r.type && ("NGRoot" === o.type && "__ng_binding" === t.parser || "NGMicrosyntaxExpression" === o.type && "NGMicrosyntax" === i.type && 1 === i.body.length) || r === o.body && "ArrowFunctionExpression" === o.type || r !== o.body && "ForStatement" === o.type || "ConditionalExpression" === o.type && "ReturnStatement" !== i.type && "ThrowStatement" !== i.type && !eF(i) || "TemplateLiteral" === o.type, l = "AssignmentExpression" === o.type || "VariableDeclarator" === o.type || "ClassProperty" === o.type || "PropertyDefinition" === o.type || "TSAbstractPropertyDefinition" === o.type || "ClassPrivateProperty" === o.type || nF(o), p = XA(r.left) && KA(r.operator, r.left.operator);
            if (c || uF(r) && !p || !uF(r) && l) return VA(a);
            if (0 === a.length) return "";
            const f = YA(r.right), d = a.findIndex((e)=>"string" != typeof e && !Array.isArray(e) && "group" === e.type
            ), h = a.slice(0, -1 === d ? 1 : d + 1), g = a.slice(h.length, f ? -1 : void 0), m = Symbol("logicalChain-" + ++oF), y = VA([
                ...h,
                $A(g)
            ], {
                id: m
            });
            if (!f) return y;
            const D = jA(a);
            return VA([
                y,
                UA(D, {
                    groupId: m
                })
            ]);
        },
        shouldInlineLogicalExpression: uF
    };
    const { builders: { join: aF , line: cF , group: lF  }  } = Zc, { hasNode: pF , hasComment: fF , getComments: dF  } = CC, { printBinaryishExpression: hF  } = sF;
    function gF(e, t, n) {
        return "NGMicrosyntaxKeyedExpression" === e.type && "of" === e.key.name && 1 === t && "NGMicrosyntaxLet" === n.body[0].type && null === n.body[0].value;
    }
    var mF = {
        printAngular: function(e248, t138, n) {
            const r = e248.getValue();
            if (r.type.startsWith("NG")) switch(r.type){
                case "NGRoot":
                    return [
                        n("node"),
                        fF(r.node) ? " //" + dF(r.node)[0].value.trimEnd() : ""
                    ];
                case "NGPipeExpression":
                    return hF(e248, t138, n);
                case "NGChainedExpression":
                    return lF(aF([
                        ";",
                        cF
                    ], e248.map((e249)=>(function(e250) {
                            return pF(e250.getValue(), (e)=>{
                                switch(e.type){
                                    case void 0:
                                        return !1;
                                    case "CallExpression":
                                    case "OptionalCallExpression":
                                    case "AssignmentExpression":
                                        return !0;
                                }
                            });
                        })(e249) ? n() : [
                            "(",
                            n(),
                            ")"
                        ]
                    , "expressions")));
                case "NGEmptyExpression":
                    return "";
                case "NGQuotedExpression":
                    return [
                        r.prefix,
                        ": ",
                        r.value.trim()
                    ];
                case "NGMicrosyntax":
                    return e248.map((e, t)=>[
                            0 === t ? "" : gF(e.getValue(), t, r) ? " " : [
                                ";",
                                cF
                            ],
                            n()
                        ]
                    , "body");
                case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r.name) ? r.name : JSON.stringify(r.name);
                case "NGMicrosyntaxExpression":
                    return [
                        n("expression"),
                        null === r.alias ? "" : [
                            " as ",
                            n("alias")
                        ]
                    ];
                case "NGMicrosyntaxKeyedExpression":
                    {
                        const t = e248.getName(), o = e248.getParentNode(), i = gF(r, t, o) || (1 === t && ("then" === r.key.name || "else" === r.key.name) || 2 === t && "else" === r.key.name && "NGMicrosyntaxKeyedExpression" === o.body[t - 1].type && "then" === o.body[t - 1].key.name) && "NGMicrosyntaxExpression" === o.body[0].type;
                        return [
                            n("key"),
                            i ? " " : ": ",
                            n("expression")
                        ];
                    }
                case "NGMicrosyntaxLet":
                    return [
                        "let ",
                        n("key"),
                        null === r.value ? "" : [
                            " = ",
                            n("value")
                        ]
                    ];
                case "NGMicrosyntaxAs":
                    return [
                        n("key"),
                        " as ",
                        n("alias")
                    ];
                default:
                    throw new Error("Unknown Angular node type: ".concat(JSON.stringify(r.type), "."));
            }
        }
    };
    const { printComments: yF , printDanglingComments: DF  } = tD, { builders: { line: EF , hardline: CF , softline: bF , group: vF , indent: AF , conditionalGroup: FF , fill: xF , ifBreak: SF , lineSuffixBoundary: wF , join: TF  } , utils: { willBreak: BF  }  } = Zc, { getLast: NF , getPreferredQuote: kF  } = dc, { isJsxNode: PF , rawText: OF , isLiteral: IF , isCallExpression: LF , isStringLiteral: jF , isBinaryish: _F , hasComment: MF , CommentCheckFlags: RF , hasNodeIgnoreComment: VF  } = CC, $F = wA, { willPrintOwnComments: WF  } = lA, qF = (e)=>"" === e || e === EF || e === CF || e === bF
    ;
    function UF(e253, t140, n64) {
        const r51 = e253.getValue();
        if ("JSXElement" === r51.type && (function(e) {
            if (0 === e.children.length) return !0;
            if (e.children.length > 1) return !1;
            const t = e.children[0];
            return IF(t) && !QF(t);
        })(r51)) return [
            n64("openingElement"),
            n64("closingElement")
        ];
        const o32 = "JSXElement" === r51.type ? n64("openingElement") : n64("openingFragment"), i20 = "JSXElement" === r51.type ? n64("closingElement") : n64("closingFragment");
        if (1 === r51.children.length && "JSXExpressionContainer" === r51.children[0].type && ("TemplateLiteral" === r51.children[0].expression.type || "TaggedTemplateExpression" === r51.children[0].expression.type)) return [
            o32,
            ...e253.map(n64, "children"),
            i20
        ];
        r51.children = r51.children.map((e254)=>(function(e) {
                return "JSXExpressionContainer" === e.type && IF(e.expression) && " " === e.expression.value && !MF(e.expression);
            })(e254) ? {
                type: "JSXText",
                value: " ",
                raw: " "
            } : e254
        );
        const u16 = r51.children.some(PF), s11 = r51.children.filter((e)=>"JSXExpressionContainer" === e.type
        ).length > 1, a7 = "JSXElement" === r51.type && r51.openingElement.attributes.length > 1;
        let c = BF(o32) || u16 || a7 || s11;
        const l = "mdx" === e253.getParentNode().rootMarker, p = t140.singleQuote ? "{' '}" : '{" "}', f = l ? " " : SF([
            p,
            bF
        ], " "), d = function(e255, t141, n65, r52, o) {
            const i = [];
            return e255.each((e, t, u)=>{
                const s = e.getValue();
                if (IF(s)) {
                    const e = OF(s);
                    if (QF(s)) {
                        const n = e.split(XF);
                        if ("" === n[0]) {
                            if (i.push(""), n.shift(), /\n/.test(n[0])) {
                                const e = u[t + 1];
                                i.push(GF(o, n[1], s, e));
                            } else i.push(r52);
                            n.shift();
                        }
                        let a;
                        if ("" === NF(n) && (n.pop(), a = n.pop()), 0 === n.length) return;
                        for (const [e256, t] of n.entries())e256 % 2 == 1 ? i.push(EF) : i.push(t);
                        if (void 0 !== a) {
                            if (/\n/.test(a)) {
                                const e = u[t + 1];
                                i.push(GF(o, NF(i), s, e));
                            } else i.push(r52);
                        } else {
                            const e = u[t + 1];
                            i.push(zF(o, NF(i), s, e));
                        }
                    } else /\n/.test(e) ? e.match(/\n/g).length > 1 && i.push("", CF) : i.push("", r52);
                } else {
                    const e = n65();
                    i.push(e);
                    const r = u[t + 1];
                    if (r && QF(r)) {
                        const e = KF(OF(r)).split(XF)[0];
                        i.push(zF(o, e, s, r));
                    } else i.push(CF);
                }
            }, "children"), i;
        }(e253, 0, n64, f, r51.openingElement && r51.openingElement.name && "fbt" === r51.openingElement.name.name), h = r51.children.some((e)=>QF(e)
        );
        for(let e251 = d.length - 2; e251 >= 0; e251--){
            const t = "" === d[e251] && "" === d[e251 + 1], n = d[e251] === CF && "" === d[e251 + 1] && d[e251 + 2] === CF, r = (d[e251] === bF || d[e251] === CF) && "" === d[e251 + 1] && d[e251 + 2] === f, o = d[e251] === f && "" === d[e251 + 1] && (d[e251 + 2] === bF || d[e251 + 2] === CF), i = d[e251] === f && "" === d[e251 + 1] && d[e251 + 2] === f, u = d[e251] === bF && "" === d[e251 + 1] && d[e251 + 2] === CF || d[e251] === CF && "" === d[e251 + 1] && d[e251 + 2] === bF;
            n && h || t || r || i || u ? d.splice(e251, 2) : o && d.splice(e251 + 1, 2);
        }
        for(; d.length > 0 && qF(NF(d));)d.pop();
        for(; d.length > 1 && qF(d[0]) && qF(d[1]);)d.shift(), d.shift();
        const g = [];
        for (const [e252, t139] of d.entries()){
            if (t139 === f) {
                if (1 === e252 && "" === d[e252 - 1]) {
                    if (2 === d.length) {
                        g.push(p);
                        continue;
                    }
                    g.push([
                        p,
                        CF
                    ]);
                    continue;
                }
                if (e252 === d.length - 1) {
                    g.push(p);
                    continue;
                }
                if ("" === d[e252 - 1] && d[e252 - 2] === CF) {
                    g.push(p);
                    continue;
                }
            }
            g.push(t139), BF(t139) && (c = !0);
        }
        const m = h ? xF(g) : vF(g, {
            shouldBreak: !0
        });
        if (l) return m;
        const y = vF([
            o32,
            AF([
                CF,
                m
            ]),
            CF,
            i20
        ]);
        return c ? y : FF([
            vF([
                o32,
                ...d,
                i20
            ]),
            y
        ]);
    }
    function zF(e, t, n, r) {
        return e ? "" : "JSXElement" === n.type && !n.closingElement || r && "JSXElement" === r.type && !r.closingElement ? 1 === t.length ? bF : CF : bF;
    }
    function GF(e, t, n, r) {
        return e ? CF : 1 === t.length ? "JSXElement" === n.type && !n.closingElement || r && "JSXElement" === r.type && !r.closingElement ? CF : bF : CF;
    }
    function HF(e257, t142, n66) {
        return (function(e258, t, n) {
            const r = e258.getParentNode();
            if (!r) return t;
            if (({
                ArrayExpression: !0,
                JSXAttribute: !0,
                JSXElement: !0,
                JSXExpressionContainer: !0,
                JSXFragment: !0,
                ExpressionStatement: !0,
                CallExpression: !0,
                OptionalCallExpression: !0,
                ConditionalExpression: !0,
                JsExpressionRoot: !0
            })[r.type]) return t;
            const o = e258.match(void 0, (e)=>"ArrowFunctionExpression" === e.type
            , LF, (e)=>"JSXExpressionContainer" === e.type
            ), i = $F(e258, n);
            return vF([
                i ? "" : SF("("),
                AF([
                    bF,
                    t
                ]),
                bF,
                i ? "" : SF(")")
            ], {
                shouldBreak: o
            });
        })(e257, yF(e257, UF(e257, t142, n66), t142), t142);
    }
    function JF(e259, t, n) {
        const r53 = e259.getValue();
        return [
            "{",
            e259.call((e)=>{
                const r = [
                    "...",
                    n()
                ], o = e.getValue();
                return MF(o) && WF(e) ? [
                    AF([
                        bF,
                        yF(e, r, t)
                    ]),
                    bF
                ] : r;
            }, "JSXSpreadAttribute" === r53.type ? "argument" : "expression"),
            "}"
        ];
    }
    const XF = new RegExp("([ \n\r\t]+)"), YF = new RegExp("[^ \n\r\t]"), KF = (e)=>e.replace(new RegExp("(?:^" + XF.source + "|" + XF.source + "$)"), "")
    ;
    function QF(e) {
        return IF(e) && (YF.test(OF(e)) || !/\n/.test(OF(e)));
    }
    var ZF = {
        hasJsxIgnoreComment: function(e) {
            const t = e.getValue(), n = e.getParentNode();
            if (!(n && t && PF(t) && PF(n))) return !1;
            let r = null;
            for(let e260 = n.children.indexOf(t); e260 > 0; e260--){
                const t = n.children[e260 - 1];
                if ("JSXText" !== t.type || QF(t)) {
                    r = t;
                    break;
                }
            }
            return r && "JSXExpressionContainer" === r.type && "JSXEmptyExpression" === r.expression.type && VF(r.expression);
        },
        printJsx: function(e261, t143, n67) {
            const r54 = e261.getValue();
            if (r54.type.startsWith("JSX")) switch(r54.type){
                case "JSXAttribute":
                    return (function(e, t, n) {
                        const r = e.getValue(), o = [];
                        if (o.push(n("name")), r.value) {
                            let e;
                            if (jF(r.value)) {
                                let n = OF(r.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                                const { escaped: o , quote: i , regex: u  } = kF(n, t.jsxSingleQuote ? "'" : '"');
                                n = n.replace(u, o), e = [
                                    i,
                                    n,
                                    i
                                ];
                            } else e = n("value");
                            o.push("=", e);
                        }
                        return o;
                    })(e261, t143, n67);
                case "JSXIdentifier":
                    return String(r54.name);
                case "JSXNamespacedName":
                    return TF(":", [
                        n67("namespace"),
                        n67("name")
                    ]);
                case "JSXMemberExpression":
                    return TF(".", [
                        n67("object"),
                        n67("property")
                    ]);
                case "JSXSpreadAttribute":
                    return JF(e261, t143, n67);
                case "JSXSpreadChild":
                    return JF(e261, t143, n67);
                case "JSXExpressionContainer":
                    return (function(e, t, n) {
                        const r = e.getValue(), o = e.getParentNode(0), i = "JSXEmptyExpression" === r.expression.type || !MF(r.expression) && ("ArrayExpression" === r.expression.type || "ObjectExpression" === r.expression.type || "ArrowFunctionExpression" === r.expression.type || LF(r.expression) || "FunctionExpression" === r.expression.type || "TemplateLiteral" === r.expression.type || "TaggedTemplateExpression" === r.expression.type || "DoExpression" === r.expression.type || PF(o) && ("ConditionalExpression" === r.expression.type || _F(r.expression)));
                        return vF(i ? [
                            "{",
                            n("expression"),
                            wF,
                            "}"
                        ] : [
                            "{",
                            AF([
                                bF,
                                n("expression")
                            ]),
                            bF,
                            wF,
                            "}"
                        ]);
                    })(e261, 0, n67);
                case "JSXFragment":
                case "JSXElement":
                    return HF(e261, t143, n67);
                case "JSXOpeningElement":
                    return (function(e262, t, n) {
                        const r = e262.getValue(), o = r.name && MF(r.name) || r.typeParameters && MF(r.typeParameters);
                        if (r.selfClosing && 0 === r.attributes.length && !o) return [
                            "<",
                            n("name"),
                            n("typeParameters"),
                            " />"
                        ];
                        if (r.attributes && 1 === r.attributes.length && r.attributes[0].value && jF(r.attributes[0].value) && !r.attributes[0].value.value.includes("\n") && !o && !MF(r.attributes[0])) return vF([
                            "<",
                            n("name"),
                            n("typeParameters"),
                            " ",
                            ...e262.map(n, "attributes"),
                            r.selfClosing ? " />" : ">"
                        ]);
                        const i = r.attributes.length > 0 && MF(NF(r.attributes), RF.Trailing), u = 0 === r.attributes.length && !o || (t.bracketSameLine || t.jsxBracketSameLine) && (!o || r.attributes.length > 0) && !i, s = r.attributes && r.attributes.some((e)=>e.value && jF(e.value) && e.value.value.includes("\n")
                        );
                        return vF([
                            "<",
                            n("name"),
                            n("typeParameters"),
                            AF(e262.map(()=>[
                                    EF,
                                    n()
                                ]
                            , "attributes")),
                            r.selfClosing ? EF : u ? ">" : bF,
                            r.selfClosing ? "/>" : u ? "" : ">"
                        ], {
                            shouldBreak: s
                        });
                    })(e261, t143, n67);
                case "JSXClosingElement":
                    return (function(e, t, n) {
                        const r = e.getValue(), o = [];
                        o.push("</");
                        const i = n("name");
                        return MF(r.name, RF.Leading | RF.Line) ? o.push(AF([
                            CF,
                            i
                        ]), CF) : MF(r.name, RF.Leading | RF.Block) ? o.push(" ", i) : o.push(i), o.push(">"), o;
                    })(e261, 0, n67);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                    return (function(e, t) {
                        const n = e.getValue(), r = MF(n), o = MF(n, RF.Line), i = "JSXOpeningFragment" === n.type;
                        return [
                            i ? "<" : "</",
                            AF([
                                o ? CF : r && !i ? " " : "",
                                DF(e, t, !0)
                            ]),
                            o ? CF : "",
                            ">"
                        ];
                    })(e261, t143);
                case "JSXEmptyExpression":
                    return (function(e, t) {
                        const n = e.getValue(), r = MF(n, RF.Line);
                        return [
                            DF(e, t, !r),
                            r ? CF : ""
                        ];
                    })(e261, t143);
                case "JSXText":
                    throw new Error("JSXTest should be handled by JSXElement");
                default:
                    throw new Error("Unknown JSX node type: ".concat(JSON.stringify(r54.type), "."));
            }
        }
    }, ex = bu, tx = Ze, nx = gr, rx = ar, ox = Wu;
    ro({
        target: "Array",
        proto: !0
    }, {
        flat: function() {
            var e = arguments.length ? arguments[0] : void 0, t = tx(this), n = nx(t), r = ox(t, 0);
            return r.length = ex(r, t, t, n, 0, void 0 === e ? 1 : rx(e)), r;
        }
    });
    var ix, ux = Sr, sx = wr, ax = Object.keys || function(e) {
        return ux(e, sx);
    }, cx = zt, lx = Yt, px = oe, fx = ax, dx = B1 ? Object.defineProperties : function(e, t) {
        lx(e);
        for(var n, r = px(t), o = fx(t), i = o.length, u = 0; i > u;)cx.f(e, n = o[u++], r[n]);
        return e;
    }, hx = pe("document", "documentElement"), gx = Yt, mx = dx, yx = wr, Dx = An, Ex = hx, Cx = Ot, bx = vn("IE_PROTO"), vx = function() {
    }, Ax = function(e) {
        return "<script>" + e + "</" + "script>";
    }, Fx = function(e) {
        e.write(Ax("")), e.close();
        var t = e.parentWindow.Object;
        return e = null, t;
    }, xx = function() {
        try {
            ix = new ActiveXObject("htmlfile");
        } catch (e263) {
        }
        xx = "undefined" != typeof document ? document.domain && ix ? Fx(ix) : (function() {
            var e, t = Cx("iframe");
            return t.style.display = "none", Ex.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(Ax("document.F=Object")), e.close(), e.F;
        })() : Fx(ix);
        for(var e264 = yx.length; e264--;)delete xx.prototype[yx[e264]];
        return xx();
    };
    Dx[bx] = !0;
    var Sx = Object.create || function(e, t) {
        var n;
        return null !== e ? (vx.prototype = gx(e), n = new vx, vx.prototype = null, n[bx] = e) : n = xx(), void 0 === t ? n : mx(n, t);
    }, wx = zt, Tx = Dt("unscopables"), Bx = Array.prototype;
    null == Bx[Tx] && wx.f(Bx, Tx, {
        configurable: !0,
        value: Sx(null)
    });
    var Nx = function(e) {
        Bx[Tx][e] = !0;
    };
    Nx("flat");
    const { isNonEmptyArray: kx  } = dc, { builders: { indent: Px , join: Ox , line: Ix  }  } = Zc, { isFlowAnnotationComment: Lx  } = CC;
    function jx(e, t, n) {
        const r = e.getValue();
        if (!r.typeAnnotation) return "";
        const o = e.getParentNode(), i = r.definite || o && "VariableDeclarator" === o.type && o.definite, u = "DeclareFunction" === o.type && o.id === r;
        return Lx(t.originalText, r.typeAnnotation) ? [
            " /*: ",
            n("typeAnnotation"),
            " */"
        ] : [
            u ? "" : i ? "!: " : ": ",
            n("typeAnnotation")
        ];
    }
    var _x = {
        printOptionalToken: function(e) {
            const t = e.getValue();
            return !t.optional || "Identifier" === t.type && t === e.getParentNode().key ? "" : "OptionalCallExpression" === t.type || "OptionalMemberExpression" === t.type && t.computed ? "?." : "?";
        },
        printFunctionTypeParameters: function(e, t, n) {
            const r = e.getValue();
            return r.typeArguments ? n("typeArguments") : r.typeParameters ? n("typeParameters") : "";
        },
        printBindExpressionCallee: function(e, t, n) {
            return [
                "::",
                n("callee")
            ];
        },
        printTypeScriptModifiers: function(e, t, n) {
            const r = e.getValue();
            return kx(r.modifiers) ? [
                Ox(" ", e.map(n, "modifiers")),
                " "
            ] : "";
        },
        printTypeAnnotation: jx,
        printRestSpread: function(e, t, n) {
            return [
                "...",
                n("argument"),
                jx(e, t, n)
            ];
        },
        adjustClause: function(e, t, n) {
            return "EmptyStatement" === e.type ? ";" : "BlockStatement" === e.type || n ? [
                " ",
                t
            ] : Px([
                Ix,
                t
            ]);
        }
    };
    const { printDanglingComments: Mx  } = tD, { builders: { line: Rx , softline: Vx , hardline: $x , group: Wx , indent: qx , ifBreak: Ux , fill: zx  }  } = Zc, { getLast: Gx , hasNewline: Hx  } = dc, { shouldPrintComma: Jx , hasComment: Xx , CommentCheckFlags: Yx , isNextLineEmpty: Kx , isNumericLiteral: Qx , isSignedNumericLiteral: Zx  } = CC, { locStart: eS  } = og, { printOptionalToken: tS , printTypeAnnotation: nS  } = _x;
    function rS(e265, t) {
        return e265.elements.length > 1 && e265.elements.every((e266)=>e266 && (Qx(e266) || Zx(e266) && !Xx(e266.argument)) && !Xx(e266, Yx.Trailing | Yx.Line, (e)=>!Hx(t.originalText, eS(e), {
                    backwards: !0
                })
            )
        );
    }
    function oS(e267, t, n, r) {
        const o = [];
        let i = [];
        return e267.each((e)=>{
            o.push(i, Wx(r())), i = [
                ",",
                Rx
            ], e.getValue() && Kx(e.getValue(), t) && i.push(Vx);
        }, n), o;
    }
    function iS(e268, t, n, r) {
        const o = [];
        return e268.each((e, i, u)=>{
            const s = i === u.length - 1;
            o.push([
                n(),
                s ? r : ","
            ]), s || o.push(Kx(e.getValue(), t) ? [
                $x,
                $x
            ] : Xx(u[i + 1], Yx.Leading | Yx.Line) ? $x : Rx);
        }, "elements"), zx(o);
    }
    var uS = {
        printArray: function(e269, t, n68) {
            const r55 = e269.getValue(), o33 = [], i = "TupleExpression" === r55.type ? "#[" : "[";
            if (0 === r55.elements.length) Xx(r55, Yx.Dangling) ? o33.push(Wx([
                i,
                Mx(e269, t),
                Vx,
                "]"
            ])) : o33.push(i, "]");
            else {
                const u = Gx(r55.elements), s = !(u && "RestElement" === u.type), a = null === u, c = Symbol("array"), l = !t.__inJestEach && r55.elements.length > 1 && r55.elements.every((e, t, n)=>{
                    const r = e && e.type;
                    if ("ArrayExpression" !== r && "ObjectExpression" !== r) return !1;
                    const o = n[t + 1];
                    if (o && r !== o.type) return !1;
                    const i = "ArrayExpression" === r ? "elements" : "properties";
                    return e[i] && e[i].length > 1;
                }), p = rS(r55, t), f = s ? a ? "," : Jx(t) ? p ? Ux(",", "", {
                    groupId: c
                }) : Ux(",") : "" : "";
                o33.push(Wx([
                    i,
                    qx([
                        Vx,
                        p ? iS(e269, t, n68, f) : [
                            oS(e269, t, "elements", n68),
                            f
                        ],
                        Mx(e269, t, !0)
                    ]),
                    Vx,
                    "]"
                ], {
                    shouldBreak: l,
                    id: c
                }));
            }
            return o33.push(tS(e269), nS(e269, t, n68)), o33;
        },
        printArrayItems: oS,
        isConciselyPrintedArray: rS
    };
    const { printDanglingComments: sS  } = tD, { getLast: aS , getPenultimate: cS  } = dc, { getFunctionParameters: lS , hasComment: pS , CommentCheckFlags: fS , isFunctionCompositionArgs: dS , isJsxNode: hS , isLongCurriedCallExpression: gS , shouldPrintComma: mS , getCallArguments: yS , iterateCallArgumentsPath: DS , isNextLineEmpty: ES , isCallExpression: CS , isStringLiteral: bS , isObjectProperty: vS  } = CC, { builders: { line: AS , hardline: FS , softline: xS , group: SS , indent: wS , conditionalGroup: TS , ifBreak: BS , breakParent: NS  } , utils: { willBreak: kS  }  } = Zc, { ArgExpansionBailout: PS  } = Cp, { isConciselyPrintedArray: OS  } = uS;
    function IS(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return "ObjectExpression" === e.type && (e.properties.length > 0 || pS(e)) || "ArrayExpression" === e.type && (e.elements.length > 0 || pS(e)) || "TSTypeAssertion" === e.type && IS(e.expression) || "TSAsExpression" === e.type && IS(e.expression) || "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type && (!e.returnType || !e.returnType.typeAnnotation || "TSTypeReference" !== e.returnType.typeAnnotation.type || LS(e.body)) && ("BlockStatement" === e.body.type || "ArrowFunctionExpression" === e.body.type && IS(e.body, !0) || "ObjectExpression" === e.body.type || "ArrayExpression" === e.body.type || !t && (CS(e.body) || "ConditionalExpression" === e.body.type) || hS(e.body)) || "DoExpression" === e.type || "ModuleExpression" === e.type;
    }
    function LS(e270) {
        return "BlockStatement" === e270.type && (e270.body.some((e)=>"EmptyStatement" !== e.type
        ) || pS(e270, fS.Dangling));
    }
    var jS = function(e271, t144, n69) {
        const r56 = e271.getValue(), o34 = "ImportExpression" === r56.type, i21 = yS(r56);
        if (0 === i21.length) return [
            "(",
            sS(e271, t144, !0),
            ")"
        ];
        if ((function(e272) {
            return 2 === e272.length && "ArrowFunctionExpression" === e272[0].type && 0 === lS(e272[0]).length && "BlockStatement" === e272[0].body.type && "ArrayExpression" === e272[1].type && !e272.some((e)=>pS(e)
            );
        })(i21)) return [
            "(",
            n69([
                "arguments",
                0
            ]),
            ", ",
            n69([
                "arguments",
                1
            ]),
            ")"
        ];
        let u = !1, s = !1;
        const a = i21.length - 1, c = [];
        DS(e271, (e, r)=>{
            const o = e.getNode(), i = [
                n69()
            ];
            r === a || (ES(o, t144) ? (0 === r && (s = !0), u = !0, i.push(",", FS, FS)) : i.push(",", AS)), c.push(i);
        });
        const l = o34 || r56.callee && "Import" === r56.callee.type || !mS(t144, "all") ? "" : ",";
        function p() {
            return SS([
                "(",
                wS([
                    AS,
                    ...c
                ]),
                l,
                AS,
                ")"
            ], {
                shouldBreak: !0
            });
        }
        if (u || "Decorator" !== e271.getParentNode().type && dS(i21)) return p();
        const f = function(e273) {
            if (2 !== e273.length) return !1;
            const [t, n] = e273;
            if ("ModuleExpression" === t.type && (function(e) {
                return "ObjectExpression" === e.type && 1 === e.properties.length && vS(e.properties[0]) && "Identifier" === e.properties[0].key.type && "type" === e.properties[0].key.name && bS(e.properties[0].value) && "module" === e.properties[0].value.value;
            })(n)) return !0;
            return !pS(t) && ("FunctionExpression" === t.type || "ArrowFunctionExpression" === t.type && "BlockStatement" === t.body.type) && "FunctionExpression" !== n.type && "ArrowFunctionExpression" !== n.type && "ConditionalExpression" !== n.type && !IS(n);
        }(i21), d = function(e, t) {
            const n = aS(e), r = cS(e);
            return !pS(n, fS.Leading) && !pS(n, fS.Trailing) && IS(n) && (!r || r.type !== n.type) && (2 !== e.length || "ArrowFunctionExpression" !== r.type || "ArrayExpression" !== n.type) && !(e.length > 1 && "ArrayExpression" === n.type && OS(n, t));
        }(i21, t144);
        if (f || d) {
            if (f ? c.slice(1).some(kS) : c.slice(0, -1).some(kS)) return p();
            let t = [];
            try {
                e271.try(()=>{
                    DS(e271, (e, r)=>{
                        f && 0 === r && (t = [
                            [
                                n69([], {
                                    expandFirstArg: !0
                                }),
                                c.length > 1 ? "," : "",
                                s ? FS : AS,
                                s ? FS : ""
                            ],
                            ...c.slice(1)
                        ]), d && r === a && (t = [
                            ...c.slice(0, -1),
                            n69([], {
                                expandLastArg: !0
                            })
                        ]);
                    });
                });
            } catch (e) {
                if (e instanceof PS) return p();
                throw e;
            }
            return [
                c.some(kS) ? NS : "",
                TS([
                    [
                        "(",
                        ...t,
                        ")"
                    ],
                    f ? [
                        "(",
                        SS(t[0], {
                            shouldBreak: !0
                        }),
                        ...t.slice(1),
                        ")"
                    ] : [
                        "(",
                        ...c.slice(0, -1),
                        SS(aS(t), {
                            shouldBreak: !0
                        }),
                        ")"
                    ],
                    p()
                ])
            ];
        }
        const h = [
            "(",
            wS([
                xS,
                ...c
            ]),
            BS(l),
            xS,
            ")"
        ];
        return gS(e271) ? h : SS(h, {
            shouldBreak: c.some(kS) || u
        });
    };
    const { builders: { softline: _S , group: MS , indent: RS , label: VS  }  } = Zc, { isNumericLiteral: $S , isMemberExpression: WS , isCallExpression: qS  } = CC, { printOptionalToken: US  } = _x;
    function zS(e, t, n) {
        const r = n("property"), o = e.getValue(), i = US(e);
        return o.computed ? !o.property || $S(o.property) ? [
            i,
            "[",
            r,
            "]"
        ] : MS([
            i,
            "[",
            RS([
                _S,
                r
            ]),
            _S,
            "]"
        ]) : [
            i,
            ".",
            r
        ];
    }
    var GS = {
        printMemberExpression: function(e, t, n) {
            const r = e.getValue(), o = e.getParentNode();
            let i, u = 0;
            do i = e.getParentNode(u), u++;
            while (i && (WS(i) || "TSNonNullExpression" === i.type))
            const s = n("object"), a = zS(e, t, n), c = i && ("NewExpression" === i.type || "BindExpression" === i.type || "AssignmentExpression" === i.type && "Identifier" !== i.left.type) || r.computed || "Identifier" === r.object.type && "Identifier" === r.property.type && !WS(o) || ("AssignmentExpression" === o.type || "VariableDeclarator" === o.type) && (qS(r.object) && r.object.arguments.length > 0 || "TSNonNullExpression" === r.object.type && qS(r.object.expression) && r.object.expression.arguments.length > 0 || "member-chain" === s.label);
            return VS("member-chain" === s.label ? "member-chain" : "member", [
                s,
                c ? a : MS(RS([
                    _S,
                    a
                ]))
            ]);
        },
        printMemberLookup: zS
    };
    const { printComments: HS  } = tD, { getLast: JS , isNextLineEmptyAfterIndex: XS , getNextNonSpaceNonCommentCharacterIndex: YS  } = dc, KS = wA, { isCallExpression: QS , isMemberExpression: ZS , isFunctionOrArrowExpression: ew , isLongCurriedCallExpression: tw , isMemberish: nw , isNumericLiteral: rw , isSimpleCallArgument: ow , hasComment: iw , CommentCheckFlags: uw , isNextLineEmpty: sw  } = CC, { locEnd: aw  } = og, { builders: { join: cw , hardline: lw , group: pw , indent: fw , conditionalGroup: dw , breakParent: hw , label: gw  } , utils: { willBreak: mw  }  } = Zc, yw = jS, { printMemberLookup: Dw  } = GS, { printOptionalToken: Ew , printFunctionTypeParameters: Cw , printBindExpressionCallee: bw  } = _x;
    var vw = function(e274, t145, n70) {
        const r57 = e274.getParentNode(), o = !r57 || "ExpressionStatement" === r57.type, i = [];
        function u(e) {
            const { originalText: n  } = t145, r = YS(n, e, aw);
            return ")" === n.charAt(r) ? !1 !== r && XS(n, r + 1) : sw(e, t145);
        }
        function s(e275) {
            const r = e275.getValue();
            QS(r) && (nw(r.callee) || QS(r.callee)) ? (i.unshift({
                node: r,
                printed: [
                    HS(e275, [
                        Ew(e275),
                        Cw(e275, t145, n70),
                        yw(e275, t145, n70)
                    ], t145),
                    u(r) ? lw : ""
                ]
            }), e275.call((e)=>s(e)
            , "callee")) : nw(r) ? (i.unshift({
                node: r,
                needsParens: KS(e275, t145),
                printed: HS(e275, ZS(r) ? Dw(e275, t145, n70) : bw(e275, t145, n70), t145)
            }), e275.call((e)=>s(e)
            , "object")) : "TSNonNullExpression" === r.type ? (i.unshift({
                node: r,
                printed: HS(e275, "!", t145)
            }), e275.call((e)=>s(e)
            , "expression")) : i.unshift({
                node: r,
                printed: n70()
            });
        }
        const a = e274.getValue();
        i.unshift({
            node: a,
            printed: [
                Ew(e274),
                Cw(e274, t145, n70),
                yw(e274, t145, n70)
            ]
        }), a.callee && e274.call((e)=>s(e)
        , "callee");
        const c = [];
        let l = [
            i[0]
        ], p = 1;
        for(; p < i.length && ("TSNonNullExpression" === i[p].node.type || QS(i[p].node) || ZS(i[p].node) && i[p].node.computed && rw(i[p].node.property)); ++p)l.push(i[p]);
        if (!QS(i[0].node)) for(; p + 1 < i.length && nw(i[p].node) && nw(i[p + 1].node); ++p)l.push(i[p]);
        c.push(l), l = [];
        let f = !1;
        for(; p < i.length; ++p){
            if (f && nw(i[p].node)) {
                if (i[p].node.computed && rw(i[p].node.property)) {
                    l.push(i[p]);
                    continue;
                }
                c.push(l), l = [], f = !1;
            }
            (QS(i[p].node) || "ImportExpression" === i[p].node.type) && (f = !0), l.push(i[p]), iw(i[p].node, uw.Trailing) && (c.push(l), l = [], f = !1);
        }
        function d(e) {
            return /^[A-Z]|^[$_]+$/.test(e);
        }
        l.length > 0 && c.push(l);
        const h = c.length >= 2 && !iw(c[1][0].node) && function(e276) {
            const n = e276[1].length > 0 && e276[1][0].node.computed;
            if (1 === e276[0].length) {
                const r = e276[0][0].node;
                return "ThisExpression" === r.type || "Identifier" === r.type && (d(r.name) || o && (function(e) {
                    return e.length <= t145.tabWidth;
                })(r.name) || n);
            }
            const r = JS(e276[0]).node;
            return ZS(r) && "Identifier" === r.property.type && (d(r.property.name) || n);
        }(c);
        function g(e277) {
            const t = e277.map((e)=>e.printed
            );
            return e277.length > 0 && JS(e277).needsParens ? [
                "(",
                ...t,
                ")"
            ] : t;
        }
        const m = c.map(g), y = m, D = h ? 3 : 2, E = c.flat(), C = E.slice(1, -1).some((e)=>iw(e.node, uw.Leading)
        ) || E.slice(0, -1).some((e)=>iw(e.node, uw.Trailing)
        ) || c[D] && iw(c[D][0].node, uw.Leading);
        if (c.length <= D && !C) return tw(e274) ? y : pw(y);
        const b = JS(c[h ? 1 : 0]).node, v = !QS(b) && u(b), A = [
            g(c[0]),
            h ? c.slice(1, 2).map(g) : "",
            v ? lw : "",
            function(e) {
                return 0 === e.length ? "" : fw(pw([
                    lw,
                    cw(lw, e.map(g))
                ]));
            }(c.slice(h ? 2 : 1))
        ], F = i.map((e)=>{
            let { node: t  } = e;
            return t;
        }).filter(QS);
        let x;
        return x = C || F.length > 2 && F.some((e278)=>!e278.arguments.every((e)=>ow(e, 0)
            )
        ) || m.slice(0, -1).some(mw) || (function() {
            const e279 = JS(JS(c)).node, t = JS(m);
            return QS(e279) && mw(t) && F.slice(0, -1).some((e)=>e.arguments.some(ew)
            );
        })() ? pw(A) : [
            mw(y) || v ? hw : "",
            dw([
                y,
                A
            ])
        ], gw("member-chain", x);
    };
    const { builders: { join: Aw , group: Fw  }  } = Zc, xw = wA, { getCallArguments: Sw , hasFlowAnnotationComment: ww , isCallExpression: Tw , isMemberish: Bw , isStringLiteral: Nw , isTemplateOnItsOwnLine: kw , isTestCall: Pw , iterateCallArgumentsPath: Ow  } = CC, Iw = vw, Lw = jS, { printOptionalToken: jw , printFunctionTypeParameters: _w  } = _x;
    var Mw = {
        printCallExpression: function(e280, t146, n71) {
            const r = e280.getValue(), o = e280.getParentNode(), i = "NewExpression" === r.type, u = "ImportExpression" === r.type, s = jw(e280), a = Sw(r);
            if (a.length > 0 && (!u && !i && (function(e, t) {
                if ("Identifier" !== e.callee.type) return !1;
                if ("require" === e.callee.name) return !0;
                if ("define" === e.callee.name) {
                    const n = Sw(e);
                    return "ExpressionStatement" === t.type && (1 === n.length || 2 === n.length && "ArrayExpression" === n[0].type || 3 === n.length && Nw(n[0]) && "ArrayExpression" === n[1].type);
                }
                return !1;
            })(r, o) || 1 === a.length && kw(a[0], t146.originalText) || !i && Pw(r, o))) {
                const r = [];
                return Ow(e280, ()=>{
                    r.push(n71());
                }), [
                    i ? "new " : "",
                    n71("callee"),
                    s,
                    _w(e280, t146, n71),
                    "(",
                    Aw(", ", r),
                    ")"
                ];
            }
            const c = ("babel" === t146.parser || "babel-flow" === t146.parser) && r.callee && "Identifier" === r.callee.type && ww(r.callee.trailingComments);
            if (c && (r.callee.trailingComments[0].printed = !0), !u && !i && Bw(r.callee) && !e280.call((e)=>xw(e, t146)
            , "callee")) return Iw(e280, t146, n71);
            const l = [
                i ? "new " : "",
                u ? "import" : n71("callee"),
                s,
                c ? "/*:: ".concat(r.callee.trailingComments[0].value.slice(2).trim(), " */") : "",
                _w(e280, t146, n71),
                Lw(e280, t146, n71)
            ];
            return u || Tw(r.callee) ? Fw(l) : l;
        }
    };
    const { isNonEmptyArray: Rw , getStringWidth: Vw  } = dc, { builders: { line: $w , group: Ww , indent: qw , indentIfBreak: Uw  } , utils: { cleanDoc: zw , willBreak: Gw , canBreak: Hw  }  } = Zc, { hasLeadingOwnLineComment: Jw , isBinaryish: Xw , isStringLiteral: Yw , isLiteral: Kw , isNumericLiteral: Qw , isCallExpression: Zw , isMemberExpression: eT , getCallArguments: tT , rawText: nT , hasComment: rT , isSignedNumericLiteral: oT , isObjectProperty: iT  } = CC, { shouldInlineLogicalExpression: uT  } = sF, { printCallExpression: sT  } = Mw;
    function aT(e281, t147, n72, r58, o35, i22) {
        const u17 = function(e282, t148, n73, r59, o36) {
            const i23 = e282.getValue(), u18 = i23[o36];
            if (!u18) return "only-left";
            const s = !cT(u18), a = e282.match(cT, lT, (e)=>!s || "ExpressionStatement" !== e.type && "VariableDeclaration" !== e.type
            );
            if (a) return s ? "ArrowFunctionExpression" === u18.type && "ArrowFunctionExpression" === u18.body.type ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!s && cT(u18.right) || Jw(t148.originalText, u18)) return "break-after-operator";
            if ("CallExpression" === u18.type && "require" === u18.callee.name || "json5" === t148.parser || "json" === t148.parser) return "never-break-after-operator";
            if ((function(e283) {
                if (lT(e283)) {
                    const t = e283.left || e283.id;
                    return "ObjectPattern" === t.type && t.properties.length > 2 && t.properties.some((e)=>iT(e) && (!e.shorthand || e.value && "AssignmentPattern" === e.value.type)
                    );
                }
                return !1;
            })(i23) || (function(e284) {
                const t = function(e285) {
                    if ((function(e) {
                        return "TSTypeAliasDeclaration" === e.type || "TypeAlias" === e.type;
                    })(e285) && e285.typeParameters && e285.typeParameters.params) return e285.typeParameters.params;
                    return null;
                }(e284);
                if (Rw(t)) {
                    const n = "TSTypeAliasDeclaration" === e284.type ? "constraint" : "bound";
                    if (t.length > 1 && t.some((e)=>e[n] || e.default
                    )) return !0;
                }
                return !1;
            })(i23) || (function(e286) {
                if ("VariableDeclarator" !== e286.type) return !1;
                const { typeAnnotation: t  } = e286.id;
                if (!t || !t.typeAnnotation) return !1;
                const n = fT(t.typeAnnotation);
                return Rw(n) && n.length > 1 && n.some((e)=>Rw(fT(e)) || "TSConditionalType" === e.type
                );
            })(i23) || pT(i23) && Hw(r59)) return "break-lhs";
            const c = function(e, t, n) {
                if (!iT(e)) return !1;
                t = zw(t);
                const r = 3;
                return "string" == typeof t && Vw(t) < n.tabWidth + r;
            }(i23, r59, t148);
            if (e282.call(()=>(function(e, t, n, r) {
                    const o = e.getValue();
                    if (Xw(o) && !uT(o)) return !0;
                    switch(o.type){
                        case "StringLiteralTypeAnnotation":
                        case "SequenceExpression":
                            return !0;
                        case "ConditionalExpression":
                            {
                                const { test: e  } = o;
                                return Xw(e) && !uT(e);
                            }
                        case "ClassExpression":
                            return Rw(o.decorators);
                    }
                    if (r) return !1;
                    let i = o;
                    const u = [];
                    for(;;)if ("UnaryExpression" === i.type) i = i.argument, u.push("argument");
                    else {
                        if ("TSNonNullExpression" !== i.type) break;
                        i = i.expression, u.push("expression");
                    }
                    if (Yw(i) || e.call(()=>dT(e, t, n)
                    , ...u)) return !0;
                    return !1;
                })(e282, t148, n73, c)
            , o36)) return "break-after-operator";
            if (c || "TemplateLiteral" === u18.type || "TaggedTemplateExpression" === u18.type || "BooleanLiteral" === u18.type || Qw(u18) || "ClassExpression" === u18.type) return "never-break-after-operator";
            return "fluid";
        }(e281, t147, n72, r58, i22), s12 = n72(i22, {
            assignmentLayout: u17
        });
        switch(u17){
            case "break-after-operator":
                return Ww([
                    Ww(r58),
                    o35,
                    Ww(qw([
                        $w,
                        s12
                    ]))
                ]);
            case "never-break-after-operator":
                return Ww([
                    Ww(r58),
                    o35,
                    " ",
                    s12
                ]);
            case "fluid":
                {
                    const e = Symbol("assignment");
                    return Ww([
                        Ww(r58),
                        o35,
                        Ww(qw($w), {
                            id: e
                        }),
                        Uw(s12, {
                            groupId: e
                        })
                    ]);
                }
            case "break-lhs":
                return Ww([
                    r58,
                    o35,
                    " ",
                    Ww(s12)
                ]);
            case "chain":
                return [
                    Ww(r58),
                    o35,
                    $w,
                    s12
                ];
            case "chain-tail":
                return [
                    Ww(r58),
                    o35,
                    qw([
                        $w,
                        s12
                    ])
                ];
            case "chain-tail-arrow-chain":
                return [
                    Ww(r58),
                    o35,
                    s12
                ];
            case "only-left":
                return r58;
        }
    }
    function cT(e) {
        return "AssignmentExpression" === e.type;
    }
    function lT(e) {
        return cT(e) || "VariableDeclarator" === e.type;
    }
    function pT(e) {
        return "VariableDeclarator" === e.type && e.init && "ArrowFunctionExpression" === e.init.type;
    }
    function fT(e287) {
        return (function(e) {
            return "TSTypeReference" === e.type || "GenericTypeAnnotation" === e.type;
        })(e287) && e287.typeParameters && e287.typeParameters.params ? e287.typeParameters.params : null;
    }
    function dT(e, t, n) {
        let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        const o = e.getValue(), i = ()=>dT(e, t, n, !0)
        ;
        if ("TSNonNullExpression" === o.type) return e.call(i, "expression");
        if (Zw(o)) {
            if ("member-chain" === sT(e, t, n).label) return !1;
            const r = tT(o);
            return !!(0 === r.length || 1 === r.length && hT(r[0], t)) && !gT(o, n) && e.call(i, "callee");
        }
        return eT(o) ? e.call(i, "object") : r && ("Identifier" === o.type || "ThisExpression" === o.type);
    }
    function hT(e, t) {
        let { printWidth: n  } = t;
        if (rT(e)) return !1;
        const r = 0.25 * n;
        if ("ThisExpression" === e.type || "Identifier" === e.type && e.name.length <= r || oT(e) && !rT(e.argument)) return !0;
        const o = "Literal" === e.type && "regex" in e && e.regex.pattern || "RegExpLiteral" === e.type && e.pattern;
        return o ? o.length <= r : Yw(e) ? nT(e).length <= r : "TemplateLiteral" === e.type ? 0 === e.expressions.length && e.quasis[0].value.raw.length <= r && !e.quasis[0].value.raw.includes("\n") : Kw(e);
    }
    function gT(e288, t) {
        const n = function(e) {
            return e.typeParameters && e.typeParameters.params || e.typeArguments && e.typeArguments.params;
        }(e288);
        if (Rw(n)) {
            if (n.length > 1) return !0;
            if (1 === n.length) {
                const e = n[0];
                if ("TSUnionType" === e.type || "UnionTypeAnnotation" === e.type || "TSIntersectionType" === e.type || "IntersectionTypeAnnotation" === e.type) return !0;
            }
            const r = e288.typeParameters ? "typeParameters" : "typeArguments";
            if (Gw(t(r))) return !0;
        }
        return !1;
    }
    var mT = {
        printVariableDeclarator: function(e, t, n) {
            return aT(e, t, n, n("id"), " =", "init");
        },
        printAssignmentExpression: function(e, t, n) {
            const r = e.getValue();
            return aT(e, t, n, n("left"), [
                " ",
                r.operator
            ], "right");
        },
        printAssignment: aT,
        isArrowFunctionVariableDeclarator: pT
    };
    const { getNextNonSpaceNonCommentCharacter: yT  } = dc, { printDanglingComments: DT  } = tD, { builders: { line: ET , hardline: CT , softline: bT , group: vT , indent: AT , ifBreak: FT  } , utils: { removeLines: xT , willBreak: ST  }  } = Zc, { getFunctionParameters: wT , iterateFunctionParametersPath: TT , isSimpleType: BT , isTestCall: NT , isTypeAnnotationAFunction: kT , isObjectType: PT , isObjectTypePropertyAFunction: OT , hasRestParameter: IT , shouldPrintComma: LT , hasComment: jT , isNextLineEmpty: _T  } = CC, { locEnd: MT  } = og, { ArgExpansionBailout: RT  } = Cp, { printFunctionTypeParameters: VT  } = _x;
    function $T(e) {
        if (!e) return !1;
        const t = wT(e);
        if (1 !== t.length) return !1;
        const [n] = t;
        return !jT(n) && ("ObjectPattern" === n.type || "ArrayPattern" === n.type || "Identifier" === n.type && n.typeAnnotation && ("TypeAnnotation" === n.typeAnnotation.type || "TSTypeAnnotation" === n.typeAnnotation.type) && PT(n.typeAnnotation.typeAnnotation) || "FunctionTypeParam" === n.type && PT(n.typeAnnotation) || "AssignmentPattern" === n.type && ("ObjectPattern" === n.left.type || "ArrayPattern" === n.left.type) && ("Identifier" === n.right.type || "ObjectExpression" === n.right.type && 0 === n.right.properties.length || "ArrayExpression" === n.right.type && 0 === n.right.elements.length));
    }
    var WT = {
        printFunctionParameters: function(e289, t, n, r60, o37) {
            const i = e289.getValue(), u = wT(i), s = o37 ? VT(e289, n, t) : "";
            if (0 === u.length) return [
                s,
                "(",
                DT(e289, n, !0, (e)=>")" === yT(n.originalText, e, MT)
                ),
                ")"
            ];
            const a = e289.getParentNode(), c = NT(a), l = $T(i), p = [];
            if (TT(e289, (e, r)=>{
                const o = r === u.length - 1;
                o && i.rest && p.push("..."), p.push(t()), o || (p.push(","), c || l ? p.push(" ") : _T(u[r], n) ? p.push(CT, CT) : p.push(ET));
            }), r60) {
                if (ST(s) || ST(p)) throw new RT;
                return vT([
                    xT(s),
                    "(",
                    xT(p),
                    ")"
                ]);
            }
            const f = u.every((e)=>!e.decorators
            );
            return l && f || c ? [
                s,
                "(",
                ...p,
                ")"
            ] : (OT(a) || kT(a) || "TypeAlias" === a.type || "UnionTypeAnnotation" === a.type || "TSUnionType" === a.type || "IntersectionTypeAnnotation" === a.type || "FunctionTypeAnnotation" === a.type && a.returnType === i) && 1 === u.length && null === u[0].name && i.this !== u[0] && u[0].typeAnnotation && null === i.typeParameters && BT(u[0].typeAnnotation) && !i.rest ? "always" === n.arrowParens ? [
                "(",
                ...p,
                ")"
            ] : p : [
                s,
                "(",
                AT([
                    bT,
                    ...p
                ]),
                FT(!IT(i) && LT(n, "all") ? "," : ""),
                bT,
                ")"
            ];
        },
        shouldHugFunctionParameters: $T,
        shouldGroupFunctionParameters: function(e290, t149) {
            const n = function(e) {
                let t;
                return e.returnType ? (t = e.returnType, t.typeAnnotation && (t = t.typeAnnotation)) : e.typeAnnotation && (t = e.typeAnnotation), t;
            }(e290);
            if (!n) return !1;
            const r = e290.typeParameters && e290.typeParameters.params;
            if (r) {
                if (r.length > 1) return !1;
                if (1 === r.length) {
                    const e = r[0];
                    if (e.constraint || e.default) return !1;
                }
            }
            return 1 === wT(e290).length && (PT(n) || ST(t149));
        }
    };
    const { printComments: qT , printDanglingComments: UT  } = tD, { getLast: zT , isNonEmptyArray: GT  } = dc, { builders: { group: HT , join: JT , line: XT , softline: YT , indent: KT , align: QT , ifBreak: ZT  }  } = Zc, eB = wA, { locStart: tB  } = og, { isSimpleType: nB , isObjectType: rB , hasLeadingOwnLineComment: oB , isObjectTypePropertyAFunction: iB , shouldPrintComma: uB  } = CC, { printAssignment: sB  } = mT, { printFunctionParameters: aB , shouldGroupFunctionParameters: cB  } = WT, { printArrayItems: lB  } = uS;
    function pB(e291) {
        if (nB(e291) || rB(e291)) return !0;
        if ("UnionTypeAnnotation" === e291.type || "TSUnionType" === e291.type) {
            const t = e291.types.filter((e)=>"VoidTypeAnnotation" === e.type || "TSVoidKeyword" === e.type || "NullLiteralTypeAnnotation" === e.type || "TSNullKeyword" === e.type
            ).length, n = e291.types.some((e)=>"ObjectTypeAnnotation" === e.type || "TSTypeLiteral" === e.type || "GenericTypeAnnotation" === e.type || "TSTypeReference" === e.type
            );
            if (e291.types.length - 1 === t && n) return !0;
        }
        return !1;
    }
    var fB = {
        printOpaqueType: function(e, t, n) {
            const r = t.semi ? ";" : "", o = e.getValue(), i = [];
            return i.push("opaque type ", n("id"), n("typeParameters")), o.supertype && i.push(": ", n("supertype")), o.impltype && i.push(" = ", n("impltype")), i.push(r), i;
        },
        printTypeAlias: function(e, t, n) {
            const r = t.semi ? ";" : "", o = e.getValue(), i = [];
            o.declare && i.push("declare "), i.push("type ", n("id"), n("typeParameters"));
            const u = "TSTypeAliasDeclaration" === o.type ? "typeAnnotation" : "right";
            return [
                sB(e, t, n, i, " =", u),
                r
            ];
        },
        printIntersectionType: function(e, t, n) {
            const r = e.getValue(), o = e.map(n, "types"), i = [];
            let u = !1;
            for(let e292 = 0; e292 < o.length; ++e292)0 === e292 ? i.push(o[e292]) : rB(r.types[e292 - 1]) && rB(r.types[e292]) ? i.push([
                " & ",
                u ? KT(o[e292]) : o[e292]
            ]) : rB(r.types[e292 - 1]) || rB(r.types[e292]) ? (e292 > 1 && (u = !0), i.push(" & ", e292 > 1 ? KT(o[e292]) : o[e292])) : i.push(KT([
                " &",
                XT,
                o[e292]
            ]));
            return HT(i);
        },
        printUnionType: function(e293, t, n) {
            const r61 = e293.getValue(), o = e293.getParentNode(), i = !("TypeParameterInstantiation" === o.type || "TSTypeParameterInstantiation" === o.type || "GenericTypeAnnotation" === o.type || "TSTypeReference" === o.type || "TSTypeAssertion" === o.type || "TupleTypeAnnotation" === o.type || "TSTupleType" === o.type || "FunctionTypeParam" === o.type && !o.name && e293.getParentNode(1).this !== o || ("TypeAlias" === o.type || "VariableDeclarator" === o.type || "TSTypeAliasDeclaration" === o.type) && oB(t.originalText, r61)), u = pB(r61), s = e293.map((e)=>{
                let r = n();
                return u || (r = QT(2, r)), qT(e, r, t);
            }, "types");
            if (u) return JT(" | ", s);
            const a = i && !oB(t.originalText, r61), c = [
                ZT([
                    a ? XT : "",
                    "| "
                ]),
                JT([
                    XT,
                    "| "
                ], s)
            ];
            return eB(e293, t) ? HT([
                KT(c),
                YT
            ]) : "TupleTypeAnnotation" === o.type && o.types.length > 1 || "TSTupleType" === o.type && o.elementTypes.length > 1 ? HT([
                KT([
                    ZT([
                        "(",
                        YT
                    ]),
                    c
                ]),
                YT,
                ZT(")")
            ]) : HT(i ? KT(c) : c);
        },
        printFunctionType: function(e, t, n) {
            const r = e.getValue(), o = [], i = e.getParentNode(0), u = e.getParentNode(1), s = e.getParentNode(2);
            let a = "TSFunctionType" === r.type || !(("ObjectTypeProperty" === i.type || "ObjectTypeInternalSlot" === i.type) && !i.variance && !i.optional && tB(i) === tB(r) || "ObjectTypeCallProperty" === i.type || s && "DeclareFunction" === s.type), c = a && ("TypeAnnotation" === i.type || "TSTypeAnnotation" === i.type);
            const l = c && a && ("TypeAnnotation" === i.type || "TSTypeAnnotation" === i.type) && "ArrowFunctionExpression" === u.type;
            iB(i) && (a = !0, c = !0), l && o.push("(");
            const p = aB(e, n, t, !1, !0), f = r.returnType || r.predicate || r.typeAnnotation ? [
                a ? " => " : ": ",
                n("returnType"),
                n("predicate"),
                n("typeAnnotation")
            ] : "", d = cB(r, f);
            return o.push(d ? HT(p) : p), f && o.push(f), l && o.push(")"), HT(o);
        },
        printTupleType: function(e, t, n) {
            const r = e.getValue(), o = "TSTupleType" === r.type ? "elementTypes" : "types", i = r[o], u = GT(i), s = u && "TSRestType" === zT(i).type, a = u ? YT : "";
            return HT([
                "[",
                KT([
                    a,
                    lB(e, t, o, n)
                ]),
                ZT(u && uB(t, "all") && !s ? "," : ""),
                UT(e, t, !0),
                a,
                "]"
            ]);
        },
        printIndexedAccessType: function(e, t, n) {
            const r = e.getValue(), o = "OptionalIndexedAccessType" === r.type && r.optional ? "?.[" : "[";
            return [
                n("objectType"),
                o,
                n("indexType"),
                "]"
            ];
        },
        shouldHugType: pB
    };
    const { printDanglingComments: dB  } = tD, { builders: { join: hB , line: gB , hardline: mB , softline: yB , group: DB , indent: EB , ifBreak: CB  }  } = Zc, { isTestCall: bB , hasComment: vB , CommentCheckFlags: AB , isTSXFile: FB , shouldPrintComma: xB , getFunctionParameters: SB , isObjectType: wB  } = CC, { createGroupIdMapper: TB  } = dc, { shouldHugType: BB  } = fB, { isArrowFunctionVariableDeclarator: NB  } = mT, kB = TB("typeParameters");
    function PB(e, t) {
        const n = e.getValue();
        if (!vB(n, AB.Dangling)) return "";
        const r = !vB(n, AB.Line), o = dB(e, t, r);
        return r ? o : [
            o,
            mB
        ];
    }
    var OB = {
        printTypeParameter: function(e, t, n) {
            const r = e.getValue(), o = [], i = e.getParentNode();
            return "TSMappedType" === i.type ? (o.push("[", n("name")), r.constraint && o.push(" in ", n("constraint")), i.nameType && o.push(" as ", e.callParent(()=>n("nameType")
            )), o.push("]"), o) : (r.variance && o.push(n("variance")), o.push(n("name")), r.bound && o.push(": ", n("bound")), r.constraint && o.push(" extends ", n("constraint")), r.default && o.push(" = ", n("default")), o);
        },
        printTypeParameters: function(e294, t150, n, r) {
            const o = e294.getValue();
            if (!o[r]) return "";
            if (!Array.isArray(o[r])) return n(r);
            const i = e294.getNode(2), u = i && bB(i), s = e294.match((e)=>!(1 === e[r].length && wB(e[r][0]))
            , void 0, (e, t)=>"typeAnnotation" === t
            , (e)=>"Identifier" === e.type
            , NB);
            if (!s && (u || 0 === o[r].length || 1 === o[r].length && ("NullableTypeAnnotation" === o[r][0].type || BB(o[r][0])))) return [
                "<",
                hB(", ", e294.map(n, r)),
                PB(e294, t150),
                ">"
            ];
            const a = "TSTypeParameterInstantiation" === o.type ? "" : 1 === SB(o).length && FB(t150) && !o[r][0].constraint && "ArrowFunctionExpression" === e294.getParentNode().type ? "," : xB(t150, "all") ? CB(",") : "";
            return DB([
                "<",
                EB([
                    yB,
                    hB([
                        ",",
                        gB
                    ], e294.map(n, r))
                ]),
                a,
                yB,
                ">"
            ], {
                id: kB(o)
            });
        },
        getTypeParametersGroupId: kB
    };
    const { printComments: IB  } = tD, { printString: LB , printNumber: jB  } = dc, { isNumericLiteral: _B , isSimpleNumber: MB , isStringLiteral: RB , isStringPropSafeToUnquote: VB , rawText: $B  } = CC, { printAssignment: WB  } = mT, qB = new WeakMap;
    function UB(e296, t, n) {
        const r = e296.getNode();
        if (r.computed) return [
            "[",
            n("key"),
            "]"
        ];
        const o = e296.getParentNode(), { key: i  } = r;
        if ("ClassPrivateProperty" === r.type && "Identifier" === i.type) return [
            "#",
            n("key")
        ];
        if ("consistent" === t.quoteProps && !qB.has(o)) {
            const e295 = (o.properties || o.body || o.members).some((e)=>!e.computed && e.key && RB(e.key) && !VB(e, t)
            );
            qB.set(o, e295);
        }
        if (("Identifier" === i.type || _B(i) && MB(jB($B(i))) && String(i.value) === jB($B(i)) && "typescript" !== t.parser && "babel-ts" !== t.parser) && ("json" === t.parser || "consistent" === t.quoteProps && qB.get(o))) {
            const n = LB(JSON.stringify("Identifier" === i.type ? i.name : i.value.toString()), t);
            return e296.call((e)=>IB(e, n, t)
            , "key");
        }
        return VB(r, t) && ("as-needed" === t.quoteProps || "consistent" === t.quoteProps && !qB.get(o)) ? e296.call((e)=>IB(e, /^\d/.test(i.value) ? jB(i.value) : i.value, t)
        , "key") : n("key");
    }
    var zB = {
        printProperty: function(e, t, n) {
            return e.getValue().shorthand ? n("value") : WB(e, t, n, UB(e, t, n), ":", "value");
        },
        printPropertyKey: UB
    };
    const GB = Ty, { printDanglingComments: HB , printCommentsSeparately: JB  } = tD, XB = au, { getNextNonSpaceNonCommentCharacterIndex: YB  } = dc, { builders: { line: KB , softline: QB , group: ZB , indent: eN , ifBreak: tN , hardline: nN , join: rN , indentIfBreak: oN  } , utils: { removeLines: iN , willBreak: uN  }  } = Zc, { ArgExpansionBailout: sN  } = Cp, { getFunctionParameters: aN , hasLeadingOwnLineComment: cN , isFlowAnnotationComment: lN , isJsxNode: pN , isTemplateOnItsOwnLine: fN , shouldPrintComma: dN , startsWithNoLookaheadToken: hN , isBinaryish: gN , isLineComment: mN , hasComment: yN , getComments: DN , CommentCheckFlags: EN , isCallLikeExpression: CN , isCallExpression: bN , getCallArguments: vN , hasNakedLeftSide: AN , getLeftSide: FN  } = CC, { locEnd: xN  } = og, { printFunctionParameters: SN , shouldGroupFunctionParameters: wN  } = WT, { printPropertyKey: TN  } = zB, { printFunctionTypeParameters: BN  } = _x;
    function NN(e, t, n) {
        const r = e.getNode(), o = SN(e, n, t), i = PN(e, n, t), u = wN(r, i), s = [
            BN(e, t, n),
            ZB([
                u ? ZB(o) : o,
                i
            ])
        ];
        return r.body ? s.push(" ", n("body")) : s.push(t.semi ? ";" : ""), s;
    }
    function kN(e297, t151) {
        if ("always" === t151.arrowParens) return !1;
        if ("avoid" === t151.arrowParens) return (function(e) {
            const t = aN(e);
            return !(1 !== t.length || e.typeParameters || yN(e, EN.Dangling) || "Identifier" !== t[0].type || t[0].typeAnnotation || yN(t[0]) || t[0].optional || e.predicate || e.returnType);
        })(e297.getValue());
        return !1;
    }
    function PN(e, t, n) {
        const r = e.getValue(), o = t("returnType");
        if (r.returnType && lN(n.originalText, r.returnType)) return [
            " /*: ",
            o,
            " */"
        ];
        const i = [
            o
        ];
        return r.returnType && r.returnType.typeAnnotation && i.unshift(": "), r.predicate && i.push(r.returnType ? " " : ": ", t("predicate")), i;
    }
    function ON(e298, t152, n74) {
        const r62 = e298.getValue(), o = t152.semi ? ";" : "", i = [];
        r62.argument && (!function(e, t) {
            if (cN(e.originalText, t)) return !0;
            if (AN(t)) {
                let n, r = t;
                for(; n = FN(r);)if (r = n, cN(e.originalText, r)) return !0;
            }
            return !1;
        }(t152, r62.argument) ? gN(r62.argument) || "SequenceExpression" === r62.argument.type ? i.push(ZB([
            tN(" (", " "),
            eN([
                QB,
                n74("argument")
            ]),
            QB,
            tN(")")
        ])) : i.push(" ", n74("argument")) : i.push([
            " (",
            eN([
                nN,
                n74("argument")
            ]),
            nN,
            ")"
        ]));
        const u = DN(r62), s = XB(u), a = s && mN(s);
        return a && i.push(o), yN(r62, EN.Dangling) && i.push(" ", HB(e298, t152, !0)), a || i.push(o), i;
    }
    var IN = {
        printFunction: function(e, t, n, r) {
            const o = e.getValue();
            let i = !1;
            if (("FunctionDeclaration" === o.type || "FunctionExpression" === o.type) && r && r.expandLastArg) {
                const t = e.getParentNode();
                bN(t) && vN(t).length > 1 && (i = !0);
            }
            const u = [];
            "TSDeclareFunction" === o.type && o.declare && u.push("declare "), o.async && u.push("async "), o.generator ? u.push("function* ") : u.push("function "), o.id && u.push(t("id"));
            const s = SN(e, t, n, i), a = PN(e, t, n), c = wN(o, a);
            return u.push(BN(e, n, t), ZB([
                c ? ZB(s) : s,
                a
            ]), o.body ? " " : "", t("body")), !n.semi || !o.declare && o.body || u.push(";"), u;
        },
        printArrowFunction: function(e299, t153, n75, r63) {
            let o38 = e299.getValue();
            const i24 = [], u19 = [];
            let s13 = !1;
            if ((function a() {
                const c = function(e300, t, n76, r) {
                    const o = [];
                    if (e300.getValue().async && o.push("async "), kN(e300, t)) o.push(n76([
                        "params",
                        0
                    ]));
                    else {
                        const i = r && (r.expandLastArg || r.expandFirstArg);
                        let u = PN(e300, n76, t);
                        if (i) {
                            if (uN(u)) throw new sN;
                            u = ZB(iN(u));
                        }
                        o.push(ZB([
                            SN(e300, n76, t, i, !0),
                            u
                        ]));
                    }
                    const i = HB(e300, t, !0, (e)=>{
                        const n = YB(t.originalText, e, xN);
                        return !1 !== n && "=>" === t.originalText.slice(n, n + 2);
                    });
                    return i && o.push(" ", i), o;
                }(e299, t153, n75, r63);
                if (0 === i24.length) i24.push(c);
                else {
                    const { leading: n , trailing: r  } = JB(e299, t153);
                    i24.push([
                        n,
                        c
                    ]), u19.unshift(r);
                }
                s13 = s13 || o38.returnType && aN(o38).length > 0 || o38.typeParameters || aN(o38).some((e)=>"Identifier" !== e.type
                ), "ArrowFunctionExpression" !== o38.body.type || r63 && r63.expandLastArg ? u19.unshift(n75("body", r63)) : (o38 = o38.body, e299.call(a, "body"));
            })(), i24.length > 1) return (function(e, t, n, r, o, i) {
                const u = e.getName(), s = e.getParentNode(), a = CN(s) && "callee" === u, c = Boolean(t && t.assignmentLayout), l = "BlockStatement" !== i.body.type && "ObjectExpression" !== i.body.type && "SequenceExpression" !== i.body.type, p = a && l || t && "chain-tail-arrow-chain" === t.assignmentLayout, f = Symbol("arrow-chain");
                return "SequenceExpression" === i.body.type && (o = ZB([
                    "(",
                    eN([
                        QB,
                        o
                    ]),
                    QB,
                    ")"
                ])), ZB([
                    ZB(eN([
                        a || c ? QB : "",
                        ZB(rN([
                            " =>",
                            KB
                        ], n), {
                            shouldBreak: r
                        })
                    ]), {
                        id: f,
                        shouldBreak: p
                    }),
                    " =>",
                    oN(l ? eN([
                        KB,
                        o
                    ]) : [
                        " ",
                        o
                    ], {
                        groupId: f
                    }),
                    a ? tN(QB, "", {
                        groupId: f
                    }) : ""
                ]);
            })(e299, r63, i24, s13, u19, o38);
            const a8 = i24;
            if (a8.push(" =>"), !cN(t153.originalText, o38.body) && ("ArrayExpression" === o38.body.type || "ObjectExpression" === o38.body.type || "BlockStatement" === o38.body.type || pN(o38.body) || fN(o38.body, t153.originalText) || "ArrowFunctionExpression" === o38.body.type || "DoExpression" === o38.body.type)) return ZB([
                ...a8,
                " ",
                u19
            ]);
            if ("SequenceExpression" === o38.body.type) return ZB([
                ...a8,
                ZB([
                    " (",
                    eN([
                        QB,
                        u19
                    ]),
                    QB,
                    ")"
                ])
            ]);
            const c4 = (r63 && r63.expandLastArg || "JSXExpressionContainer" === e299.getParentNode().type) && !yN(o38), l3 = r63 && r63.expandLastArg && dN(t153, "all"), p5 = "ConditionalExpression" === o38.body.type && !hN(o38.body, !1);
            return ZB([
                ...a8,
                ZB([
                    eN([
                        KB,
                        p5 ? tN("", "(") : "",
                        u19,
                        p5 ? tN("", ")") : ""
                    ]),
                    c4 ? [
                        tN(l3 ? "," : ""),
                        QB
                    ] : ""
                ])
            ]);
        },
        printMethod: function(e301, t, n) {
            const r = e301.getNode(), { kind: o  } = r, i = r.value || r, u = [];
            return o && "init" !== o && "method" !== o && "constructor" !== o ? (GB.ok("get" === o || "set" === o), u.push(o, " ")) : i.async && u.push("async "), i.generator && u.push("*"), u.push(TN(e301, t, n), r.optional || r.key.optional ? "?" : ""), r === i ? u.push(NN(e301, t, n)) : "FunctionExpression" === i.type ? u.push(e301.call((e)=>NN(e, t, n)
            , "value")) : u.push(n("value")), u;
        },
        printReturnStatement: function(e, t, n) {
            return [
                "return",
                ON(e, t, n)
            ];
        },
        printThrowStatement: function(e, t, n) {
            return [
                "throw",
                ON(e, t, n)
            ];
        },
        printMethodInternal: NN,
        shouldPrintParamsWithoutParens: kN
    };
    const { isNonEmptyArray: LN , hasNewline: jN  } = dc, { builders: { line: _N , hardline: MN , join: RN , breakParent: VN , group: $N  }  } = Zc, { locStart: WN , locEnd: qN  } = og, { getParentExportDeclaration: UN  } = CC;
    function zN(e302, t) {
        return e302.decorators.some((e)=>jN(t.originalText, qN(e))
        );
    }
    function GN(e) {
        if ("ExportDefaultDeclaration" !== e.type && "ExportNamedDeclaration" !== e.type && "DeclareExportDeclaration" !== e.type) return !1;
        const t = e.declaration && e.declaration.decorators;
        return LN(t) && WN(e, {
            ignoreDecorators: !0
        }) > WN(t[0]);
    }
    var HN = {
        printDecorators: function(e, t, n) {
            const r = e.getValue(), { decorators: o  } = r;
            if (!LN(o) || GN(e.getParentNode())) return;
            const i = "ClassExpression" === r.type || "ClassDeclaration" === r.type || zN(r, t);
            return [
                UN(e) ? MN : i ? VN : "",
                RN(_N, e.map(n, "decorators")),
                _N
            ];
        },
        printClassMemberDecorators: function(e, t, n) {
            const r = e.getValue();
            return $N([
                RN(_N, e.map(n, "decorators")),
                zN(r, t) ? MN : _N
            ]);
        },
        printDecoratorsBeforeExport: function(e, t, n) {
            return [
                RN(MN, e.map(n, "declaration", "decorators")),
                MN
            ];
        },
        hasDecoratorsBeforeExport: GN
    };
    const { isNonEmptyArray: JN , createGroupIdMapper: XN  } = dc, { printComments: YN , printDanglingComments: KN  } = tD, { builders: { join: QN , line: ZN , hardline: ek , softline: tk , group: nk , indent: rk , ifBreak: ok  }  } = Zc, { hasComment: ik , CommentCheckFlags: uk  } = CC, { getTypeParametersGroupId: sk  } = OB, { printMethod: ak  } = IN, { printOptionalToken: ck , printTypeAnnotation: lk  } = _x, { printPropertyKey: pk  } = zB, { printAssignment: fk  } = mT, { printClassMemberDecorators: dk  } = HN;
    const hk = XN("heritageGroup");
    function gk(e303) {
        return e303.typeParameters && !ik(e303.typeParameters, uk.Trailing | uk.Line) && !function(e) {
            return [
                "superClass",
                "extends",
                "mixins",
                "implements"
            ].filter((t)=>Boolean(e[t])
            ).length > 1;
        }(e303);
    }
    function mk(e304, t154, n, r) {
        const o = e304.getValue();
        if (!JN(o[r])) return "";
        const i = KN(e304, t154, !0, (e)=>{
            let { marker: t  } = e;
            return t === r;
        });
        return [
            gk(o) ? ok(" ", ZN, {
                groupId: sk(o.typeParameters)
            }) : ZN,
            i,
            i && ek,
            r,
            nk(rk([
                ZN,
                QN([
                    ",",
                    ZN
                ], e304.map(n, r))
            ]))
        ];
    }
    function yk(e, t, n) {
        const r = n("superClass");
        return "AssignmentExpression" === e.getParentNode().type ? nk(ok([
            "(",
            rk([
                tk,
                r
            ]),
            tk,
            ")"
        ], r)) : r;
    }
    var Dk = {
        printClass: function(e305, t, n) {
            const r = e305.getValue(), o = [];
            r.declare && o.push("declare "), r.abstract && o.push("abstract "), o.push("class");
            const i = r.id && ik(r.id, uk.Trailing) || r.superClass && ik(r.superClass) || JN(r.extends) || JN(r.mixins) || JN(r.implements), u = [], s = [];
            if (r.id && u.push(" ", n("id")), u.push(n("typeParameters")), r.superClass) {
                const r = [
                    "extends ",
                    yk(e305, t, n),
                    n("superTypeParameters")
                ], o = e305.call((e)=>YN(e, r, t)
                , "superClass");
                i ? s.push(ZN, nk(o)) : s.push(" ", o);
            } else s.push(mk(e305, t, n, "extends"));
            if (s.push(mk(e305, t, n, "mixins"), mk(e305, t, n, "implements")), i) {
                let e;
                e = gk(r) ? [
                    ...u,
                    rk(s)
                ] : rk([
                    ...u,
                    s
                ]), o.push(nk(e, {
                    id: hk(r)
                }));
            } else o.push(...u, ...s);
            return o.push(" ", n("body")), o;
        },
        printClassMethod: function(e, t, n) {
            const r = e.getValue(), o = [];
            return JN(r.decorators) && o.push(dk(e, t, n)), r.accessibility && o.push(r.accessibility + " "), r.readonly && o.push("readonly "), r.declare && o.push("declare "), r.static && o.push("static "), ("TSAbstractMethodDefinition" === r.type || r.abstract) && o.push("abstract "), r.override && o.push("override "), o.push(ak(e, t, n)), o;
        },
        printClassProperty: function(e, t, n) {
            const r = e.getValue(), o = [], i = t.semi ? ";" : "";
            return JN(r.decorators) && o.push(dk(e, t, n)), r.accessibility && o.push(r.accessibility + " "), r.declare && o.push("declare "), r.static && o.push("static "), ("TSAbstractPropertyDefinition" === r.type || r.abstract) && o.push("abstract "), r.override && o.push("override "), r.readonly && o.push("readonly "), r.variance && o.push(n("variance")), o.push(pk(e, t, n), ck(e), lk(e, t, n)), [
                fk(e, t, n, o, " =", "value"),
                i
            ];
        },
        printHardlineAfterHeritage: function(e) {
            return ok(ek, "", {
                groupId: hk(e)
            });
        }
    };
    const { isNonEmptyArray: Ek  } = dc, { builders: { join: Ck , line: bk , group: vk , indent: Ak , ifBreak: Fk  }  } = Zc, { hasComment: xk , identity: Sk , CommentCheckFlags: wk  } = CC, { getTypeParametersGroupId: Tk  } = OB, { printTypeScriptModifiers: Bk  } = _x;
    var Nk = {
        printInterface: function(e, t, n) {
            const r = e.getValue(), o = [];
            r.declare && o.push("declare "), "TSInterfaceDeclaration" === r.type && o.push(r.abstract ? "abstract " : "", Bk(e, t, n)), o.push("interface");
            const i = [], u = [];
            "InterfaceTypeAnnotation" !== r.type && i.push(" ", n("id"), n("typeParameters"));
            const s = r.typeParameters && !xk(r.typeParameters, wk.Trailing | wk.Line);
            return Ek(r.extends) && u.push(s ? Fk(" ", bk, {
                groupId: Tk(r.typeParameters)
            }) : bk, "extends ", (1 === r.extends.length ? Sk : Ak)(Ck([
                ",",
                bk
            ], e.map(n, "extends")))), r.id && xk(r.id, wk.Trailing) || Ek(r.extends) ? s ? o.push(vk([
                ...i,
                Ak(u)
            ])) : o.push(vk(Ak([
                ...i,
                ...u
            ]))) : o.push(...i, ...u), o.push(" ", n("body")), vk(o);
        }
    };
    const { isNonEmptyArray: kk  } = dc, { builders: { softline: Pk , group: Ok , indent: Ik , join: Lk , line: jk , ifBreak: _k , hardline: Mk  }  } = Zc, { printDanglingComments: Rk  } = tD, { hasComment: Vk , CommentCheckFlags: $k , shouldPrintComma: Wk , needsHardlineAfterDanglingComment: qk  } = CC, { locStart: Uk , hasSameLoc: zk  } = og, { hasDecoratorsBeforeExport: Gk , printDecoratorsBeforeExport: Hk  } = HN;
    function Jk(e, t, n) {
        const r = e.getValue();
        if (!r.source) return "";
        const o = [];
        return Yk(r, t) || o.push(" from"), o.push(" ", n("source")), o;
    }
    function Xk(e306, t155, n) {
        const r = e306.getValue();
        if (Yk(r, t155)) return "";
        const o = [
            " "
        ];
        if (kk(r.specifiers)) {
            const i = [], u = [];
            if (e306.each(()=>{
                const t = e306.getValue().type;
                if ("ExportNamespaceSpecifier" === t || "ExportDefaultSpecifier" === t || "ImportNamespaceSpecifier" === t || "ImportDefaultSpecifier" === t) i.push(n());
                else {
                    if ("ExportSpecifier" !== t && "ImportSpecifier" !== t) throw new Error("Unknown specifier type ".concat(JSON.stringify(t)));
                    u.push(n());
                }
            }, "specifiers"), o.push(Lk(", ", i)), u.length > 0) {
                i.length > 0 && o.push(", ");
                u.length > 1 || i.length > 0 || r.specifiers.some((e)=>Vk(e)
                ) ? o.push(Ok([
                    "{",
                    Ik([
                        t155.bracketSpacing ? jk : Pk,
                        Lk([
                            ",",
                            jk
                        ], u)
                    ]),
                    _k(Wk(t155) ? "," : ""),
                    t155.bracketSpacing ? jk : Pk,
                    "}"
                ])) : o.push([
                    "{",
                    t155.bracketSpacing ? " " : "",
                    ...u,
                    t155.bracketSpacing ? " " : "",
                    "}"
                ]);
            }
        } else o.push("{}");
        return o;
    }
    function Yk(e, t) {
        const { type: n , importKind: r , source: o , specifiers: i  } = e;
        return "ImportDeclaration" === n && !kk(i) && "type" !== r && !/{\s*}/.test(t.originalText.slice(Uk(e), Uk(o)));
    }
    function Kk(e, t, n) {
        const r = e.getNode();
        return kk(r.assertions) ? [
            " assert {",
            t.bracketSpacing ? " " : "",
            Lk(", ", e.map(n, "assertions")),
            t.bracketSpacing ? " " : "",
            "}"
        ] : "";
    }
    var Qk = {
        printImportDeclaration: function(e, t, n) {
            const r = e.getValue(), o = t.semi ? ";" : "", i = [], { importKind: u  } = r;
            return i.push("import"), u && "value" !== u && i.push(" ", u), i.push(Xk(e, t, n), Jk(e, t, n), Kk(e, t, n), o), i;
        },
        printExportDeclaration: function(e307, t156, n77) {
            const r64 = e307.getValue(), o39 = [];
            Gk(r64) && o39.push(Hk(e307, t156, n77));
            const { type: i25 , exportKind: u , declaration: s  } = r64;
            return o39.push("export"), (r64.default || "ExportDefaultDeclaration" === i25) && o39.push(" default"), Vk(r64, $k.Dangling) && (o39.push(" ", Rk(e307, t156, !0)), qk(r64) && o39.push(Mk)), s ? o39.push(" ", n77("declaration")) : o39.push("type" === u ? " type" : "", Xk(e307, t156, n77), Jk(e307, t156, n77), Kk(e307, t156, n77)), (function(e, t) {
                if (!t.semi) return !1;
                const { type: n , declaration: r  } = e, o = e.default || "ExportDefaultDeclaration" === n;
                if (!r) return !0;
                const { type: i  } = r;
                if (o && "ClassDeclaration" !== i && "FunctionDeclaration" !== i && "TSInterfaceDeclaration" !== i && "DeclareClass" !== i && "DeclareFunction" !== i && "TSDeclareFunction" !== i && "EnumDeclaration" !== i) return !0;
                return !1;
            })(r64, t156) && o39.push(";"), o39;
        },
        printExportAllDeclaration: function(e, t, n) {
            const r = e.getValue(), o = t.semi ? ";" : "", i = [], { exportKind: u , exported: s  } = r;
            return i.push("export"), "type" === u && i.push(" type"), i.push(" *"), s && i.push(" as ", n("exported")), i.push(Jk(e, t, n), Kk(e, t, n), o), i;
        },
        printModuleSpecifier: function(e, t, n) {
            const r = e.getNode(), { type: o  } = r, i = [], u = "ImportSpecifier" === o ? r.importKind : r.exportKind;
            u && "value" !== u && i.push(u, " ");
            const s = o.startsWith("Import"), a = s ? "imported" : "local", c = s ? "local" : "exported";
            let l = "", p = "";
            return "ExportNamespaceSpecifier" === o || "ImportNamespaceSpecifier" === o ? l = "*" : r[a] && (l = n(a)), !r[c] || r[a] && zk(r[a], r[c]) || (p = n(c)), i.push(l, l && p ? " as " : "", p), i;
        }
    };
    const { printDanglingComments: Zk  } = tD, { builders: { line: eP , softline: tP , group: nP , indent: rP , ifBreak: oP , hardline: iP  }  } = Zc, { getLast: uP , hasNewlineInRange: sP , hasNewline: aP , isNonEmptyArray: cP  } = dc, { shouldPrintComma: lP , hasComment: pP , getComments: fP , CommentCheckFlags: dP , isNextLineEmpty: hP  } = CC, { locStart: gP , locEnd: mP  } = og, { printOptionalToken: yP , printTypeAnnotation: DP  } = _x, { shouldHugFunctionParameters: EP  } = WT, { shouldHugType: CP  } = fB, { printHardlineAfterHeritage: bP  } = Dk;
    var vP = {
        printObject: function(e308, t158, n78) {
            const r = t158.semi ? ";" : "", o = e308.getValue();
            let i;
            i = "TSTypeLiteral" === o.type ? "members" : "TSInterfaceBody" === o.type ? "body" : "properties";
            const u = "ObjectTypeAnnotation" === o.type, s = [
                i
            ];
            u && s.push("indexers", "callProperties", "internalSlots");
            const a = s.map((e)=>o[e][0]
            ).sort((e, t)=>gP(e) - gP(t)
            )[0], c = e308.getParentNode(0), l = u && c && ("InterfaceDeclaration" === c.type || "DeclareInterface" === c.type || "DeclareClass" === c.type) && "body" === e308.getName(), p = "TSInterfaceBody" === o.type || l || "ObjectPattern" === o.type && "FunctionDeclaration" !== c.type && "FunctionExpression" !== c.type && "ArrowFunctionExpression" !== c.type && "ObjectMethod" !== c.type && "ClassMethod" !== c.type && "ClassPrivateMethod" !== c.type && "AssignmentPattern" !== c.type && "CatchClause" !== c.type && o.properties.some((e)=>e.value && ("ObjectPattern" === e.value.type || "ArrayPattern" === e.value.type)
            ) || "ObjectPattern" !== o.type && a && sP(t158.originalText, gP(o), gP(a)), f = l ? ";" : "TSInterfaceBody" === o.type || "TSTypeLiteral" === o.type ? oP(r, ";") : ",", d = "RecordExpression" === o.type ? "#{" : o.exact ? "{|" : "{", h = o.exact ? "|}" : "}", g = [];
            for (const t157 of s)e308.each((e)=>{
                const t = e.getValue();
                g.push({
                    node: t,
                    printed: n78(),
                    loc: gP(t)
                });
            }, t157);
            s.length > 1 && g.sort((e, t)=>e.loc - t.loc
            );
            let m = [];
            const y = g.map((e)=>{
                const n = [
                    ...m,
                    nP(e.printed)
                ];
                return m = [
                    f,
                    eP
                ], "TSPropertySignature" !== e.node.type && "TSMethodSignature" !== e.node.type && "TSConstructSignatureDeclaration" !== e.node.type || !pP(e.node, dP.PrettierIgnore) || m.shift(), hP(e.node, t158) && m.push(iP), n;
            });
            if (o.inexact) {
                let n;
                if (pP(o, dP.Dangling)) {
                    const r = pP(o, dP.Line);
                    n = [
                        Zk(e308, t158, !0),
                        r || aP(t158.originalText, mP(uP(fP(o)))) ? iP : eP,
                        "..."
                    ];
                } else n = [
                    "..."
                ];
                y.push([
                    ...m,
                    ...n
                ]);
            }
            const D = uP(o[i]), E = !(o.inexact || D && "RestElement" === D.type || D && ("TSPropertySignature" === D.type || "TSCallSignatureDeclaration" === D.type || "TSMethodSignature" === D.type || "TSConstructSignatureDeclaration" === D.type) && pP(D, dP.PrettierIgnore));
            let C;
            if (0 === y.length) {
                if (!pP(o, dP.Dangling)) return [
                    d,
                    h,
                    DP(e308, t158, n78)
                ];
                C = nP([
                    d,
                    Zk(e308, t158),
                    tP,
                    h,
                    yP(e308),
                    DP(e308, t158, n78)
                ]);
            } else C = [
                l && cP(o.properties) ? bP(c) : "",
                d,
                rP([
                    t158.bracketSpacing ? eP : tP,
                    ...y
                ]),
                oP(E && ("," !== f || lP(t158)) ? f : ""),
                t158.bracketSpacing ? eP : tP,
                h,
                yP(e308),
                DP(e308, t158, n78)
            ];
            return e308.match((e)=>"ObjectPattern" === e.type && !e.decorators
            , (e, t, n)=>EP(e) && ("params" === t || "parameters" === t || "this" === t || "rest" === t) && 0 === n
            ) || e308.match(CP, (e, t)=>"typeAnnotation" === t
            , (e, t)=>"typeAnnotation" === t
            , (e, t, n)=>EP(e) && ("params" === t || "parameters" === t || "this" === t || "rest" === t) && 0 === n
            ) || !p && e308.match((e)=>"ObjectPattern" === e.type
            , (e)=>"AssignmentExpression" === e.type || "VariableDeclarator" === e.type
            ) ? C : nP(C, {
                shouldBreak: p
            });
        }
    };
    const AP = Ty, { printDanglingComments: FP  } = tD, { printString: xP , printNumber: SP  } = dc, { builders: { hardline: wP , softline: TP , group: BP , indent: NP  }  } = Zc, { getParentExportDeclaration: kP , isFunctionNotation: PP , isGetterOrSetter: OP , rawText: IP , shouldPrintComma: LP  } = CC, { locStart: jP , locEnd: _P  } = og, { printClass: MP  } = Dk, { printOpaqueType: RP , printTypeAlias: VP , printIntersectionType: $P , printUnionType: WP , printFunctionType: qP , printTupleType: UP , printIndexedAccessType: zP  } = fB, { printInterface: GP  } = Nk, { printTypeParameter: HP , printTypeParameters: JP  } = OB, { printExportDeclaration: XP , printExportAllDeclaration: YP  } = Qk, { printArrayItems: KP  } = uS, { printObject: QP  } = vP, { printPropertyKey: ZP  } = zB, { printOptionalToken: eO , printTypeAnnotation: tO , printRestSpread: nO  } = _x;
    function rO(e, t) {
        const n = kP(e);
        return n ? (AP.strictEqual(n.type, "DeclareExportDeclaration"), t) : [
            "declare ",
            t
        ];
    }
    var oO = {
        printFlow: function(e, t, n) {
            const r = e.getValue(), o = t.semi ? ";" : "", i = [];
            switch(r.type){
                case "DeclareClass":
                    return rO(e, MP(e, t, n));
                case "DeclareFunction":
                    return rO(e, [
                        "function ",
                        n("id"),
                        r.predicate ? " " : "",
                        n("predicate"),
                        o
                    ]);
                case "DeclareModule":
                    return rO(e, [
                        "module ",
                        n("id"),
                        " ",
                        n("body")
                    ]);
                case "DeclareModuleExports":
                    return rO(e, [
                        "module.exports",
                        ": ",
                        n("typeAnnotation"),
                        o
                    ]);
                case "DeclareVariable":
                    return rO(e, [
                        "var ",
                        n("id"),
                        o
                    ]);
                case "DeclareOpaqueType":
                    return rO(e, RP(e, t, n));
                case "DeclareInterface":
                    return rO(e, GP(e, t, n));
                case "DeclareTypeAlias":
                    return rO(e, VP(e, t, n));
                case "DeclareExportDeclaration":
                    return rO(e, XP(e, t, n));
                case "DeclareExportAllDeclaration":
                    return rO(e, YP(e, t, n));
                case "OpaqueType":
                    return RP(e, t, n);
                case "TypeAlias":
                    return VP(e, t, n);
                case "IntersectionTypeAnnotation":
                    return $P(e, t, n);
                case "UnionTypeAnnotation":
                    return WP(e, t, n);
                case "FunctionTypeAnnotation":
                    return qP(e, t, n);
                case "TupleTypeAnnotation":
                    return UP(e, t, n);
                case "GenericTypeAnnotation":
                    return [
                        n("id"),
                        JP(e, t, n, "typeParameters")
                    ];
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                    return zP(e, t, n);
                case "TypeAnnotation":
                    return n("typeAnnotation");
                case "TypeParameter":
                    return HP(e, t, n);
                case "TypeofTypeAnnotation":
                    return [
                        "typeof ",
                        n("argument")
                    ];
                case "ExistsTypeAnnotation":
                    return "*";
                case "EmptyTypeAnnotation":
                    return "empty";
                case "MixedTypeAnnotation":
                    return "mixed";
                case "ArrayTypeAnnotation":
                    return [
                        n("elementType"),
                        "[]"
                    ];
                case "BooleanLiteralTypeAnnotation":
                    return String(r.value);
                case "EnumDeclaration":
                    return [
                        "enum ",
                        n("id"),
                        " ",
                        n("body")
                    ];
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody":
                    if ("EnumSymbolBody" === r.type || r.explicitType) {
                        let e = null;
                        switch(r.type){
                            case "EnumBooleanBody":
                                e = "boolean";
                                break;
                            case "EnumNumberBody":
                                e = "number";
                                break;
                            case "EnumStringBody":
                                e = "string";
                                break;
                            case "EnumSymbolBody":
                                e = "symbol";
                        }
                        i.push("of ", e, " ");
                    }
                    if (0 !== r.members.length || r.hasUnknownMembers) {
                        const o = r.members.length > 0 ? [
                            wP,
                            KP(e, t, "members", n),
                            r.hasUnknownMembers || LP(t) ? "," : ""
                        ] : [];
                        i.push(BP([
                            "{",
                            NP([
                                ...o,
                                ...r.hasUnknownMembers ? [
                                    wP,
                                    "..."
                                ] : []
                            ]),
                            FP(e, t, !0),
                            wP,
                            "}"
                        ]));
                    } else i.push(BP([
                        "{",
                        FP(e, t),
                        TP,
                        "}"
                    ]));
                    return i;
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                    return [
                        n("id"),
                        " = ",
                        "object" == typeof r.init ? n("init") : String(r.init)
                    ];
                case "EnumDefaultedMember":
                    return n("id");
                case "FunctionTypeParam":
                    {
                        const t = r.name ? n("name") : e.getParentNode().this === r ? "this" : "";
                        return [
                            t,
                            eO(e),
                            t ? ": " : "",
                            n("typeAnnotation")
                        ];
                    }
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                    return GP(e, t, n);
                case "ClassImplements":
                case "InterfaceExtends":
                    return [
                        n("id"),
                        n("typeParameters")
                    ];
                case "NullableTypeAnnotation":
                    return [
                        "?",
                        n("typeAnnotation")
                    ];
                case "Variance":
                    {
                        const { kind: e  } = r;
                        return AP.ok("plus" === e || "minus" === e), "plus" === e ? "+" : "-";
                    }
                case "ObjectTypeCallProperty":
                    return r.static && i.push("static "), i.push(n("value")), i;
                case "ObjectTypeIndexer":
                    return [
                        r.variance ? n("variance") : "",
                        "[",
                        n("id"),
                        r.id ? ": " : "",
                        n("key"),
                        "]: ",
                        n("value")
                    ];
                case "ObjectTypeProperty":
                    {
                        let o = "";
                        return r.proto ? o = "proto " : r.static && (o = "static "), [
                            o,
                            OP(r) ? r.kind + " " : "",
                            r.variance ? n("variance") : "",
                            ZP(e, t, n),
                            eO(e),
                            PP(r) ? "" : ": ",
                            n("value")
                        ];
                    }
                case "ObjectTypeAnnotation":
                    return QP(e, t, n);
                case "ObjectTypeInternalSlot":
                    return [
                        r.static ? "static " : "",
                        "[[",
                        n("id"),
                        "]]",
                        eO(e),
                        r.method ? "" : ": ",
                        n("value")
                    ];
                case "ObjectTypeSpreadProperty":
                    return nO(e, t, n);
                case "QualifiedTypeIdentifier":
                    return [
                        n("qualification"),
                        ".",
                        n("id")
                    ];
                case "StringLiteralTypeAnnotation":
                    return xP(IP(r), t);
                case "NumberLiteralTypeAnnotation":
                    AP.strictEqual(typeof r.value, "number");
                case "BigIntLiteralTypeAnnotation":
                    return r.extra ? SP(r.extra.raw) : SP(r.raw);
                case "TypeCastExpression":
                    return [
                        "(",
                        n("expression"),
                        tO(e, t, n),
                        ")"
                    ];
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation":
                    {
                        const o = JP(e, t, n, "params");
                        if ("flow" === t.parser) {
                            const e = jP(r), n = _P(r), i = t.originalText.lastIndexOf("/*", e), u = t.originalText.indexOf("*/", n);
                            if (-1 !== i && -1 !== u) {
                                const e = t.originalText.slice(i + 2, u).trim();
                                if (e.startsWith("::") && !e.includes("/*") && !e.includes("*/")) return [
                                    "/*:: ",
                                    o,
                                    " */"
                                ];
                            }
                        }
                        return o;
                    }
                case "InferredPredicate":
                    return "%checks";
                case "DeclaredPredicate":
                    return [
                        "%checks(",
                        n("value"),
                        ")"
                    ];
                case "AnyTypeAnnotation":
                    return "any";
                case "BooleanTypeAnnotation":
                    return "boolean";
                case "BigIntTypeAnnotation":
                    return "bigint";
                case "NullLiteralTypeAnnotation":
                    return "null";
                case "NumberTypeAnnotation":
                    return "number";
                case "SymbolTypeAnnotation":
                    return "symbol";
                case "StringTypeAnnotation":
                    return "string";
                case "VoidTypeAnnotation":
                    return "void";
                case "ThisTypeAnnotation":
                    return "this";
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                    throw new Error("unprintable type: " + JSON.stringify(r.type));
            }
        }
    };
    const { hasNewlineInRange: iO  } = dc, { isJsxNode: uO , isBlockComment: sO , getComments: aO , isCallExpression: cO , isMemberExpression: lO  } = CC, { locStart: pO , locEnd: fO  } = og, { builders: { line: dO , softline: hO , group: gO , indent: mO , align: yO , ifBreak: DO , dedent: EO , breakParent: CO  }  } = Zc;
    function bO(e, t, n) {
        const r = e.getValue(), o = "ConditionalExpression" === r.type, i = o ? "alternate" : "falseType", u = e.getParentNode(), s = o ? n("test") : [
            n("checkType"),
            " ",
            "extends",
            " ",
            n("extendsType")
        ];
        return u.type === r.type && u[i] === r ? yO(2, s) : s;
    }
    const vO = new Map([
        [
            "AssignmentExpression",
            "right"
        ],
        [
            "VariableDeclarator",
            "init"
        ],
        [
            "ReturnStatement",
            "argument"
        ],
        [
            "ThrowStatement",
            "argument"
        ],
        [
            "UnaryExpression",
            "argument"
        ],
        [
            "YieldExpression",
            "argument"
        ]
    ]);
    var AO = {
        printTernary: function(e310, t159, n79) {
            const r65 = e310.getValue(), o40 = "ConditionalExpression" === r65.type, i = o40 ? "consequent" : "trueType", u = o40 ? "alternate" : "falseType", s = o40 ? [
                "test"
            ] : [
                "checkType",
                "extendsType"
            ], a = r65[i], c = r65[u], l = [];
            let p = !1;
            const f = e310.getParentNode(), d = f.type === r65.type && s.some((e)=>f[e] === r65
            );
            let h, g, m = f.type === r65.type && !d, y = 0;
            do g = h || r65, h = e310.getParentNode(y), y++;
            while (h && h.type === r65.type && s.every((e)=>h[e] !== g
            ))
            const D = h || f, E = g;
            if (o40 && (uO(r65[s[0]]) || uO(a) || uO(c) || (function(e) {
                const t = [
                    e
                ];
                for(let e309 = 0; e309 < t.length; e309++){
                    const n = t[e309];
                    for (const e of [
                        "test",
                        "consequent",
                        "alternate"
                    ]){
                        const r = n[e];
                        if (uO(r)) return !0;
                        "ConditionalExpression" === r.type && t.push(r);
                    }
                }
                return !1;
            })(E))) {
                p = !0, m = !0;
                const e311 = (e)=>[
                        DO("("),
                        mO([
                            hO,
                            e
                        ]),
                        hO,
                        DO(")")
                    ]
                , t = (e)=>"NullLiteral" === e.type || "Literal" === e.type && null === e.value || "Identifier" === e.type && "undefined" === e.name
                ;
                l.push(" ? ", t(a) ? n79(i) : e311(n79(i)), " : ", c.type === r65.type || t(c) ? n79(u) : e311(n79(u)));
            } else {
                const e = [
                    dO,
                    "? ",
                    a.type === r65.type ? DO("", "(") : "",
                    yO(2, n79(i)),
                    a.type === r65.type ? DO("", ")") : "",
                    dO,
                    ": ",
                    c.type === r65.type ? n79(u) : yO(2, n79(u))
                ];
                l.push(f.type !== r65.type || f[u] === r65 || d ? e : t159.useTabs ? EO(mO(e)) : yO(Math.max(0, t159.tabWidth - 2), e));
            }
            const C = [
                ...s.map((e)=>aO(r65[e])
                ),
                aO(a),
                aO(c)
            ].flat().some((e)=>sO(e) && iO(t159.originalText, pO(e), fO(e))
            ), b = !p && (lO(f) || "NGPipeExpression" === f.type && f.left === r65) && !f.computed, v = function(e) {
                const t = e.getValue();
                if ("ConditionalExpression" !== t.type) return !1;
                let n, r = t;
                for(let t160 = 0; !n; t160++){
                    const o = e.getParentNode(t160);
                    cO(o) && o.callee === r || lO(o) && o.object === r || "TSNonNullExpression" === o.type && o.expression === r ? r = o : "NewExpression" === o.type && o.callee === r || "TSAsExpression" === o.type && o.expression === r ? (n = e.getParentNode(t160 + 1), r = o) : n = o;
                }
                return r !== t && n[vO.get(n.type)] === r;
            }(e310), A = ((e)=>f === D ? gO(e, {
                    shouldBreak: C
                }) : C ? [
                    e,
                    CO
                ] : e
            )([
                bO(e310, 0, n79),
                m ? l : mO(l),
                o40 && b && !v ? hO : ""
            ]);
            return d || v ? gO([
                mO([
                    hO,
                    A
                ]),
                hO
            ]) : A;
        }
    };
    const { builders: { hardline: FO  }  } = Zc, xO = wA, { getLeftSidePathName: SO , hasNakedLeftSide: wO , isJsxNode: TO , isTheOnlyJsxElementInMarkdown: BO , hasComment: NO , CommentCheckFlags: kO , isNextLineEmpty: PO  } = CC, { shouldPrintParamsWithoutParens: OO  } = IN;
    function IO(e313, t161, n80, r) {
        const o41 = e313.getValue(), i = [], u = "ClassBody" === o41.type, s = function(e) {
            for(let t = e.length - 1; t >= 0; t--){
                const n = e[t];
                if ("EmptyStatement" !== n.type) return n;
            }
        }(o41[r]);
        return e313.each((e314, r, o)=>{
            const a = e314.getValue();
            if ("EmptyStatement" === a.type) return;
            const c = n80();
            t161.semi || u || BO(t161, e314) || !function(e315, t) {
                if ("ExpressionStatement" !== e315.getNode().type) return !1;
                return e315.call((e)=>LO(e, t)
                , "expression");
            }(e314, t161) ? i.push(c) : NO(a, kO.Leading) ? i.push(n80([], {
                needsSemi: !0
            })) : i.push(";", c), !t161.semi && u && jO(a) && (function(e, t) {
                const n = e.key && e.key.name;
                if (!("static" !== n && "get" !== n && "set" !== n || e.value || e.typeAnnotation)) return !0;
                if (!t) return !1;
                if (t.static || t.accessibility) return !1;
                if (!t.computed) {
                    const e = t.key && t.key.name;
                    if ("in" === e || "instanceof" === e) return !0;
                }
                if (jO(t) && t.variance && !t.static && !t.declare) return !0;
                switch(t.type){
                    case "ClassProperty":
                    case "PropertyDefinition":
                    case "TSAbstractPropertyDefinition":
                        return t.computed;
                    case "MethodDefinition":
                    case "TSAbstractMethodDefinition":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                        {
                            if ((t.value ? t.value.async : t.async) || "get" === t.kind || "set" === t.kind) return !1;
                            const e = t.value ? t.value.generator : t.generator;
                            return !(!t.computed && !e);
                        }
                    case "TSIndexSignature":
                        return !0;
                }
                return !1;
            })(a, o[r + 1]) && i.push(";"), a !== s && (i.push(FO), PO(a, t161) && i.push(FO));
        }, r), i;
    }
    function LO(e316, t) {
        const n = e316.getValue();
        switch(n.type){
            case "ParenthesizedExpression":
            case "TypeCastExpression":
            case "ArrayExpression":
            case "ArrayPattern":
            case "TemplateLiteral":
            case "TemplateElement":
            case "RegExpLiteral":
                return !0;
            case "ArrowFunctionExpression":
                if (!OO(e316, t)) return !0;
                break;
            case "UnaryExpression":
                {
                    const { prefix: e , operator: t  } = n;
                    if (e && ("+" === t || "-" === t)) return !0;
                    break;
                }
            case "BindExpression":
                if (!n.object) return !0;
                break;
            case "Literal":
                if (n.regex) return !0;
                break;
            default:
                if (TO(n)) return !0;
        }
        return !!xO(e316, t) || !!wO(n) && e316.call((e)=>LO(e, t)
        , ...SO(e316, n));
    }
    const jO = (e)=>{
        let { type: t  } = e;
        return "ClassProperty" === t || "PropertyDefinition" === t || "ClassPrivateProperty" === t;
    };
    var _O = {
        printBody: function(e, t, n) {
            return IO(e, t, n, "body");
        },
        printSwitchCaseConsequent: function(e, t, n) {
            return IO(e, t, n, "consequent");
        }
    };
    const { printDanglingComments: MO  } = tD, { isNonEmptyArray: RO  } = dc, { builders: { hardline: VO , indent: $O  }  } = Zc, { hasComment: WO , CommentCheckFlags: qO , isNextLineEmpty: UO  } = CC, { printHardlineAfterHeritage: zO  } = Dk, { printBody: GO  } = _O;
    function HO(e317, t, n) {
        const r66 = e317.getValue(), o42 = RO(r66.directives), i = r66.body.some((e)=>"EmptyStatement" !== e.type
        ), u = WO(r66, qO.Dangling);
        if (!o42 && !i && !u) return "";
        const s = [];
        if (o42 && e317.each((e, r, o)=>{
            s.push(n()), (r < o.length - 1 || i || u) && (s.push(VO), UO(e.getValue(), t) && s.push(VO));
        }, "directives"), i && s.push(GO(e317, t, n)), u && s.push(MO(e317, t, !0)), "Program" === r66.type) {
            const t = e317.getParentNode();
            t && "ModuleExpression" === t.type || s.push(VO);
        }
        return s;
    }
    var JO = {
        printBlock: function(e, t, n) {
            const r = e.getValue(), o = [];
            if ("StaticBlock" === r.type && o.push("static "), "ClassBody" === r.type && RO(r.body)) {
                const t = e.getParentNode();
                o.push(zO(t));
            }
            o.push("{");
            const i = HO(e, t, n);
            if (i) o.push($O([
                VO,
                i
            ]), VO);
            else {
                const t = e.getParentNode(), n = e.getParentNode(1);
                "ArrowFunctionExpression" === t.type || "FunctionExpression" === t.type || "FunctionDeclaration" === t.type || "ObjectMethod" === t.type || "ClassMethod" === t.type || "ClassPrivateMethod" === t.type || "ForStatement" === t.type || "WhileStatement" === t.type || "DoWhileStatement" === t.type || "DoExpression" === t.type || "CatchClause" === t.type && !n.finalizer || "TSModuleDeclaration" === t.type || "TSDeclareFunction" === t.type || "StaticBlock" === r.type || "ClassBody" === r.type || o.push(VO);
            }
            return o.push("}"), o;
        },
        printBlockBody: HO
    };
    const { printDanglingComments: XO  } = tD, { hasNewlineInRange: YO  } = dc, { builders: { join: KO , line: QO , hardline: ZO , softline: eI , group: tI , indent: nI , conditionalGroup: rI , ifBreak: oI  }  } = Zc, { isLiteral: iI , getTypeScriptMappedTypeModifier: uI , shouldPrintComma: sI , isCallExpression: aI , isMemberExpression: cI  } = CC, { locStart: lI , locEnd: pI  } = og, { printOptionalToken: fI , printTypeScriptModifiers: dI  } = _x, { printTernary: hI  } = AO, { printFunctionParameters: gI , shouldGroupFunctionParameters: mI  } = WT, { printTemplateLiteral: yI  } = VC, { printArrayItems: DI  } = uS, { printObject: EI  } = vP, { printClassProperty: CI , printClassMethod: bI  } = Dk, { printTypeParameter: vI , printTypeParameters: AI  } = OB, { printPropertyKey: FI  } = zB, { printFunction: xI , printMethodInternal: SI  } = IN, { printInterface: wI  } = Nk, { printBlock: TI  } = JO, { printTypeAlias: BI , printIntersectionType: NI , printUnionType: kI , printFunctionType: PI , printTupleType: OI , printIndexedAccessType: II  } = fB;
    var LI = {
        printTypescript: function(e, t, n) {
            const r = e.getValue();
            if (!r.type.startsWith("TS")) return;
            if (r.type.endsWith("Keyword")) return r.type.slice(2, -7).toLowerCase();
            const o = t.semi ? ";" : "", i = [];
            switch(r.type){
                case "TSThisType":
                    return "this";
                case "TSTypeAssertion":
                    {
                        const e = !("ArrayExpression" === r.expression.type || "ObjectExpression" === r.expression.type), t = tI([
                            "<",
                            nI([
                                eI,
                                n("typeAnnotation")
                            ]),
                            eI,
                            ">"
                        ]), o = [
                            oI("("),
                            nI([
                                eI,
                                n("expression")
                            ]),
                            eI,
                            oI(")")
                        ];
                        return e ? rI([
                            [
                                t,
                                n("expression")
                            ],
                            [
                                t,
                                tI(o, {
                                    shouldBreak: !0
                                })
                            ],
                            [
                                t,
                                n("expression")
                            ]
                        ]) : tI([
                            t,
                            n("expression")
                        ]);
                    }
                case "TSDeclareFunction":
                    return xI(e, n, t);
                case "TSExportAssignment":
                    return [
                        "export = ",
                        n("expression"),
                        o
                    ];
                case "TSModuleBlock":
                    return TI(e, t, n);
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                    return EI(e, t, n);
                case "TSTypeAliasDeclaration":
                    return BI(e, t, n);
                case "TSQualifiedName":
                    return KO(".", [
                        n("left"),
                        n("right")
                    ]);
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                    return bI(e, t, n);
                case "TSAbstractPropertyDefinition":
                    return CI(e, t, n);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                    return i.push(n("expression")), r.typeParameters && i.push(n("typeParameters")), i;
                case "TSTemplateLiteralType":
                    return yI(e, n, t);
                case "TSNamedTupleMember":
                    return [
                        n("label"),
                        r.optional ? "?" : "",
                        ": ",
                        n("elementType")
                    ];
                case "TSRestType":
                    return [
                        "...",
                        n("typeAnnotation")
                    ];
                case "TSOptionalType":
                    return [
                        n("typeAnnotation"),
                        "?"
                    ];
                case "TSInterfaceDeclaration":
                    return wI(e, t, n);
                case "TSClassImplements":
                    return [
                        n("expression"),
                        n("typeParameters")
                    ];
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                    return AI(e, t, n, "params");
                case "TSTypeParameter":
                    return vI(e, t, n);
                case "TSAsExpression":
                    {
                        i.push(n("expression"), " as ", n("typeAnnotation"));
                        const t = e.getParentNode();
                        return aI(t) && t.callee === r || cI(t) && t.object === r ? tI([
                            nI([
                                eI,
                                ...i
                            ]),
                            eI
                        ]) : i;
                    }
                case "TSArrayType":
                    return [
                        n("elementType"),
                        "[]"
                    ];
                case "TSPropertySignature":
                    return r.readonly && i.push("readonly "), i.push(FI(e, t, n), fI(e)), r.typeAnnotation && i.push(": ", n("typeAnnotation")), r.initializer && i.push(" = ", n("initializer")), i;
                case "TSParameterProperty":
                    return r.accessibility && i.push(r.accessibility + " "), r.export && i.push("export "), r.static && i.push("static "), r.override && i.push("override "), r.readonly && i.push("readonly "), i.push(n("parameter")), i;
                case "TSTypeQuery":
                    return [
                        "typeof ",
                        n("exprName")
                    ];
                case "TSIndexSignature":
                    {
                        const i = e.getParentNode(), u = r.parameters.length > 1 ? oI(sI(t) ? "," : "") : "", s = tI([
                            nI([
                                eI,
                                KO([
                                    ", ",
                                    eI
                                ], e.map(n, "parameters"))
                            ]),
                            u,
                            eI
                        ]);
                        return [
                            r.export ? "export " : "",
                            r.accessibility ? [
                                r.accessibility,
                                " "
                            ] : "",
                            r.static ? "static " : "",
                            r.readonly ? "readonly " : "",
                            r.declare ? "declare " : "",
                            "[",
                            r.parameters ? s : "",
                            r.typeAnnotation ? "]: " : "]",
                            r.typeAnnotation ? n("typeAnnotation") : "",
                            "ClassBody" === i.type ? o : ""
                        ];
                    }
                case "TSTypePredicate":
                    return [
                        r.asserts ? "asserts " : "",
                        n("parameterName"),
                        r.typeAnnotation ? [
                            " is ",
                            n("typeAnnotation")
                        ] : ""
                    ];
                case "TSNonNullExpression":
                    return [
                        n("expression"),
                        "!"
                    ];
                case "TSImportType":
                    return [
                        r.isTypeOf ? "typeof " : "",
                        "import(",
                        n(r.parameter ? "parameter" : "argument"),
                        ")",
                        r.qualifier ? [
                            ".",
                            n("qualifier")
                        ] : "",
                        AI(e, t, n, "typeParameters")
                    ];
                case "TSLiteralType":
                    return n("literal");
                case "TSIndexedAccessType":
                    return II(e, t, n);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType":
                    if ("TSConstructorType" === r.type && r.abstract && i.push("abstract "), "TSCallSignatureDeclaration" !== r.type && i.push("new "), i.push(tI(gI(e, n, t, !1, !0))), r.returnType || r.typeAnnotation) {
                        const e = "TSConstructorType" === r.type;
                        i.push(e ? " => " : ": ", n("returnType"), n("typeAnnotation"));
                    }
                    return i;
                case "TSTypeOperator":
                    return [
                        r.operator,
                        " ",
                        n("typeAnnotation")
                    ];
                case "TSMappedType":
                    {
                        const i = YO(t.originalText, lI(r), pI(r));
                        return tI([
                            "{",
                            nI([
                                t.bracketSpacing ? QO : eI,
                                r.readonly ? [
                                    uI(r.readonly, "readonly"),
                                    " "
                                ] : "",
                                dI(e, t, n),
                                n("typeParameter"),
                                r.optional ? uI(r.optional, "?") : "",
                                r.typeAnnotation ? ": " : "",
                                n("typeAnnotation"),
                                oI(o)
                            ]),
                            XO(e, t, !0),
                            t.bracketSpacing ? QO : eI,
                            "}"
                        ], {
                            shouldBreak: i
                        });
                    }
                case "TSMethodSignature":
                    {
                        const o = r.kind && "method" !== r.kind ? "".concat(r.kind, " ") : "";
                        i.push(r.accessibility ? [
                            r.accessibility,
                            " "
                        ] : "", o, r.export ? "export " : "", r.static ? "static " : "", r.readonly ? "readonly " : "", r.abstract ? "abstract " : "", r.declare ? "declare " : "", r.computed ? "[" : "", n("key"), r.computed ? "]" : "", fI(e));
                        const u = gI(e, n, t, !1, !0), s = r.returnType ? "returnType" : "typeAnnotation", a = r[s], c = a ? n(s) : "", l = mI(r, c);
                        return i.push(l ? tI(u) : u), a && i.push(": ", tI(c)), tI(i);
                    }
                case "TSNamespaceExportDeclaration":
                    return i.push("export as namespace ", n("id")), t.semi && i.push(";"), tI(i);
                case "TSEnumDeclaration":
                    return r.declare && i.push("declare "), r.modifiers && i.push(dI(e, t, n)), r.const && i.push("const "), i.push("enum ", n("id"), " "), 0 === r.members.length ? i.push(tI([
                        "{",
                        XO(e, t),
                        eI,
                        "}"
                    ])) : i.push(tI([
                        "{",
                        nI([
                            ZO,
                            DI(e, t, "members", n),
                            sI(t, "es5") ? "," : ""
                        ]),
                        XO(e, t, !0),
                        ZO,
                        "}"
                    ])), i;
                case "TSEnumMember":
                    return i.push(n("id")), r.initializer && i.push(" = ", n("initializer")), i;
                case "TSImportEqualsDeclaration":
                    return r.isExport && i.push("export "), i.push("import "), r.importKind && "value" !== r.importKind && i.push(r.importKind, " "), i.push(n("id"), " = ", n("moduleReference")), t.semi && i.push(";"), tI(i);
                case "TSExternalModuleReference":
                    return [
                        "require(",
                        n("expression"),
                        ")"
                    ];
                case "TSModuleDeclaration":
                    {
                        const u = e.getParentNode(), s = iI(r.id), a = "TSModuleDeclaration" === u.type, c = r.body && "TSModuleDeclaration" === r.body.type;
                        if (a) i.push(".");
                        else {
                            r.declare && i.push("declare "), i.push(dI(e, t, n));
                            const o = t.originalText.slice(lI(r), lI(r.id));
                            "Identifier" === r.id.type && "global" === r.id.name && !/namespace|module/.test(o) || i.push(s || /(?:^|\s)module(?:\s|$)/.test(o) ? "module " : "namespace ");
                        }
                        return i.push(n("id")), c ? i.push(n("body")) : r.body ? i.push(" ", tI(n("body"))) : i.push(o), i;
                    }
                case "TSConditionalType":
                    return hI(e, t, n);
                case "TSInferType":
                    return [
                        "infer",
                        " ",
                        n("typeParameter")
                    ];
                case "TSIntersectionType":
                    return NI(e, t, n);
                case "TSUnionType":
                    return kI(e, t, n);
                case "TSFunctionType":
                    return PI(e, t, n);
                case "TSTupleType":
                    return OI(e, t, n);
                case "TSTypeReference":
                    return [
                        n("typeName"),
                        AI(e, t, n, "typeParameters")
                    ];
                case "TSTypeAnnotation":
                    return n("typeAnnotation");
                case "TSEmptyBodyFunctionExpression":
                    return SI(e, t, n);
                case "TSJSDocAllType":
                    return "*";
                case "TSJSDocUnknownType":
                    return "?";
                case "TSJSDocNullableType":
                    return [
                        "?",
                        n("typeAnnotation")
                    ];
                case "TSJSDocNonNullableType":
                    return [
                        "!",
                        n("typeAnnotation")
                    ];
                default:
                    throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(r.type), "."));
            }
        }
    };
    const { hasNewline: jI  } = dc, { builders: { join: _I , hardline: MI  } , utils: { replaceTextEndOfLine: RI  }  } = Zc, { isLineComment: VI , isBlockComment: $I  } = CC, { locStart: WI , locEnd: qI  } = og;
    var UI = {
        printComment: function(e319, t162) {
            const n81 = e319.getValue();
            if (VI(n81)) return t162.originalText.slice(WI(n81), qI(n81)).trimEnd();
            if ($I(n81)) {
                if ((function(e320) {
                    const t = "*".concat(e320.value, "*").split("\n");
                    return t.length > 1 && t.every((e)=>"*" === e.trim()[0]
                    );
                })(n81)) {
                    const e321 = function(e324) {
                        const t = e324.value.split("\n");
                        return [
                            "/*",
                            _I(MI, t.map((e, n)=>0 === n ? e.trimEnd() : " " + (n < t.length - 1 ? e.trim() : e.trimStart())
                            )),
                            "*/"
                        ];
                    }(n81);
                    return n81.trailing && !jI(t162.originalText, WI(n81), {
                        backwards: !0
                    }) ? [
                        MI,
                        e321
                    ] : e321;
                }
                const e318 = qI(n81), r = "*-/" === t162.originalText.slice(e318 - 3, e318);
                return [
                    "/*",
                    RI(n81.value),
                    r ? "*-/" : "*/"
                ];
            }
            throw new Error("Not a comment: " + JSON.stringify(n81));
        }
    };
    const { printString: zI , printNumber: GI  } = dc;
    function HI(e) {
        return e.toLowerCase();
    }
    function JI(e) {
        let { pattern: t , flags: n  } = e;
        return n = [
            ...n
        ].sort().join(""), "/".concat(t, "/").concat(n);
    }
    var XI = {
        printLiteral: function(e, t) {
            const n = e.getNode();
            switch(n.type){
                case "RegExpLiteral":
                    return JI(n);
                case "BigIntLiteral":
                    return HI(n.bigint || n.extra.raw);
                case "NumericLiteral":
                    return GI(n.extra.raw);
                case "StringLiteral":
                    return zI(n.extra.raw, t);
                case "NullLiteral":
                    return "null";
                case "BooleanLiteral":
                    return String(n.value);
                case "DecimalLiteral":
                    return GI(n.value) + "m";
                case "Literal":
                    {
                        if (n.regex) return JI(n.regex);
                        if (n.bigint) return HI(n.raw);
                        if (n.decimal) return GI(n.decimal) + "m";
                        const { value: e  } = n;
                        return "number" == typeof e ? GI(n.raw) : "string" == typeof e ? zI(n.raw, t) : String(e);
                    }
            }
        }
    };
    const { printDanglingComments: YI  } = tD, { hasNewline: KI  } = dc, { builders: { join: QI , line: ZI , hardline: eL , softline: tL , group: nL , indent: rL  } , utils: { replaceTextEndOfLine: oL  }  } = Zc, iL = Nb, uL = Lb, { insertPragma: sL  } = iv, aL = lA, cL = wA, lL = TA, { hasFlowShorthandAnnotationComment: pL , hasComment: fL , CommentCheckFlags: dL , isTheOnlyJsxElementInMarkdown: hL , isBlockComment: gL , isLineComment: mL , isNextLineEmpty: yL , needsHardlineAfterDanglingComment: DL , rawText: EL , hasIgnoreComment: CL , isCallExpression: bL , isMemberExpression: vL  } = CC, { locStart: AL , locEnd: FL  } = og, { printHtmlBinding: xL , isVueEventBindingExpression: SL  } = IA, { printAngular: wL  } = mF, { printJsx: TL , hasJsxIgnoreComment: BL  } = ZF, { printFlow: NL  } = oO, { printTypescript: kL  } = LI, { printOptionalToken: PL , printBindExpressionCallee: OL , printTypeAnnotation: IL , adjustClause: LL , printRestSpread: jL  } = _x, { printImportDeclaration: _L , printExportDeclaration: ML , printExportAllDeclaration: RL , printModuleSpecifier: VL  } = Qk, { printTernary: $L  } = AO, { printTemplateLiteral: WL  } = VC, { printArray: qL  } = uS, { printObject: UL  } = vP, { printClass: zL , printClassMethod: GL , printClassProperty: HL  } = Dk, { printProperty: JL  } = zB, { printFunction: XL , printArrowFunction: YL , printMethod: KL , printReturnStatement: QL , printThrowStatement: ZL  } = IN, { printCallExpression: ej  } = Mw, { printVariableDeclarator: tj , printAssignmentExpression: nj  } = mT, { printBinaryishExpression: rj  } = sF, { printSwitchCaseConsequent: oj  } = _O, { printMemberExpression: ij  } = GS, { printBlock: uj , printBlockBody: sj  } = JO, { printComment: aj  } = UI, { printLiteral: cj  } = XI, { printDecorators: lj  } = HN;
    function pj(e, t) {
        const n = EL(e), r = n.slice(1, -1);
        if (r.includes('"') || r.includes("'")) return n;
        const o = t.singleQuote ? "'" : '"';
        return o + r + o;
    }
    var fj = {
        preprocess: lL,
        print: function(e325, t163, n82, r68) {
            const o43 = function(e326, t, n, r69) {
                const o44 = e326.getValue(), i27 = t.semi ? ";" : "";
                if (!o44) return "";
                if ("string" == typeof o44) return o44;
                for (const r67 of [
                    cj,
                    xL,
                    wL,
                    TL,
                    NL,
                    kL
                ]){
                    const o = r67(e326, t, n);
                    if (void 0 !== o) return o;
                }
                let u = [];
                switch(o44.type){
                    case "JsExpressionRoot":
                        return n("node");
                    case "JsonRoot":
                        return [
                            n("node"),
                            eL
                        ];
                    case "File":
                        return o44.program && o44.program.interpreter && u.push(n([
                            "program",
                            "interpreter"
                        ])), u.push(n("program")), u;
                    case "Program":
                        return sj(e326, t, n);
                    case "EmptyStatement":
                        return "";
                    case "ExpressionStatement":
                        if (o44.directive) return [
                            pj(o44.expression, t),
                            i27
                        ];
                        if ("__vue_event_binding" === t.parser) {
                            const t = e326.getParentNode();
                            if ("Program" === t.type && 1 === t.body.length && t.body[0] === o44) return [
                                n("expression"),
                                SL(o44.expression) ? ";" : ""
                            ];
                        }
                        return [
                            n("expression"),
                            hL(t, e326) ? "" : i27
                        ];
                    case "ParenthesizedExpression":
                        return !fL(o44.expression) && ("ObjectExpression" === o44.expression.type || "ArrayExpression" === o44.expression.type) ? [
                            "(",
                            n("expression"),
                            ")"
                        ] : nL([
                            "(",
                            rL([
                                tL,
                                n("expression")
                            ]),
                            tL,
                            ")"
                        ]);
                    case "AssignmentExpression":
                        return nj(e326, t, n);
                    case "VariableDeclarator":
                        return tj(e326, t, n);
                    case "BinaryExpression":
                    case "LogicalExpression":
                        return rj(e326, t, n);
                    case "AssignmentPattern":
                        return [
                            n("left"),
                            " = ",
                            n("right")
                        ];
                    case "OptionalMemberExpression":
                    case "MemberExpression":
                        return ij(e326, t, n);
                    case "MetaProperty":
                        return [
                            n("meta"),
                            ".",
                            n("property")
                        ];
                    case "BindExpression":
                        return o44.object && u.push(n("object")), u.push(nL(rL([
                            tL,
                            OL(e326, t, n)
                        ]))), u;
                    case "Identifier":
                        return [
                            o44.name,
                            PL(e326),
                            IL(e326, t, n)
                        ];
                    case "V8IntrinsicIdentifier":
                        return [
                            "%",
                            o44.name
                        ];
                    case "SpreadElement":
                    case "SpreadElementPattern":
                    case "SpreadProperty":
                    case "SpreadPropertyPattern":
                    case "RestElement":
                        return jL(e326, t, n);
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                        return XL(e326, n, t, r69);
                    case "ArrowFunctionExpression":
                        return YL(e326, t, n, r69);
                    case "YieldExpression":
                        return u.push("yield"), o44.delegate && u.push("*"), o44.argument && u.push(" ", n("argument")), u;
                    case "AwaitExpression":
                        if (u.push("await"), o44.argument) {
                            u.push(" ", n("argument"));
                            const t = e326.getParentNode();
                            if (bL(t) && t.callee === o44 || vL(t) && t.object === o44) {
                                u = [
                                    rL([
                                        tL,
                                        ...u
                                    ]),
                                    tL
                                ];
                                const t = e326.findAncestor((e)=>"AwaitExpression" === e.type || "BlockStatement" === e.type
                                );
                                if (!t || "AwaitExpression" !== t.type) return nL(u);
                            }
                        }
                        return u;
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                        return ML(e326, t, n);
                    case "ExportAllDeclaration":
                        return RL(e326, t, n);
                    case "ImportDeclaration":
                        return _L(e326, t, n);
                    case "ImportSpecifier":
                    case "ExportSpecifier":
                    case "ImportNamespaceSpecifier":
                    case "ExportNamespaceSpecifier":
                    case "ImportDefaultSpecifier":
                    case "ExportDefaultSpecifier":
                        return VL(e326, t, n);
                    case "ImportAttribute":
                        return [
                            n("key"),
                            ": ",
                            n("value")
                        ];
                    case "Import":
                        return "import";
                    case "BlockStatement":
                    case "StaticBlock":
                    case "ClassBody":
                        return uj(e326, t, n);
                    case "ThrowStatement":
                        return ZL(e326, t, n);
                    case "ReturnStatement":
                        return QL(e326, t, n);
                    case "NewExpression":
                    case "ImportExpression":
                    case "OptionalCallExpression":
                    case "CallExpression":
                        return ej(e326, t, n);
                    case "ObjectExpression":
                    case "ObjectPattern":
                    case "RecordExpression":
                        return UL(e326, t, n);
                    case "ObjectProperty":
                    case "Property":
                        return o44.method || "get" === o44.kind || "set" === o44.kind ? KL(e326, t, n) : JL(e326, t, n);
                    case "ObjectMethod":
                        return KL(e326, t, n);
                    case "Decorator":
                        return [
                            "@",
                            n("expression")
                        ];
                    case "ArrayExpression":
                    case "ArrayPattern":
                    case "TupleExpression":
                        return qL(e326, t, n);
                    case "SequenceExpression":
                        {
                            const t = e326.getParentNode(0);
                            if ("ExpressionStatement" === t.type || "ForStatement" === t.type) {
                                const t = [];
                                return e326.each((e, r)=>{
                                    0 === r ? t.push(n()) : t.push(",", rL([
                                        ZI,
                                        n()
                                    ]));
                                }, "expressions"), nL(t);
                            }
                            return nL(QI([
                                ",",
                                ZI
                            ], e326.map(n, "expressions")));
                        }
                    case "ThisExpression":
                        return "this";
                    case "Super":
                        return "super";
                    case "Directive":
                        return [
                            n("value"),
                            i27
                        ];
                    case "DirectiveLiteral":
                        return pj(o44, t);
                    case "UnaryExpression":
                        return u.push(o44.operator), /[a-z]$/.test(o44.operator) && u.push(" "), fL(o44.argument) ? u.push(nL([
                            "(",
                            rL([
                                tL,
                                n("argument")
                            ]),
                            tL,
                            ")"
                        ])) : u.push(n("argument")), u;
                    case "UpdateExpression":
                        return u.push(n("argument"), o44.operator), o44.prefix && u.reverse(), u;
                    case "ConditionalExpression":
                        return $L(e326, t, n);
                    case "VariableDeclaration":
                        {
                            const t = e326.map(n, "declarations"), r = e326.getParentNode(), s = "ForStatement" === r.type || "ForInStatement" === r.type || "ForOfStatement" === r.type, a = o44.declarations.some((e)=>e.init
                            );
                            let c;
                            return 1 !== t.length || fL(o44.declarations[0]) ? t.length > 0 && (c = rL(t[0])) : c = t[0], u = [
                                o44.declare ? "declare " : "",
                                o44.kind,
                                c ? [
                                    " ",
                                    c
                                ] : "",
                                rL(t.slice(1).map((e)=>[
                                        ",",
                                        a && !s ? eL : ZI,
                                        e
                                    ]
                                ))
                            ], s && r.body !== o44 || u.push(i27), nL(u);
                        }
                    case "WithStatement":
                        return nL([
                            "with (",
                            n("object"),
                            ")",
                            LL(o44.body, n("body"))
                        ]);
                    case "IfStatement":
                        {
                            const r = LL(o44.consequent, n("consequent")), i = nL([
                                "if (",
                                nL([
                                    rL([
                                        tL,
                                        n("test")
                                    ]),
                                    tL
                                ]),
                                ")",
                                r
                            ]);
                            if (u.push(i), o44.alternate) {
                                const r = fL(o44.consequent, dL.Trailing | dL.Line) || DL(o44), i = "BlockStatement" === o44.consequent.type && !r;
                                u.push(i ? " " : eL), fL(o44, dL.Dangling) && u.push(YI(e326, t, !0), r ? eL : " "), u.push("else", nL(LL(o44.alternate, n("alternate"), "IfStatement" === o44.alternate.type)));
                            }
                            return u;
                        }
                    case "ForStatement":
                        {
                            const r = LL(o44.body, n("body")), i = YI(e326, t, !0), u = i ? [
                                i,
                                tL
                            ] : "";
                            return o44.init || o44.test || o44.update ? [
                                u,
                                nL([
                                    "for (",
                                    nL([
                                        rL([
                                            tL,
                                            n("init"),
                                            ";",
                                            ZI,
                                            n("test"),
                                            ";",
                                            ZI,
                                            n("update")
                                        ]),
                                        tL
                                    ]),
                                    ")",
                                    r
                                ])
                            ] : [
                                u,
                                nL([
                                    "for (;;)",
                                    r
                                ])
                            ];
                        }
                    case "WhileStatement":
                        return nL([
                            "while (",
                            nL([
                                rL([
                                    tL,
                                    n("test")
                                ]),
                                tL
                            ]),
                            ")",
                            LL(o44.body, n("body"))
                        ]);
                    case "ForInStatement":
                        return nL([
                            "for (",
                            n("left"),
                            " in ",
                            n("right"),
                            ")",
                            LL(o44.body, n("body"))
                        ]);
                    case "ForOfStatement":
                        return nL([
                            "for",
                            o44.await ? " await" : "",
                            " (",
                            n("left"),
                            " of ",
                            n("right"),
                            ")",
                            LL(o44.body, n("body"))
                        ]);
                    case "DoWhileStatement":
                        {
                            const e = LL(o44.body, n("body"));
                            return u = [
                                nL([
                                    "do",
                                    e
                                ])
                            ], "BlockStatement" === o44.body.type ? u.push(" ") : u.push(eL), u.push("while (", nL([
                                rL([
                                    tL,
                                    n("test")
                                ]),
                                tL
                            ]), ")", i27), u;
                        }
                    case "DoExpression":
                        return [
                            o44.async ? "async " : "",
                            "do ",
                            n("body")
                        ];
                    case "BreakStatement":
                        return u.push("break"), o44.label && u.push(" ", n("label")), u.push(i27), u;
                    case "ContinueStatement":
                        return u.push("continue"), o44.label && u.push(" ", n("label")), u.push(i27), u;
                    case "LabeledStatement":
                        return "EmptyStatement" === o44.body.type ? [
                            n("label"),
                            ":;"
                        ] : [
                            n("label"),
                            ": ",
                            n("body")
                        ];
                    case "TryStatement":
                        return [
                            "try ",
                            n("block"),
                            o44.handler ? [
                                " ",
                                n("handler")
                            ] : "",
                            o44.finalizer ? [
                                " finally ",
                                n("finalizer")
                            ] : ""
                        ];
                    case "CatchClause":
                        if (o44.param) {
                            const e327 = fL(o44.param, (e)=>!gL(e) || e.leading && KI(t.originalText, FL(e)) || e.trailing && KI(t.originalText, AL(e), {
                                    backwards: !0
                                })
                            ), r = n("param");
                            return [
                                "catch ",
                                e327 ? [
                                    "(",
                                    rL([
                                        tL,
                                        r
                                    ]),
                                    tL,
                                    ") "
                                ] : [
                                    "(",
                                    r,
                                    ") "
                                ],
                                n("body")
                            ];
                        }
                        return [
                            "catch ",
                            n("body")
                        ];
                    case "SwitchStatement":
                        return [
                            nL([
                                "switch (",
                                rL([
                                    tL,
                                    n("discriminant")
                                ]),
                                tL,
                                ")"
                            ]),
                            " {",
                            o44.cases.length > 0 ? rL([
                                eL,
                                QI(eL, e326.map((e, r, o)=>{
                                    const i = e.getValue();
                                    return [
                                        n(),
                                        r !== o.length - 1 && yL(i, t) ? eL : ""
                                    ];
                                }, "cases"))
                            ]) : "",
                            eL,
                            "}"
                        ];
                    case "SwitchCase":
                        {
                            o44.test ? u.push("case ", n("test"), ":") : u.push("default:");
                            const r = o44.consequent.filter((e)=>"EmptyStatement" !== e.type
                            );
                            if (r.length > 0) {
                                const o = oj(e326, t, n);
                                u.push(1 === r.length && "BlockStatement" === r[0].type ? [
                                    " ",
                                    o
                                ] : rL([
                                    eL,
                                    o
                                ]));
                            }
                            return u;
                        }
                    case "DebuggerStatement":
                        return [
                            "debugger",
                            i27
                        ];
                    case "ClassDeclaration":
                    case "ClassExpression":
                        return zL(e326, t, n);
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "MethodDefinition":
                        return GL(e326, t, n);
                    case "ClassProperty":
                    case "PropertyDefinition":
                    case "ClassPrivateProperty":
                        return HL(e326, t, n);
                    case "TemplateElement":
                        return oL(o44.value.raw);
                    case "TemplateLiteral":
                        return WL(e326, n, t);
                    case "TaggedTemplateExpression":
                        return [
                            n("tag"),
                            n("typeParameters"),
                            n("quasi")
                        ];
                    case "PrivateIdentifier":
                        return [
                            "#",
                            n("name")
                        ];
                    case "PrivateName":
                        return [
                            "#",
                            n("id")
                        ];
                    case "InterpreterDirective":
                        return u.push("#!", o44.value, eL), yL(o44, t) && u.push(eL), u;
                    case "TopicReference":
                        return "%";
                    case "ArgumentPlaceholder":
                        return "?";
                    case "ModuleExpression":
                        {
                            u.push("module {");
                            const e = n("body");
                            return e && u.push(rL([
                                eL,
                                e
                            ]), eL), u.push("}"), u;
                        }
                    default:
                        throw new Error("unknown type: " + JSON.stringify(o44.type));
                }
            }(e325, t163, n82, r68);
            if (!o43) return "";
            const i26 = e325.getValue(), { type: u20  } = i26;
            if ("ClassMethod" === u20 || "ClassPrivateMethod" === u20 || "ClassProperty" === u20 || "PropertyDefinition" === u20 || "TSAbstractPropertyDefinition" === u20 || "ClassPrivateProperty" === u20 || "MethodDefinition" === u20 || "TSAbstractMethodDefinition" === u20 || "TSDeclareMethod" === u20) return o43;
            const s14 = lj(e325, t163, n82);
            if (s14) return nL([
                ...s14,
                o43
            ]);
            if (!cL(e325, t163)) return r68 && r68.needsSemi ? [
                ";",
                o43
            ] : o43;
            const a9 = [
                r68 && r68.needsSemi ? ";(" : "(",
                o43
            ];
            if (pL(i26)) {
                const [e] = i26.trailingComments;
                a9.push(" /*", e.value.trimStart(), "*/"), e.printed = !0;
            }
            return a9.push(")"), a9;
        },
        embed: iL,
        insertPragma: sL,
        massageAstNode: uL,
        hasPrettierIgnore: (e)=>CL(e) || BL(e)
        ,
        willPrintOwnComments: aL.willPrintOwnComments,
        canAttachComment: function(e) {
            return e.type && !gL(e) && !mL(e) && "EmptyStatement" !== e.type && "TemplateElement" !== e.type && "Import" !== e.type && "TSEmptyBodyFunctionExpression" !== e.type;
        },
        printComment: aj,
        isBlockComment: gL,
        handleComments: {
            avoidAstMutation: !0,
            ownLine: aL.handleOwnLineComment,
            endOfLine: aL.handleEndOfLineComment,
            remaining: aL.handleRemainingComment
        },
        getCommentChildNodes: aL.getCommentChildNodes
    };
    const { builders: { hardline: dj , indent: hj , join: gj  }  } = Zc, mj = TA;
    const yj = new Set([
        "start",
        "end",
        "extra",
        "loc",
        "comments",
        "leadingComments",
        "trailingComments",
        "innerComments",
        "errors",
        "range",
        "tokens"
    ]);
    function Dj(e, t) {
        const { type: n  } = e;
        if ("ObjectProperty" !== n || "Identifier" !== e.key.type) {
            if ("UnaryExpression" === n && "+" === e.operator) return t.argument;
            if ("ArrayExpression" !== n) return "TemplateLiteral" === n ? {
                type: "StringLiteral",
                value: e.quasis[0].value.cooked
            } : void 0;
            for (const [n83, r] of e.elements.entries())null === r && t.elements.splice(n83, 0, {
                type: "NullLiteral"
            });
        } else t.key = {
            type: "StringLiteral",
            value: e.key.name
        };
    }
    Dj.ignoredProperties = yj;
    var Ej = {
        preprocess: mj,
        print: function(e, t, n) {
            const r = e.getValue();
            switch(r.type){
                case "JsonRoot":
                    return [
                        n("node"),
                        dj
                    ];
                case "ArrayExpression":
                    {
                        if (0 === r.elements.length) return "[]";
                        const t = e.map(()=>null === e.getValue() ? "null" : n()
                        , "elements");
                        return [
                            "[",
                            hj([
                                dj,
                                gj([
                                    ",",
                                    dj
                                ], t)
                            ]),
                            dj,
                            "]"
                        ];
                    }
                case "ObjectExpression":
                    return 0 === r.properties.length ? "{}" : [
                        "{",
                        hj([
                            dj,
                            gj([
                                ",",
                                dj
                            ], e.map(n, "properties"))
                        ]),
                        dj,
                        "}"
                    ];
                case "ObjectProperty":
                    return [
                        n("key"),
                        ": ",
                        n("value")
                    ];
                case "UnaryExpression":
                    return [
                        "+" === r.operator ? "" : r.operator,
                        n("argument")
                    ];
                case "NullLiteral":
                    return "null";
                case "BooleanLiteral":
                    return r.value ? "true" : "false";
                case "StringLiteral":
                case "NumericLiteral":
                    return JSON.stringify(r.value);
                case "Identifier":
                    {
                        const t = e.getParentNode();
                        return t && "ObjectProperty" === t.type && t.key === r ? JSON.stringify(r.name) : r.name;
                    }
                case "TemplateLiteral":
                    return n([
                        "quasis",
                        0
                    ]);
                case "TemplateElement":
                    return JSON.stringify(r.value.cooked);
                default:
                    throw new Error("unknown type: " + JSON.stringify(r.type));
            }
        },
        massageAstNode: Dj
    };
    const Cj = "Common";
    var bj = {
        bracketSpacing: {
            since: "0.0.0",
            category: Cj,
            type: "boolean",
            default: !0,
            description: "Print spaces between brackets.",
            oppositeDescription: "Do not print spaces between brackets."
        },
        singleQuote: {
            since: "0.0.0",
            category: Cj,
            type: "boolean",
            default: !1,
            description: "Use single quotes instead of double quotes."
        },
        proseWrap: {
            since: "1.8.2",
            category: Cj,
            type: "choice",
            default: [
                {
                    since: "1.8.2",
                    value: !0
                },
                {
                    since: "1.9.0",
                    value: "preserve"
                }
            ],
            description: "How to wrap prose.",
            choices: [
                {
                    since: "1.9.0",
                    value: "always",
                    description: "Wrap prose if it exceeds the print width."
                },
                {
                    since: "1.9.0",
                    value: "never",
                    description: "Do not wrap prose."
                },
                {
                    since: "1.9.0",
                    value: "preserve",
                    description: "Wrap prose as-is."
                }
            ]
        },
        bracketSameLine: {
            since: "2.4.0",
            category: Cj,
            type: "boolean",
            default: !1,
            description: "Put > of opening tags on the last line instead of on a new line."
        }
    };
    const vj = "JavaScript";
    var Aj = {
        name: "JavaScript",
        type: "programming",
        tmScope: "source.js",
        aceMode: "javascript",
        codemirrorMode: "javascript",
        codemirrorMimeType: "text/javascript",
        color: "#f1e05a",
        aliases: [
            "js",
            "node"
        ],
        extensions: [
            ".js",
            "._js",
            ".bones",
            ".cjs",
            ".es",
            ".es6",
            ".frag",
            ".gs",
            ".jake",
            ".jsb",
            ".jscad",
            ".jsfl",
            ".jsm",
            ".jss",
            ".jsx",
            ".mjs",
            ".njs",
            ".pac",
            ".sjs",
            ".ssjs",
            ".xsjs",
            ".xsjslib"
        ],
        filenames: [
            "Jakefile"
        ],
        interpreters: [
            "chakra",
            "d8",
            "gjs",
            "js",
            "node",
            "nodejs",
            "qjs",
            "rhino",
            "v8",
            "v8-shell"
        ],
        languageId: 183
    }, Fj = {
        name: "TypeScript",
        type: "programming",
        color: "#2b7489",
        aliases: [
            "ts"
        ],
        interpreters: [
            "deno",
            "ts-node"
        ],
        extensions: [
            ".ts"
        ],
        tmScope: "source.ts",
        aceMode: "typescript",
        codemirrorMode: "javascript",
        codemirrorMimeType: "application/typescript",
        languageId: 378
    }, xj = {
        name: "TSX",
        type: "programming",
        group: "TypeScript",
        extensions: [
            ".tsx"
        ],
        tmScope: "source.tsx",
        aceMode: "javascript",
        codemirrorMode: "jsx",
        codemirrorMimeType: "text/jsx",
        languageId: 94901924
    }, Sj = {
        name: "JSON",
        type: "data",
        tmScope: "source.json",
        aceMode: "json",
        codemirrorMode: "javascript",
        codemirrorMimeType: "application/json",
        extensions: [
            ".json",
            ".avsc",
            ".geojson",
            ".gltf",
            ".har",
            ".ice",
            ".JSON-tmLanguage",
            ".jsonl",
            ".mcmeta",
            ".tfstate",
            ".tfstate.backup",
            ".topojson",
            ".webapp",
            ".webmanifest",
            ".yy",
            ".yyp"
        ],
        filenames: [
            ".arcconfig",
            ".htmlhintrc",
            ".imgbotconfig",
            ".tern-config",
            ".tern-project",
            ".watchmanconfig",
            "Pipfile.lock",
            "composer.lock",
            "mcmod.info"
        ],
        languageId: 174
    }, wj = {
        name: "JSON with Comments",
        type: "data",
        group: "JSON",
        tmScope: "source.js",
        aceMode: "javascript",
        codemirrorMode: "javascript",
        codemirrorMimeType: "text/javascript",
        aliases: [
            "jsonc"
        ],
        extensions: [
            ".jsonc",
            ".sublime-build",
            ".sublime-commands",
            ".sublime-completions",
            ".sublime-keymap",
            ".sublime-macro",
            ".sublime-menu",
            ".sublime-mousemap",
            ".sublime-project",
            ".sublime-settings",
            ".sublime-theme",
            ".sublime-workspace",
            ".sublime_metrics",
            ".sublime_session"
        ],
        filenames: [
            ".babelrc",
            ".eslintrc.json",
            ".jscsrc",
            ".jshintrc",
            ".jslintrc",
            "api-extractor.json",
            "devcontainer.json",
            "jsconfig.json",
            "language-configuration.json",
            "tsconfig.json",
            "tslint.json"
        ],
        languageId: 423
    }, Tj = {
        name: "JSON5",
        type: "data",
        extensions: [
            ".json5"
        ],
        tmScope: "source.js",
        aceMode: "javascript",
        codemirrorMode: "javascript",
        codemirrorMimeType: "application/json",
        languageId: 175
    };
    const Bj = bE, Nj = fj, kj = Ej, Pj = {
        arrowParens: {
            since: "1.9.0",
            category: vj,
            type: "choice",
            default: [
                {
                    since: "1.9.0",
                    value: "avoid"
                },
                {
                    since: "2.0.0",
                    value: "always"
                }
            ],
            description: "Include parentheses around a sole arrow function parameter.",
            choices: [
                {
                    value: "always",
                    description: "Always include parens. Example: `(x) => x`"
                },
                {
                    value: "avoid",
                    description: "Omit parens when possible. Example: `x => x`"
                }
            ]
        },
        bracketSameLine: bj.bracketSameLine,
        bracketSpacing: bj.bracketSpacing,
        jsxBracketSameLine: {
            since: "0.17.0",
            category: vj,
            type: "boolean",
            description: "Put > on the last line instead of at a new line.",
            deprecated: "2.4.0"
        },
        semi: {
            since: "1.0.0",
            category: vj,
            type: "boolean",
            default: !0,
            description: "Print semicolons.",
            oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
        },
        singleQuote: bj.singleQuote,
        jsxSingleQuote: {
            since: "1.15.0",
            category: vj,
            type: "boolean",
            default: !1,
            description: "Use single quotes in JSX."
        },
        quoteProps: {
            since: "1.17.0",
            category: vj,
            type: "choice",
            default: "as-needed",
            description: "Change when properties in objects are quoted.",
            choices: [
                {
                    value: "as-needed",
                    description: "Only add quotes around object properties where required."
                },
                {
                    value: "consistent",
                    description: "If at least one property in an object requires quotes, quote all properties."
                },
                {
                    value: "preserve",
                    description: "Respect the input use of quotes in object properties."
                }
            ]
        },
        trailingComma: {
            since: "0.0.0",
            category: vj,
            type: "choice",
            default: [
                {
                    since: "0.0.0",
                    value: !1
                },
                {
                    since: "0.19.0",
                    value: "none"
                },
                {
                    since: "2.0.0",
                    value: "es5"
                }
            ],
            description: "Print trailing commas wherever possible when multi-line.",
            choices: [
                {
                    value: "es5",
                    description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
                },
                {
                    value: "none",
                    description: "No trailing commas."
                },
                {
                    value: "all",
                    description: "Trailing commas wherever possible (including function arguments)."
                }
            ]
        }
    }, Oj = [
        Bj(Aj, (e329)=>({
                since: "0.0.0",
                parsers: [
                    "babel",
                    "espree",
                    "meriyah",
                    "babel-flow",
                    "babel-ts",
                    "flow",
                    "typescript"
                ],
                vscodeLanguageIds: [
                    "javascript",
                    "mongo"
                ],
                interpreters: [
                    ...e329.interpreters,
                    "zx"
                ],
                extensions: [
                    ...e329.extensions.filter((e)=>".jsx" !== e
                    ),
                    ".wxs"
                ]
            })
        ),
        Bj(Aj, ()=>({
                name: "Flow",
                since: "0.0.0",
                parsers: [
                    "flow",
                    "babel-flow"
                ],
                vscodeLanguageIds: [
                    "javascript"
                ],
                aliases: [],
                filenames: [],
                extensions: [
                    ".js.flow"
                ]
            })
        ),
        Bj(Aj, ()=>({
                name: "JSX",
                since: "0.0.0",
                parsers: [
                    "babel",
                    "babel-flow",
                    "babel-ts",
                    "flow",
                    "typescript",
                    "espree",
                    "meriyah"
                ],
                vscodeLanguageIds: [
                    "javascriptreact"
                ],
                aliases: void 0,
                filenames: void 0,
                extensions: [
                    ".jsx"
                ],
                group: "JavaScript",
                interpreters: void 0,
                tmScope: "source.js.jsx",
                aceMode: "javascript",
                codemirrorMode: "jsx",
                codemirrorMimeType: "text/jsx",
                color: void 0
            })
        ),
        Bj(Fj, (e)=>({
                since: "1.4.0",
                parsers: [
                    "typescript",
                    "babel-ts"
                ],
                vscodeLanguageIds: [
                    "typescript"
                ],
                extensions: [
                    ...e.extensions,
                    ".mts",
                    ".cts"
                ]
            })
        ),
        Bj(xj, ()=>({
                since: "1.4.0",
                parsers: [
                    "typescript",
                    "babel-ts"
                ],
                vscodeLanguageIds: [
                    "typescriptreact"
                ]
            })
        ),
        Bj(Sj, ()=>({
                name: "JSON.stringify",
                since: "1.13.0",
                parsers: [
                    "json-stringify"
                ],
                vscodeLanguageIds: [
                    "json"
                ],
                extensions: [],
                filenames: [
                    "package.json",
                    "package-lock.json",
                    "composer.json"
                ]
            })
        ),
        Bj(Sj, (e330)=>({
                since: "1.5.0",
                parsers: [
                    "json"
                ],
                vscodeLanguageIds: [
                    "json"
                ],
                extensions: e330.extensions.filter((e)=>".jsonl" !== e
                )
            })
        ),
        Bj(wj, (e)=>({
                since: "1.5.0",
                parsers: [
                    "json"
                ],
                vscodeLanguageIds: [
                    "jsonc"
                ],
                filenames: [
                    ...e.filenames,
                    ".eslintrc"
                ]
            })
        ),
        Bj(Tj, ()=>({
                since: "1.13.0",
                parsers: [
                    "json5"
                ],
                vscodeLanguageIds: [
                    "json5"
                ]
            })
        )
    ];
    var Ij = {
        languages: Oj,
        options: Pj,
        printers: {
            estree: Nj,
            "estree-json": kj
        },
        parsers: undefined
    };
    const { isFrontMatterNode: Lj  } = dc, jj = au, _j = new Set([
        "raw",
        "raws",
        "sourceIndex",
        "source",
        "before",
        "after",
        "trailingComma"
    ]);
    function Mj(e331, t164, n84) {
        if (Lj(e331) && "yaml" === e331.lang && delete t164.value, "css-comment" === e331.type && "css-root" === n84.type && n84.nodes.length > 0) {
            if ((n84.nodes[0] === e331 || Lj(n84.nodes[0]) && n84.nodes[1] === e331) && (delete t164.text, /^\*\s*@(?:format|prettier)\s*$/.test(e331.text))) return null;
            if ("css-root" === n84.type && jj(n84.nodes) === e331) return null;
        }
        if ("value-root" === e331.type && delete t164.text, "media-query" !== e331.type && "media-query-list" !== e331.type && "media-feature-expression" !== e331.type || delete t164.value, "css-rule" === e331.type && delete t164.params, "selector-combinator" === e331.type && (t164.value = t164.value.replace(/\s+/g, " ")), "media-feature" === e331.type && (t164.value = t164.value.replace(/ /g, "")), ("value-word" === e331.type && (e331.isColor && e331.isHex || [
            "initial",
            "inherit",
            "unset",
            "revert"
        ].includes(t164.value.replace().toLowerCase())) || "media-feature" === e331.type || "selector-root-invalid" === e331.type || "selector-pseudo" === e331.type) && (t164.value = t164.value.toLowerCase()), "css-decl" === e331.type && (t164.prop = t164.prop.toLowerCase()), "css-atrule" !== e331.type && "css-import" !== e331.type || (t164.name = t164.name.toLowerCase()), "value-number" === e331.type && (t164.unit = t164.unit.toLowerCase()), "media-feature" !== e331.type && "media-keyword" !== e331.type && "media-type" !== e331.type && "media-unknown" !== e331.type && "media-url" !== e331.type && "media-value" !== e331.type && "selector-attribute" !== e331.type && "selector-string" !== e331.type && "selector-class" !== e331.type && "selector-combinator" !== e331.type && "value-string" !== e331.type || !t164.value || (t164.value = t164.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), "selector-attribute" === e331.type && (t164.attribute = t164.attribute.trim(), t164.namespace && "string" == typeof t164.namespace && (t164.namespace = t164.namespace.trim(), 0 === t164.namespace.length && (t164.namespace = !0)), t164.value && (t164.value = t164.value.trim().replace(/^["']|["']$/g, ""), delete t164.quoted)), "media-value" !== e331.type && "media-type" !== e331.type && "value-number" !== e331.type && "selector-root-invalid" !== e331.type && "selector-class" !== e331.type && "selector-combinator" !== e331.type && "selector-tag" !== e331.type || !t164.value || (t164.value = t164.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e, t, n)=>{
            const r = Number(t);
            return Number.isNaN(r) ? e : r + n.toLowerCase();
        })), "selector-tag" === e331.type) {
            const n = e331.value.toLowerCase();
            [
                "from",
                "to"
            ].includes(n) && (t164.value = n);
        }
        "css-atrule" === e331.type && "supports" === e331.name.toLowerCase() && delete t164.value, "selector-unknown" === e331.type && delete t164.value;
    }
    Mj.ignoredProperties = _j;
    var Rj = Mj;
    const { builders: { hardline: Vj , markAsRoot: $j  }  } = Zc;
    var Wj = function(e, t) {
        if ("yaml" === e.lang) {
            const n = e.value.trim(), r = n ? t(n, {
                parser: "yaml"
            }, {
                stripTrailingHardline: !0
            }) : "";
            return $j([
                e.startDelimiter,
                Vj,
                r,
                r ? Vj : "",
                e.endDelimiter
            ]);
        }
    };
    const { builders: { hardline: qj  }  } = Zc, Uj = Wj;
    var zj = function(e, t, n) {
        const r = e.getValue();
        if ("front-matter" === r.type) {
            const e = Uj(r, n);
            return e ? [
                e,
                qj
            ] : "";
        }
    };
    const Gj = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
    var Hj = function(e) {
        const t = e.match(Gj);
        if (!t) return {
            content: e
        };
        const { startDelimiter: n , language: r , value: o = "" , endDelimiter: i  } = t.groups;
        let u = r.trim() || "yaml";
        if ("+++" === n && (u = "toml"), "yaml" !== u && n !== i) return {
            content: e
        };
        const [s] = t;
        return {
            frontMatter: {
                type: "front-matter",
                lang: u,
                value: o,
                startDelimiter: n,
                endDelimiter: i,
                raw: s.replace(/\n$/, "")
            },
            content: s.replace(/[^\n]/g, " ") + e.slice(s.length)
        };
    };
    const Jj = iv, Xj = Hj;
    var Yj = {
        hasPragma: function(e) {
            return Jj.hasPragma(Xj(e).content);
        },
        insertPragma: function(e) {
            const { frontMatter: t , content: n  } = Xj(e);
            return (t ? t.raw + "\n\n" : "") + Jj.insertPragma(n);
        }
    };
    const { isNonEmptyArray: Kj  } = dc, Qj = new Set([
        "red",
        "green",
        "blue",
        "alpha",
        "a",
        "rgb",
        "hue",
        "h",
        "saturation",
        "s",
        "lightness",
        "l",
        "whiteness",
        "w",
        "blackness",
        "b",
        "tint",
        "shade",
        "blend",
        "blenda",
        "contrast",
        "hsl",
        "hsla",
        "hwb",
        "hwba"
    ]), Zj = new Set([
        "import",
        "use",
        "forward"
    ]);
    function e_(e, t) {
        const n = Array.isArray(t) ? t : [
            t
        ];
        let r, o = -1;
        for(; r = e.getParentNode(++o);)if (n.includes(r.type)) return o;
        return -1;
    }
    function t_(e, t) {
        const n = e_(e, t);
        return -1 === n ? null : e.getParentNode(n);
    }
    function n_(e) {
        return "value-operator" === e.type && "*" === e.value;
    }
    function r_(e) {
        return "value-operator" === e.type && "/" === e.value;
    }
    function o_(e) {
        return "value-operator" === e.type && "+" === e.value;
    }
    function i_(e) {
        return "value-operator" === e.type && "-" === e.value;
    }
    function u_(e) {
        return "value-operator" === e.type && "%" === e.value;
    }
    function s_(e) {
        return "value-comma_group" === e.type && e.groups && e.groups[1] && "value-colon" === e.groups[1].type;
    }
    function a_(e) {
        return "value-paren_group" === e.type && e.groups && e.groups[0] && s_(e.groups[0]);
    }
    function c_(e) {
        return e && "value-colon" === e.type;
    }
    var l_ = {
        getAncestorCounter: e_,
        getAncestorNode: t_,
        getPropOfDeclNode: function(e) {
            const t = t_(e, "css-decl");
            return t && t.prop && t.prop.toLowerCase();
        },
        hasSCSSInterpolation: function(e) {
            if (Kj(e)) {
                for(let t = e.length - 1; t > 0; t--)if ("word" === e[t].type && "{" === e[t].value && "word" === e[t - 1].type && e[t - 1].value.endsWith("#")) return !0;
            }
            return !1;
        },
        hasStringOrFunction: function(e) {
            if (Kj(e)) {
                for(let t = 0; t < e.length; t++)if ("string" === e[t].type || "func" === e[t].type) return !0;
            }
            return !1;
        },
        maybeToLowerCase: function(e) {
            return e.includes("$") || e.includes("@") || e.includes("#") || e.startsWith("%") || e.startsWith("--") || e.startsWith(":--") || e.includes("(") && e.includes(")") ? e : e.toLowerCase();
        },
        insideValueFunctionNode: function(e, t) {
            const n = t_(e, "value-func");
            return n && n.value && n.value.toLowerCase() === t;
        },
        insideICSSRuleNode: function(e) {
            const t = t_(e, "css-rule");
            return t && t.raws && t.raws.selector && (t.raws.selector.startsWith(":import") || t.raws.selector.startsWith(":export"));
        },
        insideAtRuleNode: function(e, t) {
            const n = Array.isArray(t) ? t : [
                t
            ], r = t_(e, "css-atrule");
            return r && n.includes(r.name.toLowerCase());
        },
        insideURLFunctionInImportAtRuleNode: function(e) {
            const t = e.getValue(), n = t_(e, "css-atrule");
            return n && "import" === n.name && "url" === t.groups[0].value && 2 === t.groups.length;
        },
        isKeyframeAtRuleKeywords: function(e, t) {
            const n = t_(e, "css-atrule");
            return n && n.name && n.name.toLowerCase().endsWith("keyframes") && [
                "from",
                "to"
            ].includes(t.toLowerCase());
        },
        isWideKeywords: function(e) {
            return [
                "initial",
                "inherit",
                "unset",
                "revert"
            ].includes(e.toLowerCase());
        },
        isSCSS: function(e, t) {
            return "less" === e || "scss" === e ? "scss" === e : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t);
        },
        isSCSSVariable: function(e) {
            return Boolean(e && "word" === e.type && e.value.startsWith("$"));
        },
        isLastNode: function(e, t) {
            const n = e.getParentNode();
            if (!n) return !1;
            const { nodes: r  } = n;
            return r && r.indexOf(t) === r.length - 1;
        },
        isLessParser: function(e) {
            return "css" === e.parser || "less" === e.parser;
        },
        isSCSSControlDirectiveNode: function(e) {
            return "css-atrule" === e.type && [
                "if",
                "else",
                "for",
                "each",
                "while"
            ].includes(e.name);
        },
        isDetachedRulesetDeclarationNode: function(e) {
            return !!e.selector && ("string" == typeof e.selector && /^@.+:.*$/.test(e.selector) || e.selector.value && /^@.+:.*$/.test(e.selector.value));
        },
        isRelationalOperatorNode: function(e) {
            return "value-word" === e.type && [
                "<",
                ">",
                "<=",
                ">="
            ].includes(e.value);
        },
        isEqualityOperatorNode: function(e) {
            return "value-word" === e.type && [
                "==",
                "!="
            ].includes(e.value);
        },
        isMultiplicationNode: n_,
        isDivisionNode: r_,
        isAdditionNode: o_,
        isSubtractionNode: i_,
        isModuloNode: u_,
        isMathOperatorNode: function(e) {
            return n_(e) || r_(e) || o_(e) || i_(e) || u_(e);
        },
        isEachKeywordNode: function(e) {
            return "value-word" === e.type && "in" === e.value;
        },
        isForKeywordNode: function(e) {
            return "value-word" === e.type && [
                "from",
                "through",
                "end"
            ].includes(e.value);
        },
        isURLFunctionNode: function(e) {
            return "value-func" === e.type && "url" === e.value.toLowerCase();
        },
        isIfElseKeywordNode: function(e) {
            return "value-word" === e.type && [
                "and",
                "or",
                "not"
            ].includes(e.value);
        },
        hasComposesNode: function(e) {
            return e.value && "value-root" === e.value.type && e.value.group && "value-value" === e.value.group.type && "composes" === e.prop.toLowerCase();
        },
        hasParensAroundNode: function(e) {
            return e.value && e.value.group && e.value.group.group && "value-paren_group" === e.value.group.group.type && null !== e.value.group.group.open && null !== e.value.group.group.close;
        },
        hasEmptyRawBefore: function(e) {
            return e.raws && "" === e.raws.before;
        },
        isSCSSNestedPropertyNode: function(e) {
            return !!e.selector && e.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
        },
        isDetachedRulesetCallNode: function(e) {
            return e.raws && e.raws.params && /^\(\s*\)$/.test(e.raws.params);
        },
        isTemplatePlaceholderNode: function(e) {
            return e.name.startsWith("prettier-placeholder");
        },
        isTemplatePropNode: function(e) {
            return e.prop.startsWith("@prettier-placeholder");
        },
        isPostcssSimpleVarNode: function(e, t) {
            return "$$" === e.value && "value-func" === e.type && t && "value-word" === t.type && !t.raws.before;
        },
        isKeyValuePairNode: s_,
        isKeyValuePairInParenGroupNode: a_,
        isKeyInValuePairNode: function(e, t) {
            if (!s_(t)) return !1;
            const { groups: n  } = t, r = n.indexOf(e);
            return -1 !== r && c_(n[r + 1]);
        },
        isSCSSMapItemNode: function(e) {
            const t = e.getValue();
            if (0 === t.groups.length) return !1;
            const n = e.getParentNode(1);
            if (!(a_(t) || n && a_(n))) return !1;
            const r = t_(e, "css-decl");
            return !!(r && r.prop && r.prop.startsWith("$")) || !!a_(n) || "value-func" === n.type;
        },
        isInlineValueCommentNode: function(e) {
            return "value-comment" === e.type && e.inline;
        },
        isHashNode: function(e) {
            return "value-word" === e.type && "#" === e.value;
        },
        isLeftCurlyBraceNode: function(e) {
            return "value-word" === e.type && "{" === e.value;
        },
        isRightCurlyBraceNode: function(e) {
            return "value-word" === e.type && "}" === e.value;
        },
        isWordNode: function(e) {
            return [
                "value-word",
                "value-atword"
            ].includes(e.type);
        },
        isColonNode: c_,
        isMediaAndSupportsKeywords: function(e) {
            return e.value && [
                "not",
                "and",
                "or"
            ].includes(e.value.toLowerCase());
        },
        isColorAdjusterFuncNode: function(e) {
            return "value-func" === e.type && Qj.has(e.value.toLowerCase());
        },
        lastLineHasInlineComment: function(e) {
            return /\/\//.test(e.split(/[\n\r]/).pop());
        },
        stringifyNode: function e(t) {
            if (t.groups) return (t.open && t.open.value ? t.open.value : "") + t.groups.reduce((n, r, o)=>n + e(r) + ("comma_group" === t.groups[0].type && o !== t.groups.length - 1 ? "," : "")
            , "") + (t.close && t.close.value ? t.close.value : "");
            const n85 = t.raws && t.raws.before ? t.raws.before : "", r70 = t.raws && t.raws.quote ? t.raws.quote : "";
            return n85 + r70 + ("atword" === t.type ? "@" : "") + (t.value ? t.value : "") + r70 + (t.unit ? t.unit : "") + (t.group ? e(t.group) : "") + (t.raws && t.raws.after ? t.raws.after : "");
        },
        isAtWordPlaceholderNode: function(e) {
            return e && "value-atword" === e.type && e.value.startsWith("prettier-placeholder-");
        },
        isModuleRuleName: function(e) {
            return Zj.has(e);
        },
        isConfigurationNode: function(e332, t) {
            if (!e332.open || "(" !== e332.open.value || !e332.close || ")" !== e332.close.value || e332.groups.some((e)=>"value-comma_group" !== e.type
            )) return !1;
            if ("value-comma_group" === t.type) {
                const n = t.groups.indexOf(e332) - 1, r = t.groups[n];
                if (r && "value-word" === r.type && "with" === r.value) return !0;
            }
            return !1;
        },
        isParenGroupNode: function(e) {
            return "value-paren_group" === e.type && e.open && "(" === e.open.value && e.close && ")" === e.close.value;
        }
    };
    const p_ = function(e, t) {
        let n = 0;
        for(let r = 0; r < e.line - 1; ++r)n = t.indexOf("\n", n) + 1;
        return n + e.column;
    }, { getLast: f_ , skipEverythingButNewLine: d_  } = dc;
    function h_(e, t) {
        return "number" == typeof e.sourceIndex ? e.sourceIndex : e.source ? p_(e.source.start, t) - 1 : null;
    }
    function g_(e, t) {
        if ("css-comment" === e.type && e.inline) return d_(t, e.source.startOffset);
        const n = e.nodes && f_(e.nodes);
        return n && e.source && !e.source.end && (e = n), e.source && e.source.end ? p_(e.source.end, t) : null;
    }
    function m_(e, t, n) {
        e.source && (e.source.startOffset = h_(e, n) + t, e.source.endOffset = g_(e, n) + t);
        for(const r in e){
            const o = e[r];
            "source" !== r && o && "object" == typeof o && m_(o, t, n);
        }
    }
    function y_(e) {
        let t = e.source.startOffset;
        return "string" == typeof e.prop && (t += e.prop.length), "css-atrule" === e.type && "string" == typeof e.name && (t += 1 + e.name.length + e.raws.afterName.match(/^\s*:?\s*/)[0].length), "css-atrule" !== e.type && e.raws && "string" == typeof e.raws.between && (t += e.raws.between.length), t;
    }
    var D_ = {
        locStart: function(e) {
            return e.source.startOffset;
        },
        locEnd: function(e) {
            return e.source.endOffset;
        },
        calculateLoc: function e(t, n) {
            t.source && (t.source.startOffset = h_(t, n), t.source.endOffset = g_(t, n));
            for(const r in t){
                const o = t[r];
                "source" !== r && o && "object" == typeof o && ("value-root" === o.type || "value-unknown" === o.type ? m_(o, y_(t), o.text || o.value) : e(o, n));
            }
        },
        replaceQuotesInInlineComments: function(e) {
            let t, n = "initial", r = "initial", o = !1;
            const i = [];
            for(let u = 0; u < e.length; u++){
                const s = e[u];
                switch(n){
                    case "initial":
                        if ("'" === s) {
                            n = "single-quotes";
                            continue;
                        }
                        if ('"' === s) {
                            n = "double-quotes";
                            continue;
                        }
                        if (("u" === s || "U" === s) && "url(" === e.slice(u, u + 4).toLowerCase()) {
                            n = "url", u += 3;
                            continue;
                        }
                        if ("*" === s && "/" === e[u - 1]) {
                            n = "comment-block";
                            continue;
                        }
                        if ("/" === s && "/" === e[u - 1]) {
                            n = "comment-inline", t = u - 1;
                            continue;
                        }
                        continue;
                    case "single-quotes":
                        if ("'" === s && "\\" !== e[u - 1] && (n = r, r = "initial"), "\n" === s || "\r" === s) return e;
                        continue;
                    case "double-quotes":
                        if ('"' === s && "\\" !== e[u - 1] && (n = r, r = "initial"), "\n" === s || "\r" === s) return e;
                        continue;
                    case "url":
                        if (")" === s && (n = "initial"), "\n" === s || "\r" === s) return e;
                        if ("'" === s) {
                            n = "single-quotes", r = "url";
                            continue;
                        }
                        if ('"' === s) {
                            n = "double-quotes", r = "url";
                            continue;
                        }
                        continue;
                    case "comment-block":
                        "/" === s && "*" === e[u - 1] && (n = "initial");
                        continue;
                    case "comment-inline":
                        '"' !== s && "'" !== s && "*" !== s || (o = !0), "\n" !== s && "\r" !== s || (o && i.push([
                            t,
                            u
                        ]), n = "initial", o = !1);
                        continue;
                }
            }
            for (const [t165, n86] of i)e = e.slice(0, t165) + e.slice(t165, n86).replace(/["'*]/g, " ") + e.slice(n86);
            return e;
        }
    };
    const E_ = au, { printNumber: C_ , printString: b_ , hasNewline: v_ , isFrontMatterNode: A_ , isNextLineEmpty: F_ , isNonEmptyArray: x_  } = dc, { builders: { join: S_ , line: w_ , hardline: T_ , softline: B_ , group: N_ , fill: k_ , indent: P_ , dedent: O_ , ifBreak: I_ , breakParent: L_  } , utils: { removeLines: j_ , getDocParts: __  }  } = Zc, M_ = Rj, R_ = zj, { insertPragma: V_  } = Yj, { getAncestorNode: $_ , getPropOfDeclNode: W_ , maybeToLowerCase: q_ , insideValueFunctionNode: U_ , insideICSSRuleNode: z_ , insideAtRuleNode: G_ , insideURLFunctionInImportAtRuleNode: H_ , isKeyframeAtRuleKeywords: J_ , isWideKeywords: X_ , isSCSS: Y_ , isLastNode: K_ , isLessParser: Q_ , isSCSSControlDirectiveNode: Z_ , isDetachedRulesetDeclarationNode: eM , isRelationalOperatorNode: tM , isEqualityOperatorNode: nM , isMultiplicationNode: rM , isDivisionNode: oM , isAdditionNode: iM , isSubtractionNode: uM , isMathOperatorNode: sM , isEachKeywordNode: aM , isForKeywordNode: cM , isURLFunctionNode: lM , isIfElseKeywordNode: pM , hasComposesNode: fM , hasParensAroundNode: dM , hasEmptyRawBefore: hM , isKeyValuePairNode: gM , isKeyInValuePairNode: mM , isDetachedRulesetCallNode: yM , isTemplatePlaceholderNode: DM , isTemplatePropNode: EM , isPostcssSimpleVarNode: CM , isSCSSMapItemNode: bM , isInlineValueCommentNode: vM , isHashNode: AM , isLeftCurlyBraceNode: FM , isRightCurlyBraceNode: xM , isWordNode: SM , isColonNode: wM , isMediaAndSupportsKeywords: TM , isColorAdjusterFuncNode: BM , lastLineHasInlineComment: NM , isAtWordPlaceholderNode: kM , isConfigurationNode: PM , isParenGroupNode: OM  } = l_, { locStart: IM , locEnd: LM  } = D_;
    function jM(e) {
        return "es5" === e.trailingComma || "all" === e.trailingComma;
    }
    function _M(e333, t, n87) {
        const r = [];
        return e333.each((e, o, i)=>{
            const u = i[o - 1];
            if (u && "css-comment" === u.type && "prettier-ignore" === u.text.trim()) {
                const n = e.getValue();
                r.push(t.originalText.slice(IM(n), LM(n)));
            } else r.push(n87());
            o !== i.length - 1 && ("css-comment" === i[o + 1].type && !v_(t.originalText, IM(i[o + 1]), {
                backwards: !0
            }) && !A_(i[o]) || "css-atrule" === i[o + 1].type && "else" === i[o + 1].name && "css-comment" !== i[o].type ? r.push(" ") : (r.push(t.__isHTMLStyleAttribute ? w_ : T_), F_(t.originalText, e.getValue(), LM) && !A_(i[o]) && r.push(T_)));
        }, "nodes"), r;
    }
    const MM = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, RM = new RegExp(MM.source + "|" + "(".concat(/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source, ")?") + "(".concat(/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source, ")") + "(".concat(/[A-Za-z]+/g.source, ")?"), "g");
    function VM(e334, t) {
        return e334.replace(MM, (e)=>b_(e, t)
        );
    }
    function $M(e, t) {
        const n = t.singleQuote ? "'" : '"';
        return e.includes('"') || e.includes("'") ? e : n + e + n;
    }
    function WM(e335) {
        return e335.replace(RM, (e, t, n, r, o)=>!n && r ? qM(r) + q_(o || "") : e
        );
    }
    function qM(e) {
        return C_(e).replace(/\.0(?=$|e)/, "");
    }
    var UM = {
        print: function(e336, t166, n) {
            const r71 = e336.getValue();
            if (!r71) return "";
            if ("string" == typeof r71) return r71;
            switch(r71.type){
                case "front-matter":
                    return [
                        r71.raw,
                        T_
                    ];
                case "css-root":
                    {
                        const o = _M(e336, t166, n), i = r71.raws.after.trim();
                        return [
                            o,
                            i ? " ".concat(i) : "",
                            __(o).length > 0 ? T_ : ""
                        ];
                    }
                case "css-comment":
                    {
                        const e = r71.inline || r71.raws.inline, n = t166.originalText.slice(IM(r71), LM(r71));
                        return e ? n.trimEnd() : n;
                    }
                case "css-rule":
                    return [
                        n("selector"),
                        r71.important ? " !important" : "",
                        r71.nodes ? [
                            r71.selector && "selector-unknown" === r71.selector.type && NM(r71.selector.value) ? w_ : " ",
                            "{",
                            r71.nodes.length > 0 ? P_([
                                T_,
                                _M(e336, t166, n)
                            ]) : "",
                            T_,
                            "}",
                            eM(r71) ? ";" : ""
                        ] : ";"
                    ];
                case "css-decl":
                    {
                        const o = e336.getParentNode(), { between: i  } = r71.raws, u = i.trim(), s = ":" === u;
                        let a = fM(r71) ? j_(n("value")) : n("value");
                        return !s && NM(u) && (a = P_([
                            T_,
                            O_(a)
                        ])), [
                            r71.raws.before.replace(/[\s;]/g, ""),
                            z_(e336) ? r71.prop : q_(r71.prop),
                            u.startsWith("//") ? " " : "",
                            u,
                            r71.extend ? "" : " ",
                            Q_(t166) && r71.extend && r71.selector ? [
                                "extend(",
                                n("selector"),
                                ")"
                            ] : "",
                            a,
                            r71.raws.important ? r71.raws.important.replace(/\s*!\s*important/i, " !important") : r71.important ? " !important" : "",
                            r71.raws.scssDefault ? r71.raws.scssDefault.replace(/\s*!default/i, " !default") : r71.scssDefault ? " !default" : "",
                            r71.raws.scssGlobal ? r71.raws.scssGlobal.replace(/\s*!global/i, " !global") : r71.scssGlobal ? " !global" : "",
                            r71.nodes ? [
                                " {",
                                P_([
                                    B_,
                                    _M(e336, t166, n)
                                ]),
                                B_,
                                "}"
                            ] : EM(r71) && !o.raws.semicolon && ";" !== t166.originalText[LM(r71) - 1] ? "" : t166.__isHTMLStyleAttribute && K_(e336, r71) ? I_(";") : ";"
                        ];
                    }
                case "css-atrule":
                    {
                        const o = e336.getParentNode(), i = DM(r71) && !o.raws.semicolon && ";" !== t166.originalText[LM(r71) - 1];
                        if (Q_(t166)) {
                            if (r71.mixin) return [
                                n("selector"),
                                r71.important ? " !important" : "",
                                i ? "" : ";"
                            ];
                            if (r71.function) return [
                                r71.name,
                                n("params"),
                                i ? "" : ";"
                            ];
                            if (r71.variable) return [
                                "@",
                                r71.name,
                                ": ",
                                r71.value ? n("value") : "",
                                r71.raws.between.trim() ? r71.raws.between.trim() + " " : "",
                                r71.nodes ? [
                                    "{",
                                    P_([
                                        r71.nodes.length > 0 ? B_ : "",
                                        _M(e336, t166, n)
                                    ]),
                                    B_,
                                    "}"
                                ] : "",
                                i ? "" : ";"
                            ];
                        }
                        return [
                            "@",
                            yM(r71) || r71.name.endsWith(":") ? r71.name : q_(r71.name),
                            r71.params ? [
                                yM(r71) ? "" : DM(r71) ? "" === r71.raws.afterName ? "" : r71.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r71.raws.afterName) ? [
                                    T_,
                                    T_
                                ] : /^\s*\n/.test(r71.raws.afterName) ? T_ : " " : " ",
                                n("params")
                            ] : "",
                            r71.selector ? P_([
                                " ",
                                n("selector")
                            ]) : "",
                            r71.value ? N_([
                                " ",
                                n("value"),
                                Z_(r71) ? dM(r71) ? " " : w_ : ""
                            ]) : "else" === r71.name ? " " : "",
                            r71.nodes ? [
                                Z_(r71) ? "" : r71.selector && !r71.selector.nodes && "string" == typeof r71.selector.value && NM(r71.selector.value) || !r71.selector && "string" == typeof r71.params && NM(r71.params) ? w_ : " ",
                                "{",
                                P_([
                                    r71.nodes.length > 0 ? B_ : "",
                                    _M(e336, t166, n)
                                ]),
                                B_,
                                "}"
                            ] : i ? "" : ";"
                        ];
                    }
                case "media-query-list":
                    {
                        const t = [];
                        return e336.each((e)=>{
                            const r = e.getValue();
                            "media-query" === r.type && "" === r.value || t.push(n());
                        }, "nodes"), N_(P_(S_(w_, t)));
                    }
                case "media-query":
                    return [
                        S_(" ", e336.map(n, "nodes")),
                        K_(e336, r71) ? "" : ","
                    ];
                case "media-type":
                case "media-value":
                    return WM(VM(r71.value, t166));
                case "media-feature-expression":
                    return r71.nodes ? [
                        "(",
                        ...e336.map(n, "nodes"),
                        ")"
                    ] : r71.value;
                case "media-feature":
                    return q_(VM(r71.value.replace(/ +/g, " "), t166));
                case "media-colon":
                case "value-comma":
                    return [
                        r71.value,
                        " "
                    ];
                case "media-keyword":
                case "selector-string":
                    return VM(r71.value, t166);
                case "media-url":
                    return VM(r71.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t166);
                case "media-unknown":
                case "selector-comment":
                case "selector-nesting":
                case "value-paren":
                case "value-operator":
                case "value-unicode-range":
                case "value-unknown":
                    return r71.value;
                case "selector-root":
                    return N_([
                        G_(e336, "custom-selector") ? [
                            $_(e336, "css-atrule").customSelector,
                            w_
                        ] : "",
                        S_([
                            ",",
                            G_(e336, [
                                "extend",
                                "custom-selector",
                                "nest"
                            ]) ? w_ : T_
                        ], e336.map(n, "nodes"))
                    ]);
                case "selector-selector":
                    return N_(P_(e336.map(n, "nodes")));
                case "selector-tag":
                    {
                        const t = e336.getParentNode(), n = t && t.nodes.indexOf(r71), o = n && t.nodes[n - 1];
                        return [
                            r71.namespace ? [
                                !0 === r71.namespace ? "" : r71.namespace.trim(),
                                "|"
                            ] : "",
                            "selector-nesting" === o.type ? r71.value : WM(J_(e336, r71.value) ? r71.value.toLowerCase() : r71.value)
                        ];
                    }
                case "selector-id":
                    return [
                        "#",
                        r71.value
                    ];
                case "selector-class":
                    return [
                        ".",
                        WM(VM(r71.value, t166))
                    ];
                case "selector-attribute":
                    return [
                        "[",
                        r71.namespace ? [
                            !0 === r71.namespace ? "" : r71.namespace.trim(),
                            "|"
                        ] : "",
                        r71.attribute.trim(),
                        r71.operator ? r71.operator : "",
                        r71.value ? $M(VM(r71.value.trim(), t166), t166) : "",
                        r71.insensitive ? " i" : "",
                        "]"
                    ];
                case "selector-combinator":
                    if ("+" === r71.value || ">" === r71.value || "~" === r71.value || ">>>" === r71.value) {
                        const t = e336.getParentNode();
                        return [
                            "selector-selector" === t.type && t.nodes[0] === r71 ? "" : w_,
                            r71.value,
                            K_(e336, r71) ? "" : " "
                        ];
                    }
                    return [
                        r71.value.trim().startsWith("(") ? w_ : "",
                        WM(VM(r71.value.trim(), t166)) || w_
                    ];
                case "selector-universal":
                    return [
                        r71.namespace ? [
                            !0 === r71.namespace ? "" : r71.namespace.trim(),
                            "|"
                        ] : "",
                        r71.value
                    ];
                case "selector-pseudo":
                    return [
                        q_(r71.value),
                        x_(r71.nodes) ? [
                            "(",
                            S_(", ", e336.map(n, "nodes")),
                            ")"
                        ] : ""
                    ];
                case "selector-unknown":
                    {
                        const n = $_(e336, "css-rule");
                        if (n && n.isSCSSNesterProperty) return WM(VM(q_(r71.value), t166));
                        const o = e336.getParentNode();
                        if (o.raws && o.raws.selector) {
                            const e = IM(o), n = e + o.raws.selector.length;
                            return t166.originalText.slice(e, n).trim();
                        }
                        const i = e336.getParentNode(1);
                        if ("value-paren_group" === o.type && i && "value-func" === i.type && "selector" === i.value) {
                            const e = IM(o.open) + 1, n = LM(o.close) - 1, r = t166.originalText.slice(e, n).trim();
                            return NM(r) ? [
                                L_,
                                r
                            ] : r;
                        }
                        return r71.value;
                    }
                case "value-value":
                case "value-root":
                    return n("group");
                case "value-comment":
                    return t166.originalText.slice(IM(r71), LM(r71));
                case "value-comma_group":
                    {
                        const t = e336.getParentNode(), o = e336.getParentNode(1), i = W_(e336), u = i && "value-value" === t.type && ("grid" === i || i.startsWith("grid-template")), s = $_(e336, "css-atrule"), a = s && Z_(s), c = r71.groups.some((e)=>vM(e)
                        ), l = e336.map(n, "groups"), p = [], f = U_(e336, "url");
                        let d = !1, h = !1;
                        for(let n88 = 0; n88 < r71.groups.length; ++n88){
                            p.push(l[n88]);
                            const i = r71.groups[n88 - 1], c = r71.groups[n88], g = r71.groups[n88 + 1], m = r71.groups[n88 + 2];
                            if (f) {
                                (g && iM(g) || iM(c)) && p.push(" ");
                                continue;
                            }
                            if (G_(e336, "forward") && "value-word" === c.type && c.value && void 0 !== i && "value-word" === i.type && "as" === i.value && "value-operator" === g.type && "*" === g.value) continue;
                            if (!g) continue;
                            if ("value-word" === c.type && c.value.endsWith("-") && kM(g)) continue;
                            const y = "value-string" === c.type && c.value.startsWith("#{"), D = d && "value-string" === g.type && g.value.endsWith("}");
                            if (y || D) {
                                d = !d;
                                continue;
                            }
                            if (d) continue;
                            if (wM(c) || wM(g)) continue;
                            if ("value-atword" === c.type && "" === c.value) continue;
                            if ("~" === c.value) continue;
                            if (c.value && c.value.includes("\\") && g && "value-comment" !== g.type) continue;
                            if (i && i.value && i.value.indexOf("\\") === i.value.length - 1 && "value-operator" === c.type && "/" === c.value) continue;
                            if ("\\" === c.value) continue;
                            if (CM(c, g)) continue;
                            if (AM(c) || FM(c) || xM(g) || FM(g) && hM(g) || xM(c) && hM(g)) continue;
                            if ("--" === c.value && AM(g)) continue;
                            const E = sM(c), C = sM(g);
                            if ((E && AM(g) || C && xM(c)) && hM(g)) continue;
                            if (!i && oM(c)) continue;
                            if (U_(e336, "calc") && (iM(c) || iM(g) || uM(c) || uM(g)) && hM(g)) continue;
                            const b = (iM(c) || uM(c)) && 0 === n88 && ("value-number" === g.type || g.isHex) && o && BM(o) && !hM(g), v = m && "value-func" === m.type || m && SM(m) || "value-func" === c.type || SM(c), A = "value-func" === g.type || SM(g) || i && "value-func" === i.type || i && SM(i);
                            if (rM(g) || rM(c) || U_(e336, "calc") || b || !(oM(g) && !v || oM(c) && !A || iM(g) && !v || iM(c) && !A || uM(g) || uM(c)) || !(hM(g) || E && (!i || i && sM(i)))) {
                                if (vM(c)) {
                                    if ("value-paren_group" === t.type) {
                                        p.push(O_(T_));
                                        continue;
                                    }
                                    p.push(T_);
                                } else a && (nM(g) || tM(g) || pM(g) || aM(c) || cM(c)) || s && "namespace" === s.name.toLowerCase() ? p.push(" ") : u ? c.source && g.source && c.source.start.line !== g.source.start.line ? (p.push(T_), h = !0) : p.push(" ") : C ? p.push(" ") : g && "..." === g.value || kM(c) && kM(g) && LM(c) === IM(g) || (kM(c) && OM(g) && LM(c) === IM(g.open) ? p.push(B_) : "with" === c.value && OM(g) ? p.push(" ") : p.push(w_));
                            }
                        }
                        return c && p.push(L_), h && p.unshift(T_), a ? N_(P_(p)) : H_(e336) ? N_(k_(p)) : N_(P_(k_(p)));
                    }
                case "value-paren_group":
                    {
                        const o = e336.getParentNode();
                        if (o && lM(o) && (1 === r71.groups.length || r71.groups.length > 0 && "value-comma_group" === r71.groups[0].type && r71.groups[0].groups.length > 0 && "value-word" === r71.groups[0].groups[0].type && r71.groups[0].groups[0].value.startsWith("data:"))) return [
                            r71.open ? n("open") : "",
                            S_(",", e336.map(n, "groups")),
                            r71.close ? n("close") : ""
                        ];
                        if (!r71.open) {
                            const t = e336.map(n, "groups"), r = [];
                            for(let e = 0; e < t.length; e++)0 !== e && r.push([
                                ",",
                                w_
                            ]), r.push(t[e]);
                            return N_(P_(k_(r)));
                        }
                        const i = bM(e336), u = E_(r71.groups), s = u && "value-comment" === u.type, a = mM(r71, o), c = PM(r71, o), l = c || i && !a, p = c || a, f = N_([
                            r71.open ? n("open") : "",
                            P_([
                                B_,
                                S_([
                                    ",",
                                    w_
                                ], e336.map((e)=>{
                                    const t = e.getValue(), r = n();
                                    if (gM(t) && "value-comma_group" === t.type && t.groups && "value-paren_group" !== t.groups[0].type && t.groups[2] && "value-paren_group" === t.groups[2].type) {
                                        const e = __(r.contents.contents);
                                        return e[1] = N_(e[1]), N_(O_(r));
                                    }
                                    return r;
                                }, "groups"))
                            ]),
                            I_(!s && Y_(t166.parser, t166.originalText) && i && jM(t166) ? "," : ""),
                            B_,
                            r71.close ? n("close") : ""
                        ], {
                            shouldBreak: l
                        });
                        return p ? O_(f) : f;
                    }
                case "value-func":
                    return [
                        r71.value,
                        G_(e336, "supports") && TM(r71) ? " " : "",
                        n("group")
                    ];
                case "value-number":
                    return [
                        qM(r71.value),
                        q_(r71.unit)
                    ];
                case "value-word":
                    return r71.isColor && r71.isHex || X_(r71.value) ? r71.value.toLowerCase() : r71.value;
                case "value-colon":
                    {
                        const t = e336.getParentNode(), n = t && t.groups.indexOf(r71), o = n && t.groups[n - 1];
                        return [
                            r71.value,
                            o && "string" == typeof o.value && "\\" === E_(o.value) || U_(e336, "url") ? "" : w_
                        ];
                    }
                case "value-string":
                    return b_(r71.raws.quote + r71.value + r71.raws.quote, t166);
                case "value-atword":
                    return [
                        "@",
                        r71.value
                    ];
                default:
                    throw new Error("Unknown postcss type ".concat(JSON.stringify(r71.type)));
            }
        },
        embed: R_,
        insertPragma: V_,
        massageAstNode: M_
    };
    var zM = {
        name: "PostCSS",
        type: "markup",
        tmScope: "source.postcss",
        group: "CSS",
        extensions: [
            ".pcss",
            ".postcss"
        ],
        aceMode: "text",
        languageId: 262764437
    }, GM = {
        name: "Less",
        type: "markup",
        color: "#1d365d",
        extensions: [
            ".less"
        ],
        tmScope: "source.css.less",
        aceMode: "less",
        codemirrorMode: "css",
        codemirrorMimeType: "text/css",
        languageId: 198
    }, HM = {
        name: "SCSS",
        type: "markup",
        color: "#c6538c",
        tmScope: "source.css.scss",
        aceMode: "scss",
        codemirrorMode: "css",
        codemirrorMimeType: "text/x-scss",
        extensions: [
            ".scss"
        ],
        languageId: 329
    };
    const JM = bE, XM = UM, YM = {
        singleQuote: bj.singleQuote
    }, KM = [
        JM({
            name: "CSS",
            type: "markup",
            tmScope: "source.css",
            aceMode: "css",
            codemirrorMode: "css",
            codemirrorMimeType: "text/css",
            color: "#563d7c",
            extensions: [
                ".css"
            ],
            languageId: 50
        }, (e)=>({
                since: "1.4.0",
                parsers: [
                    "css"
                ],
                vscodeLanguageIds: [
                    "css"
                ],
                extensions: [
                    ...e.extensions,
                    ".wxss"
                ]
            })
        ),
        JM(zM, ()=>({
                since: "1.4.0",
                parsers: [
                    "css"
                ],
                vscodeLanguageIds: [
                    "postcss"
                ]
            })
        ),
        JM(GM, ()=>({
                since: "1.4.0",
                parsers: [
                    "less"
                ],
                vscodeLanguageIds: [
                    "less"
                ]
            })
        ),
        JM(HM, ()=>({
                since: "1.4.0",
                parsers: [
                    "scss"
                ],
                vscodeLanguageIds: [
                    "scss"
                ]
            })
        )
    ];
    var QM = {
        languages: KM,
        options: YM,
        printers: {
            postcss: XM
        },
        parsers: undefined
    };
    var ZM = {
        locStart: function(e) {
            return e.loc.start.offset;
        },
        locEnd: function(e) {
            return e.loc.end.offset;
        }
    };
    function eR(e, t) {
        if ("TextNode" === e.type) {
            const n = e.chars.trim();
            if (!n) return null;
            t.chars = n.replace(/[\t\n\f\r ]+/g, " ");
        }
        "AttrNode" === e.type && "class" === e.name.toLowerCase() && delete t.value;
    }
    eR.ignoredProperties = new Set([
        "loc",
        "selfClosing"
    ]);
    var tR = eR;
    const nR = au;
    const rR = new Set([
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "image",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "nextid",
        "param",
        "source",
        "track",
        "wbr"
    ]);
    function oR(e) {
        return iR(e, [
            "TextNode"
        ]) && !/\S/.test(e.chars);
    }
    function iR(e, t) {
        return e && t.includes(e.type);
    }
    function uR(e, t) {
        return iR(e.getParentNode(0), t);
    }
    function sR(e, t) {
        const n = e.getValue(), r = e.getParentNode(0) || {
        }, o = r.children || r.body || r.parts || [], i = o.indexOf(n);
        return -1 !== i && o[i + t];
    }
    function aR(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        return sR(e, -t);
    }
    function cR(e) {
        return sR(e, 1);
    }
    function lR(e) {
        return iR(e, [
            "MustacheCommentStatement"
        ]) && "string" == typeof e.value && "prettier-ignore" === e.value.trim();
    }
    var pR = {
        getNextNode: cR,
        getPreviousNode: aR,
        hasPrettierIgnore: function(e) {
            const t = e.getValue(), n = aR(e, 2);
            return lR(t) || lR(n);
        },
        isLastNodeOfSiblings: function(e) {
            const t = e.getValue(), n = e.getParentNode(0);
            return !(!uR(e, [
                "ElementNode"
            ]) || nR(n.children) !== t) || !(!uR(e, [
                "Block"
            ]) || nR(n.body) !== t);
        },
        isNextNodeOfSomeType: function(e, t) {
            return iR(cR(e), t);
        },
        isNodeOfSomeType: iR,
        isParentOfSomeType: uR,
        isPreviousNodeOfSomeType: function(e, t) {
            return iR(aR(e), t);
        },
        isVoid: function(e337) {
            return (function(e338) {
                return iR(e338, [
                    "ElementNode"
                ]) && "string" == typeof e338.tag && ":" !== e338.tag[0] && ((function(e) {
                    return e.toUpperCase() === e;
                })(e338.tag[0]) || e338.tag.includes("."));
            })(e337) && e337.children.every((e)=>oR(e)
            ) || rR.has(e337.tag);
        },
        isWhitespaceNode: oR
    };
    const { builders: { dedent: fR , fill: dR , group: hR , hardline: gR , ifBreak: mR , indent: yR , join: DR , line: ER , softline: CR  } , utils: { getDocParts: bR , replaceTextEndOfLine: vR  }  } = Zc, { getPreferredQuote: AR , isNonEmptyArray: FR  } = dc, { locStart: xR , locEnd: SR  } = ZM, wR = tR, { getNextNode: TR , getPreviousNode: BR , hasPrettierIgnore: NR , isLastNodeOfSiblings: kR , isNextNodeOfSomeType: PR , isNodeOfSomeType: OR , isParentOfSomeType: IR , isPreviousNodeOfSomeType: LR , isVoid: jR , isWhitespaceNode: _R  } = pR;
    function MR(e, t) {
        return xR(e) - xR(t);
    }
    function RR(e339, t, n) {
        const r72 = e339.getValue().children.every((e)=>_R(e)
        );
        return "ignore" === t.htmlWhitespaceSensitivity && r72 ? "" : e339.map((e, r)=>{
            const o = n();
            return 0 === r && "ignore" === t.htmlWhitespaceSensitivity ? [
                CR,
                o
            ] : o;
        }, "children");
    }
    function VR(e) {
        return jR(e) ? mR([
            CR,
            "/>"
        ], [
            " />",
            CR
        ]) : mR([
            CR,
            ">"
        ], ">");
    }
    function $R(e) {
        return [
            !1 === e.escaped ? "{{{" : "{{",
            e.strip && e.strip.open ? "~" : ""
        ];
    }
    function WR(e) {
        const t = !1 === e.escaped ? "}}}" : "}}";
        return [
            e.strip && e.strip.close ? "~" : "",
            t
        ];
    }
    function qR(e) {
        return [
            $R(e),
            e.closeStrip.open ? "~" : "",
            "/"
        ];
    }
    function UR(e) {
        const t = WR(e);
        return [
            e.closeStrip.close ? "~" : "",
            t
        ];
    }
    function zR(e) {
        return [
            $R(e),
            e.inverseStrip.open ? "~" : ""
        ];
    }
    function GR(e) {
        const t = WR(e);
        return [
            e.inverseStrip.close ? "~" : "",
            t
        ];
    }
    function HR(e340, t167) {
        const n = e340.getValue(), r = function(e) {
            return [
                $R(e),
                e.openStrip.open ? "~" : "",
                "#"
            ];
        }(n), o = function(e) {
            const t = WR(e);
            return [
                e.openStrip.close ? "~" : "",
                t
            ];
        }(n), i = [
            sV(e340, t167)
        ], u = aV(e340, t167);
        if (u && i.push(ER, u), FR(n.program.blockParams)) {
            const e = cV(n.program);
            i.push(ER, e);
        }
        return hR([
            r,
            yR(i),
            CR,
            o
        ]);
    }
    function JR(e, t) {
        return [
            "ignore" === t.htmlWhitespaceSensitivity ? gR : "",
            zR(e),
            "else",
            GR(e)
        ];
    }
    function XR(e, t) {
        const n = e.getParentNode(1);
        return [
            zR(n),
            "else if ",
            aV(e, t),
            GR(n)
        ];
    }
    function YR(e, t, n) {
        const r = e.getValue();
        if ("ignore" === n.htmlWhitespaceSensitivity) return [
            KR(r) ? CR : gR,
            qR(r),
            t("path"),
            UR(r)
        ];
        return [
            qR(r),
            t("path"),
            UR(r)
        ];
    }
    function KR(e341) {
        return OR(e341, [
            "BlockStatement"
        ]) && e341.program.body.every((e)=>_R(e)
        );
    }
    function QR(e) {
        return OR(e, [
            "BlockStatement"
        ]) && e.inverse;
    }
    function ZR(e, t, n) {
        if (KR(e.getValue())) return "";
        const r = t("program");
        return "ignore" === n.htmlWhitespaceSensitivity ? yR([
            gR,
            r
        ]) : yR(r);
    }
    function eV(e342, t, n) {
        const r = e342.getValue(), o = t("inverse"), i = "ignore" === n.htmlWhitespaceSensitivity ? [
            gR,
            o
        ] : o;
        return (function(e) {
            return QR(e) && 1 === e.inverse.body.length && OR(e.inverse.body[0], [
                "BlockStatement"
            ]) && "if" === e.inverse.body[0].path.parts[0];
        })(r) ? i : QR(r) ? [
            JR(r, n),
            yR(i)
        ] : "";
    }
    function tV(e343) {
        return bR(DR(ER, function(e) {
            return e.split(/[\t\n\f\r ]+/);
        }(e343)));
    }
    function nV(e) {
        return (e = "string" == typeof e ? e : "").split("\n").length - 1;
    }
    function rV() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        return Array.from({
            length: Math.min(e, 2)
        }).fill(gR);
    }
    function oV(e, t) {
        const { quote: n , regex: r  } = AR(e, t);
        return [
            n,
            e.replace(r, "\\".concat(n)),
            n
        ];
    }
    function iV(e, t) {
        const n = sV(e, t), r = aV(e, t);
        return r ? yR([
            n,
            ER,
            hR(r)
        ]) : n;
    }
    function uV(e, t) {
        const n = sV(e, t), r = aV(e, t);
        return r ? [
            yR([
                n,
                ER,
                r
            ]),
            CR
        ] : n;
    }
    function sV(e, t) {
        return t("path");
    }
    function aV(e, t) {
        const n = e.getValue(), r = [];
        if (n.params.length > 0) {
            const n = e.map(t, "params");
            r.push(...n);
        }
        if (n.hash && n.hash.pairs.length > 0) {
            const e = t("hash");
            r.push(e);
        }
        return 0 === r.length ? "" : DR(ER, r);
    }
    function cV(e) {
        return [
            "as |",
            e.blockParams.join(" "),
            "|"
        ];
    }
    var lV = {
        print: function(e344, t168, n90) {
            const r73 = e344.getValue();
            if (!r73) return "";
            if (NR(e344)) return t168.originalText.slice(xR(r73), SR(r73));
            const o46 = t168.singleQuote ? "'" : '"';
            switch(r73.type){
                case "Block":
                case "Program":
                case "Template":
                    return hR(e344.map(n90, "body"));
                case "ElementNode":
                    {
                        const o45 = hR(function(e345, t) {
                            const n91 = e345.getValue(), r = [
                                "attributes",
                                "modifiers",
                                "comments"
                            ].filter((e)=>FR(n91[e])
                            ), o = r.flatMap((e)=>n91[e]
                            ).sort(MR);
                            for (const n89 of r)e345.each((e)=>{
                                const n = o.indexOf(e.getValue());
                                o.splice(n, 1, [
                                    ER,
                                    t()
                                ]);
                            }, n89);
                            FR(n91.blockParams) && o.push(ER, cV(n91));
                            return [
                                "<",
                                n91.tag,
                                yR(o),
                                VR(n91)
                            ];
                        }(e344, n90)), i = "ignore" === t168.htmlWhitespaceSensitivity && PR(e344, [
                            "ElementNode"
                        ]) ? CR : "";
                        if (jR(r73)) return [
                            o45,
                            i
                        ];
                        const u = [
                            "</",
                            r73.tag,
                            ">"
                        ];
                        return 0 === r73.children.length ? [
                            o45,
                            yR(u),
                            i
                        ] : "ignore" === t168.htmlWhitespaceSensitivity ? [
                            o45,
                            yR(RR(e344, t168, n90)),
                            gR,
                            yR(u),
                            i
                        ] : [
                            o45,
                            yR(hR(RR(e344, t168, n90))),
                            yR(u),
                            i
                        ];
                    }
                case "BlockStatement":
                    {
                        const o = e344.getParentNode(1);
                        return o && o.inverse && 1 === o.inverse.body.length && o.inverse.body[0] === r73 && "if" === o.inverse.body[0].path.parts[0] ? [
                            XR(e344, n90),
                            ZR(e344, n90, t168),
                            eV(e344, n90, t168)
                        ] : [
                            HR(e344, n90),
                            hR([
                                ZR(e344, n90, t168),
                                eV(e344, n90, t168),
                                YR(e344, n90, t168)
                            ])
                        ];
                    }
                case "ElementModifierStatement":
                    return hR([
                        "{{",
                        uV(e344, n90),
                        "}}"
                    ]);
                case "MustacheStatement":
                    return hR([
                        $R(r73),
                        uV(e344, n90),
                        WR(r73)
                    ]);
                case "SubExpression":
                    return hR([
                        "(",
                        iV(e344, n90),
                        CR,
                        ")"
                    ]);
                case "AttrNode":
                    {
                        const e346 = "TextNode" === r73.value.type;
                        if (e346 && "" === r73.value.chars && xR(r73.value) === SR(r73.value)) return r73.name;
                        const t = e346 ? AR(r73.value.chars, o46).quote : "ConcatStatement" === r73.value.type ? AR(r73.value.parts.filter((e)=>"TextNode" === e.type
                        ).map((e)=>e.chars
                        ).join(""), o46).quote : "", i = n90("value");
                        return [
                            r73.name,
                            "=",
                            t,
                            "class" === r73.name && t ? hR(yR(i)) : i,
                            t
                        ];
                    }
                case "ConcatStatement":
                    return e344.map(n90, "parts");
                case "Hash":
                    return DR(ER, e344.map(n90, "pairs"));
                case "HashPair":
                    return [
                        r73.key,
                        "=",
                        n90("value")
                    ];
                case "TextNode":
                    {
                        let n92 = r73.chars.replace(/{{/g, "\\{{");
                        const o = function(e) {
                            for(let t = 0; t < 2; t++){
                                const n = e.getParentNode(t);
                                if (n && "AttrNode" === n.type) return n.name.toLowerCase();
                            }
                        }(e344);
                        if (o) {
                            if ("class" === o) {
                                const t = n92.trim().split(/\s+/).join(" ");
                                let r = !1, o = !1;
                                return IR(e344, [
                                    "ConcatStatement"
                                ]) && (LR(e344, [
                                    "MustacheStatement"
                                ]) && /^\s/.test(n92) && (r = !0), PR(e344, [
                                    "MustacheStatement"
                                ]) && /\s$/.test(n92) && "" !== t && (o = !0)), [
                                    r ? ER : "",
                                    t,
                                    o ? ER : ""
                                ];
                            }
                            return vR(n92);
                        }
                        const i = /^[\t\n\f\r ]*$/.test(n92), u = !BR(e344), s = !TR(e344);
                        if ("ignore" !== t168.htmlWhitespaceSensitivity) {
                            const t = /^[\t\n\f\r ]*/, r = /[\t\n\f\r ]*$/, o = s && IR(e344, [
                                "Template"
                            ]), a = u && IR(e344, [
                                "Template"
                            ]);
                            if (i) {
                                if (a || o) return "";
                                let t = [
                                    ER
                                ];
                                const r = nV(n92);
                                return r && (t = rV(r)), kR(e344) && (t = t.map((e)=>fR(e)
                                )), t;
                            }
                            const [c] = n92.match(t), [l] = n92.match(r);
                            let p = [];
                            if (c) {
                                p = [
                                    ER
                                ];
                                const e = nV(c);
                                e && (p = rV(e)), n92 = n92.replace(t, "");
                            }
                            let f = [];
                            if (l) {
                                if (!o) {
                                    f = [
                                        ER
                                    ];
                                    const t = nV(l);
                                    t && (f = rV(t)), kR(e344) && (f = f.map((e)=>fR(e)
                                    ));
                                }
                                n92 = n92.replace(r, "");
                            }
                            return [
                                ...p,
                                dR(tV(n92)),
                                ...f
                            ];
                        }
                        const a = nV(n92);
                        let c = function(e) {
                            return nV(((e = "string" == typeof e ? e : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
                        }(n92), l = function(e) {
                            return nV(((e = "string" == typeof e ? e : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
                        }(n92);
                        if ((u || s) && i && IR(e344, [
                            "Block",
                            "ElementNode",
                            "Template"
                        ])) return "";
                        i && a ? (c = Math.min(a, 2), l = 0) : (PR(e344, [
                            "BlockStatement",
                            "ElementNode"
                        ]) && (l = Math.max(l, 1)), LR(e344, [
                            "BlockStatement",
                            "ElementNode"
                        ]) && (c = Math.max(c, 1)));
                        let p = "", f = "";
                        return 0 === l && PR(e344, [
                            "MustacheStatement"
                        ]) && (f = " "), 0 === c && LR(e344, [
                            "MustacheStatement"
                        ]) && (p = " "), u && (c = 0, p = ""), s && (l = 0, f = ""), n92 = n92.replace(/^[\t\n\f\r ]+/g, p).replace(/[\t\n\f\r ]+$/, f), [
                            ...rV(c),
                            dR(tV(n92)),
                            ...rV(l)
                        ];
                    }
                case "MustacheCommentStatement":
                    {
                        const e = xR(r73), n = SR(r73), o = "~" === t168.originalText.charAt(e + 2), i = "~" === t168.originalText.charAt(n - 3), u = r73.value.includes("}}") ? "--" : "";
                        return [
                            "{{",
                            o ? "~" : "",
                            "!",
                            u,
                            r73.value,
                            u,
                            i ? "~" : "",
                            "}}"
                        ];
                    }
                case "PathExpression":
                    return r73.original;
                case "BooleanLiteral":
                case "NumberLiteral":
                    return String(r73.value);
                case "CommentStatement":
                    return [
                        "\x3c!--",
                        r73.value,
                        "--\x3e"
                    ];
                case "StringLiteral":
                    if ((function(e) {
                        let t = 0, n = e.getParentNode(t);
                        for(; n && OR(n, [
                            "SubExpression"
                        ]);)t++, n = e.getParentNode(t);
                        if (n && OR(e.getParentNode(t + 1), [
                            "ConcatStatement"
                        ]) && OR(e.getParentNode(t + 2), [
                            "AttrNode"
                        ])) return !0;
                        return !1;
                    })(e344)) {
                        const e = t168.singleQuote ? '"' : "'";
                        return oV(r73.value, e);
                    }
                    return oV(r73.value, o46);
                case "UndefinedLiteral":
                    return "undefined";
                case "NullLiteral":
                    return "null";
                default:
                    throw new Error("unknown glimmer type: " + JSON.stringify(r73.type));
            }
        },
        massageAstNode: wR
    };
    const pV = lV;
    var fV = {
        languages: [
            bE({
                name: "Handlebars",
                type: "markup",
                color: "#f7931e",
                aliases: [
                    "hbs",
                    "htmlbars"
                ],
                extensions: [
                    ".handlebars",
                    ".hbs"
                ],
                tmScope: "text.html.handlebars",
                aceMode: "handlebars",
                languageId: 155
            }, ()=>({
                    since: "2.3.0",
                    parsers: [
                        "glimmer"
                    ],
                    vscodeLanguageIds: [
                        "handlebars"
                    ]
                })
            )
        ],
        printers: {
            glimmer: pV
        },
        parsers: undefined
    };
    var dV = {
        hasPragma: function(e) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e);
        },
        insertPragma: function(e) {
            return "# @format\n\n" + e;
        }
    };
    var hV = {
        locStart: function(e) {
            return "number" == typeof e.start ? e.start : e.loc && e.loc.start;
        },
        locEnd: function(e) {
            return "number" == typeof e.end ? e.end : e.loc && e.loc.end;
        }
    };
    const { builders: { join: gV , hardline: mV , line: yV , softline: DV , group: EV , indent: CV , ifBreak: bV  }  } = Zc, { isNextLineEmpty: vV , isNonEmptyArray: AV  } = dc, { insertPragma: FV  } = dV, { locStart: xV , locEnd: SV  } = hV;
    function wV(e, t, n) {
        if (0 === n.directives.length) return "";
        const r = gV(yV, e.map(t, "directives"));
        return "FragmentDefinition" === n.kind || "OperationDefinition" === n.kind ? EV([
            yV,
            r
        ]) : [
            " ",
            EV(CV([
                DV,
                r
            ]))
        ];
    }
    function TV(e348, t, n) {
        const r = e348.getValue().length;
        return e348.map((e, o)=>{
            const i = n();
            return vV(t.originalText, e.getValue(), SV) && o < r - 1 ? [
                i,
                mV
            ] : i;
        });
    }
    function BV(e350, t, n) {
        const r = e350.getNode(), o = [], { interfaces: i  } = r, u = e350.map((e)=>n(e)
        , "interfaces");
        for(let e349 = 0; e349 < i.length; e349++){
            const n = i[e349];
            o.push(u[e349]);
            const r = i[e349 + 1];
            if (r) {
                const e = t.originalText.slice(n.loc.end, r.loc.start), i = e.includes("#"), u = e.replace(/#.*/g, "").trim();
                o.push("," === u ? "," : " &", i ? yV : " ");
            }
        }
        return o;
    }
    function NV() {
    }
    NV.ignoredProperties = new Set([
        "loc",
        "comments"
    ]);
    var kV = {
        print: function(e351, t, n) {
            const r = e351.getValue();
            if (!r) return "";
            if ("string" == typeof r) return r;
            switch(r.kind){
                case "Document":
                    {
                        const r = [];
                        return e351.each((e, o, i)=>{
                            r.push(n()), o !== i.length - 1 && (r.push(mV), vV(t.originalText, e.getValue(), SV) && r.push(mV));
                        }, "definitions"), [
                            ...r,
                            mV
                        ];
                    }
                case "OperationDefinition":
                    {
                        const o = "{" !== t.originalText[xV(r)], i = Boolean(r.name);
                        return [
                            o ? r.operation : "",
                            o && i ? [
                                " ",
                                n("name")
                            ] : "",
                            o && !i && AV(r.variableDefinitions) ? " " : "",
                            AV(r.variableDefinitions) ? EV([
                                "(",
                                CV([
                                    DV,
                                    gV([
                                        bV("", ", "),
                                        DV
                                    ], e351.map(n, "variableDefinitions"))
                                ]),
                                DV,
                                ")"
                            ]) : "",
                            wV(e351, n, r),
                            r.selectionSet && (o || i) ? " " : "",
                            n("selectionSet")
                        ];
                    }
                case "FragmentDefinition":
                    return [
                        "fragment ",
                        n("name"),
                        AV(r.variableDefinitions) ? EV([
                            "(",
                            CV([
                                DV,
                                gV([
                                    bV("", ", "),
                                    DV
                                ], e351.map(n, "variableDefinitions"))
                            ]),
                            DV,
                            ")"
                        ]) : "",
                        " on ",
                        n("typeCondition"),
                        wV(e351, n, r),
                        " ",
                        n("selectionSet")
                    ];
                case "SelectionSet":
                    return [
                        "{",
                        CV([
                            mV,
                            gV(mV, e351.call((e)=>TV(e, t, n)
                            , "selections"))
                        ]),
                        mV,
                        "}"
                    ];
                case "Field":
                    return EV([
                        r.alias ? [
                            n("alias"),
                            ": "
                        ] : "",
                        n("name"),
                        r.arguments.length > 0 ? EV([
                            "(",
                            CV([
                                DV,
                                gV([
                                    bV("", ", "),
                                    DV
                                ], e351.call((e)=>TV(e, t, n)
                                , "arguments"))
                            ]),
                            DV,
                            ")"
                        ]) : "",
                        wV(e351, n, r),
                        r.selectionSet ? " " : "",
                        n("selectionSet")
                    ]);
                case "Name":
                case "IntValue":
                case "FloatValue":
                case "EnumValue":
                    return r.value;
                case "StringValue":
                    return r.block ? [
                        '"""',
                        mV,
                        gV(mV, r.value.replace(/"""/g, "\\$&").split("\n")),
                        mV,
                        '"""'
                    ] : [
                        '"',
                        r.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"),
                        '"'
                    ];
                case "BooleanValue":
                    return r.value ? "true" : "false";
                case "NullValue":
                    return "null";
                case "Variable":
                    return [
                        "$",
                        n("name")
                    ];
                case "ListValue":
                    return EV([
                        "[",
                        CV([
                            DV,
                            gV([
                                bV("", ", "),
                                DV
                            ], e351.map(n, "values"))
                        ]),
                        DV,
                        "]"
                    ]);
                case "ObjectValue":
                    return EV([
                        "{",
                        t.bracketSpacing && r.fields.length > 0 ? " " : "",
                        CV([
                            DV,
                            gV([
                                bV("", ", "),
                                DV
                            ], e351.map(n, "fields"))
                        ]),
                        DV,
                        bV("", t.bracketSpacing && r.fields.length > 0 ? " " : ""),
                        "}"
                    ]);
                case "ObjectField":
                case "Argument":
                    return [
                        n("name"),
                        ": ",
                        n("value")
                    ];
                case "Directive":
                    return [
                        "@",
                        n("name"),
                        r.arguments.length > 0 ? EV([
                            "(",
                            CV([
                                DV,
                                gV([
                                    bV("", ", "),
                                    DV
                                ], e351.call((e)=>TV(e, t, n)
                                , "arguments"))
                            ]),
                            DV,
                            ")"
                        ]) : ""
                    ];
                case "NamedType":
                    return n("name");
                case "VariableDefinition":
                    return [
                        n("variable"),
                        ": ",
                        n("type"),
                        r.defaultValue ? [
                            " = ",
                            n("defaultValue")
                        ] : "",
                        wV(e351, n, r)
                    ];
                case "ObjectTypeExtension":
                case "ObjectTypeDefinition":
                    return [
                        n("description"),
                        r.description ? mV : "",
                        "ObjectTypeExtension" === r.kind ? "extend " : "",
                        "type ",
                        n("name"),
                        r.interfaces.length > 0 ? [
                            " implements ",
                            ...BV(e351, t, n)
                        ] : "",
                        wV(e351, n, r),
                        r.fields.length > 0 ? [
                            " {",
                            CV([
                                mV,
                                gV(mV, e351.call((e)=>TV(e, t, n)
                                , "fields"))
                            ]),
                            mV,
                            "}"
                        ] : ""
                    ];
                case "FieldDefinition":
                    return [
                        n("description"),
                        r.description ? mV : "",
                        n("name"),
                        r.arguments.length > 0 ? EV([
                            "(",
                            CV([
                                DV,
                                gV([
                                    bV("", ", "),
                                    DV
                                ], e351.call((e)=>TV(e, t, n)
                                , "arguments"))
                            ]),
                            DV,
                            ")"
                        ]) : "",
                        ": ",
                        n("type"),
                        wV(e351, n, r)
                    ];
                case "DirectiveDefinition":
                    return [
                        n("description"),
                        r.description ? mV : "",
                        "directive ",
                        "@",
                        n("name"),
                        r.arguments.length > 0 ? EV([
                            "(",
                            CV([
                                DV,
                                gV([
                                    bV("", ", "),
                                    DV
                                ], e351.call((e)=>TV(e, t, n)
                                , "arguments"))
                            ]),
                            DV,
                            ")"
                        ]) : "",
                        r.repeatable ? " repeatable" : "",
                        " on ",
                        gV(" | ", e351.map(n, "locations"))
                    ];
                case "EnumTypeExtension":
                case "EnumTypeDefinition":
                    return [
                        n("description"),
                        r.description ? mV : "",
                        "EnumTypeExtension" === r.kind ? "extend " : "",
                        "enum ",
                        n("name"),
                        wV(e351, n, r),
                        r.values.length > 0 ? [
                            " {",
                            CV([
                                mV,
                                gV(mV, e351.call((e)=>TV(e, t, n)
                                , "values"))
                            ]),
                            mV,
                            "}"
                        ] : ""
                    ];
                case "EnumValueDefinition":
                    return [
                        n("description"),
                        r.description ? mV : "",
                        n("name"),
                        wV(e351, n, r)
                    ];
                case "InputValueDefinition":
                    return [
                        n("description"),
                        r.description ? r.description.block ? mV : yV : "",
                        n("name"),
                        ": ",
                        n("type"),
                        r.defaultValue ? [
                            " = ",
                            n("defaultValue")
                        ] : "",
                        wV(e351, n, r)
                    ];
                case "InputObjectTypeExtension":
                case "InputObjectTypeDefinition":
                    return [
                        n("description"),
                        r.description ? mV : "",
                        "InputObjectTypeExtension" === r.kind ? "extend " : "",
                        "input ",
                        n("name"),
                        wV(e351, n, r),
                        r.fields.length > 0 ? [
                            " {",
                            CV([
                                mV,
                                gV(mV, e351.call((e)=>TV(e, t, n)
                                , "fields"))
                            ]),
                            mV,
                            "}"
                        ] : ""
                    ];
                case "SchemaDefinition":
                    return [
                        "schema",
                        wV(e351, n, r),
                        " {",
                        r.operationTypes.length > 0 ? CV([
                            mV,
                            gV(mV, e351.call((e)=>TV(e, t, n)
                            , "operationTypes"))
                        ]) : "",
                        mV,
                        "}"
                    ];
                case "OperationTypeDefinition":
                    return [
                        n("operation"),
                        ": ",
                        n("type")
                    ];
                case "InterfaceTypeExtension":
                case "InterfaceTypeDefinition":
                    return [
                        n("description"),
                        r.description ? mV : "",
                        "InterfaceTypeExtension" === r.kind ? "extend " : "",
                        "interface ",
                        n("name"),
                        r.interfaces.length > 0 ? [
                            " implements ",
                            ...BV(e351, t, n)
                        ] : "",
                        wV(e351, n, r),
                        r.fields.length > 0 ? [
                            " {",
                            CV([
                                mV,
                                gV(mV, e351.call((e)=>TV(e, t, n)
                                , "fields"))
                            ]),
                            mV,
                            "}"
                        ] : ""
                    ];
                case "FragmentSpread":
                    return [
                        "...",
                        n("name"),
                        wV(e351, n, r)
                    ];
                case "InlineFragment":
                    return [
                        "...",
                        r.typeCondition ? [
                            " on ",
                            n("typeCondition")
                        ] : "",
                        wV(e351, n, r),
                        " ",
                        n("selectionSet")
                    ];
                case "UnionTypeExtension":
                case "UnionTypeDefinition":
                    return EV([
                        n("description"),
                        r.description ? mV : "",
                        EV([
                            "UnionTypeExtension" === r.kind ? "extend " : "",
                            "union ",
                            n("name"),
                            wV(e351, n, r),
                            r.types.length > 0 ? [
                                " =",
                                bV("", " "),
                                CV([
                                    bV([
                                        yV,
                                        "  "
                                    ]),
                                    gV([
                                        yV,
                                        "| "
                                    ], e351.map(n, "types"))
                                ])
                            ] : ""
                        ])
                    ]);
                case "ScalarTypeExtension":
                case "ScalarTypeDefinition":
                    return [
                        n("description"),
                        r.description ? mV : "",
                        "ScalarTypeExtension" === r.kind ? "extend " : "",
                        "scalar ",
                        n("name"),
                        wV(e351, n, r)
                    ];
                case "NonNullType":
                    return [
                        n("type"),
                        "!"
                    ];
                case "ListType":
                    return [
                        "[",
                        n("type"),
                        "]"
                    ];
                default:
                    throw new Error("unknown graphql type: " + JSON.stringify(r.kind));
            }
        },
        massageAstNode: NV,
        hasPrettierIgnore: function(e352) {
            const t = e352.getValue();
            return t && Array.isArray(t.comments) && t.comments.some((e)=>"prettier-ignore" === e.value.trim()
            );
        },
        insertPragma: FV,
        printComment: function(e) {
            const t = e.getValue();
            if ("Comment" === t.kind) return "#" + t.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify(t));
        },
        canAttachComment: function(e) {
            return e.kind && "Comment" !== e.kind;
        }
    };
    const PV = kV, OV = {
        bracketSpacing: bj.bracketSpacing
    };
    var IV = {
        languages: [
            bE({
                name: "GraphQL",
                type: "data",
                color: "#e10098",
                extensions: [
                    ".graphql",
                    ".gql",
                    ".graphqls"
                ],
                tmScope: "source.graphql",
                aceMode: "text",
                languageId: 139
            }, ()=>({
                    since: "1.5.0",
                    parsers: [
                        "graphql"
                    ],
                    vscodeLanguageIds: [
                        "graphql"
                    ]
                })
            )
        ],
        options: OV,
        printers: {
            graphql: PV
        },
        parsers: undefined
    };
    var LV = {
        locStart: function(e) {
            return e.position.start.offset;
        },
        locEnd: function(e) {
            return e.position.end.offset;
        }
    };
    const { getLast: jV  } = dc, { locStart: _V , locEnd: MV  } = LV, { cjkPattern: RV , kPattern: VV , punctuationPattern: $V  } = {
        cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",
        kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
        punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
    }, WV = [
        "liquidNode",
        "inlineCode",
        "emphasis",
        "esComment",
        "strong",
        "delete",
        "wikiLink",
        "link",
        "linkReference",
        "image",
        "imageReference",
        "footnote",
        "footnoteReference",
        "sentence",
        "whitespace",
        "word",
        "break",
        "inlineMath"
    ], qV = [
        ...WV,
        "tableCell",
        "paragraph",
        "heading"
    ], UV = new RegExp(VV), zV = new RegExp($V);
    function GV(e, t) {
        const [, n, r, o] = t.slice(e.position.start.offset, e.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
        return {
            numberText: n,
            marker: r,
            leadingSpaces: o
        };
    }
    var HV = {
        mapAst: function(e353, t169) {
            return (function e(n94, r, o) {
                const i = Object.assign({
                }, t169(n94, r, o));
                return i.children && (i.children = i.children.map((t, n)=>e(t, n, [
                        i,
                        ...o
                    ])
                )), i;
            })(e353, null, []);
        },
        splitText: function(e355, t171) {
            const n = "non-cjk", r = "cj-letter", o = "cjk-punctuation", i = [], u21 = ("preserve" === t171.proseWrap ? e355 : e355.replace(new RegExp("(".concat(RV, ")\n(").concat(RV, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
            for (const [e354, t170] of u21.entries()){
                if (e354 % 2 == 1) {
                    i.push({
                        type: "whitespace",
                        value: /\n/.test(t170) ? "\n" : " "
                    });
                    continue;
                }
                if ((0 === e354 || e354 === u21.length - 1) && "" === t170) continue;
                const a = t170.split(new RegExp("(".concat(RV, ")")));
                for (const [e, t] of a.entries())(0 !== e && e !== a.length - 1 || "" !== t) && (e % 2 != 0 ? s15(zV.test(t) ? {
                    type: "word",
                    value: t,
                    kind: o,
                    hasLeadingPunctuation: !0,
                    hasTrailingPunctuation: !0
                } : {
                    type: "word",
                    value: t,
                    kind: UV.test(t) ? "k-letter" : r,
                    hasLeadingPunctuation: !1,
                    hasTrailingPunctuation: !1
                }) : "" !== t && s15({
                    type: "word",
                    value: t,
                    kind: n,
                    hasLeadingPunctuation: zV.test(t[0]),
                    hasTrailingPunctuation: zV.test(jV(t))
                }));
            }
            function s15(e356) {
                const t = jV(i);
                var u, s;
                t && "word" === t.type && (t.kind === n && e356.kind === r && !t.hasTrailingPunctuation || t.kind === r && e356.kind === n && !e356.hasLeadingPunctuation ? i.push({
                    type: "whitespace",
                    value: " "
                }) : (u = n, s = o, t.kind === u && e356.kind === s || t.kind === s && e356.kind === u || [
                    t.value,
                    e356.value
                ].some((e)=>/\u3000/.test(e)
                ) || i.push({
                    type: "whitespace",
                    value: ""
                }))), i.push(e356);
            }
            return i;
        },
        punctuationPattern: $V,
        getFencedCodeBlockValue: function(e, t) {
            const { value: n  } = e;
            return e.position.end.offset === t.length && n.endsWith("\n") && t.endsWith("\n") ? n.slice(0, -1) : n;
        },
        getOrderedListItemInfo: GV,
        hasGitDiffFriendlyOrderedList: function(e, t) {
            if (!e.ordered) return !1;
            if (e.children.length < 2) return !1;
            const n = Number(GV(e.children[0], t.originalText).numberText), r = Number(GV(e.children[1], t.originalText).numberText);
            if (0 === n && e.children.length > 2) {
                const n = Number(GV(e.children[2], t.originalText).numberText);
                return 1 === r && 1 === n;
            }
            return 1 === r;
        },
        INLINE_NODE_TYPES: WV,
        INLINE_NODE_WRAPPER_TYPES: qV,
        isAutolink: function(e) {
            if (!e || "link" !== e.type || 1 !== e.children.length) return !1;
            const t = e.children[0];
            return t && _V(e) === _V(t) && MV(e) === MV(t);
        }
    };
    const { inferParserByLanguage: JV , getMaxContinuousCount: XV  } = dc, { builders: { hardline: YV , markAsRoot: KV  } , utils: { replaceEndOfLine: QV  }  } = Zc, ZV = Wj, { getFencedCodeBlockValue: e$  } = HV;
    var t$ = function(e, t, n, r) {
        const o = e.getValue();
        if ("code" === o.type && null !== o.lang) {
            const e = JV(o.lang, r);
            if (e) {
                const t = r.__inJsTemplate ? "~" : "`", i = t.repeat(Math.max(3, XV(o.value, t) + 1)), u = {
                    parser: e
                };
                "tsx" === o.lang && (u.filepath = "dummy.tsx");
                const s = n(e$(o, r.originalText), u, {
                    stripTrailingHardline: !0
                });
                return KV([
                    i,
                    o.lang,
                    o.meta ? " " + o.meta : "",
                    YV,
                    QV(s),
                    YV,
                    i
                ]);
            }
        }
        switch(o.type){
            case "front-matter":
                return ZV(o, n);
            case "importExport":
                return [
                    n(o.value, {
                        parser: "babel"
                    }, {
                        stripTrailingHardline: !0
                    }),
                    YV
                ];
            case "jsx":
                return n("<$>".concat(o.value, "</$>"), {
                    parser: "__js_expression",
                    rootMarker: "mdx"
                }, {
                    stripTrailingHardline: !0
                });
        }
        return null;
    };
    const n$ = Hj, r$ = [
        "format",
        "prettier"
    ];
    function o$(e) {
        const t = "@(".concat(r$.join("|"), ")"), n = new RegExp([
            "\x3c!--\\s*".concat(t, "\\s*--\x3e"),
            "{\\s*\\/\\*\\s*".concat(t, "\\s*\\*\\/\\s*}"),
            "\x3c!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t, "[^\\S\n]*($|\n)[\\s\\S]*\n.*--\x3e")
        ].join("|"), "m"), r = e.match(n);
        return r && 0 === r.index;
    }
    var i$ = {
        startWithPragma: o$,
        hasPragma: (e)=>o$(n$(e).content.trimStart())
        ,
        insertPragma: (e)=>{
            const t = n$(e), n = "\x3c!-- @".concat(r$[0], " --\x3e");
            return t.frontMatter ? "".concat(t.frontMatter.raw, "\n\n").concat(n, "\n\n").concat(t.content) : "".concat(n, "\n\n").concat(t.content);
        }
    };
    const u$ = au, { getOrderedListItemInfo: s$ , mapAst: a$ , splitText: c$  } = HV, l$ = /^.$/us;
    function p$(e357, t, n) {
        return a$(e357, (e358)=>{
            if (!e358.children) return e358;
            const r74 = e358.children.reduce((e, r)=>{
                const o = u$(e);
                return o && t(o, r) ? e.splice(-1, 1, n(o, r)) : e.push(r), e;
            }, []);
            return Object.assign(Object.assign({
            }, e358), {
            }, {
                children: r74
            });
        });
    }
    var f$ = function(e359, t172) {
        return e359 = (function(e360, t) {
            return a$(e360, (e)=>"text" === e.type && "*" !== e.value && "_" !== e.value && l$.test(e.value) && e.position.end.offset - e.position.start.offset !== e.value.length ? Object.assign(Object.assign({
                }, e), {
                }, {
                    value: t.originalText.slice(e.position.start.offset, e.position.end.offset)
                }) : e
            );
        })(e359, t172), e359 = (function(e361, t173) {
            return a$(e361, (e, n, r)=>{
                if ("code" === e.type) {
                    const n = /^\n?(?: {4,}|\t)/.test(t173.originalText.slice(e.position.start.offset, e.position.end.offset));
                    if (e.isIndented = n, n) for(let e362 = 0; e362 < r.length; e362++){
                        const t = r[e362];
                        if (t.hasIndentedCodeblock) break;
                        "list" === t.type && (t.hasIndentedCodeblock = !0);
                    }
                }
                return e;
            });
        })(e359 = function(e363) {
            return a$(e363, (e)=>"inlineCode" !== e.type ? e : Object.assign(Object.assign({
                }, e), {
                }, {
                    value: e.value.replace(/\s+/g, " ")
                })
            );
        }(e359 = function(e364) {
            return p$(e364, (e, t)=>"text" === e.type && "text" === t.type
            , (e, t)=>({
                    type: "text",
                    value: e.value + t.value,
                    position: {
                        start: e.position.start,
                        end: t.position.end
                    }
                })
            );
        }(e359)), t172), e359 = (function(e365, t174) {
            function n95(e) {
                return 0 === e.children.length ? -1 : e.children[0].position.start.column - 1;
            }
            function r75(e) {
                if (!e.ordered) return !0;
                const [r, o] = e.children;
                if (s$(r, t174.originalText).leadingSpaces.length > 1) return !0;
                const i = n95(r);
                if (-1 === i) return !1;
                if (1 === e.children.length) return i % t174.tabWidth == 0;
                if (i !== n95(o)) return !1;
                if (i % t174.tabWidth == 0) return !0;
                return s$(o, t174.originalText).leadingSpaces.length > 1;
            }
            return a$(e365, (e, t, n)=>{
                if ("list" === e.type && e.children.length > 0) {
                    for(let t = 0; t < n.length; t++){
                        const r = n[t];
                        if ("list" === r.type && !r.isAligned) return e.isAligned = !1, e;
                    }
                    e.isAligned = r75(e);
                }
                return e;
            });
        })(e359, t172), e359 = (function(e366, t) {
            return a$(e366, (e, n, r)=>{
                let [o] = r;
                if ("text" !== e.type) return e;
                let { value: i  } = e;
                return "paragraph" === o.type && (0 === n && (i = i.trimStart()), n === o.children.length - 1 && (i = i.trimEnd())), {
                    type: "sentence",
                    position: e.position,
                    children: c$(i, t)
                };
            });
        })(e359, t172), e359 = (function(e367) {
            return p$(e367, (e, t)=>"importExport" === e.type && "importExport" === t.type
            , (e, t)=>({
                    type: "importExport",
                    value: e.value + "\n\n" + t.value,
                    position: {
                        start: e.position.start,
                        end: t.position.end
                    }
                })
            );
        })(e359 = function(e368) {
            return a$(e368, (e)=>"import" !== e.type && "export" !== e.type ? e : Object.assign(Object.assign({
                }, e), {
                }, {
                    type: "importExport"
                })
            );
        }(e359));
    };
    const { isFrontMatterNode: d$  } = dc, { startWithPragma: h$  } = i$, g$ = new Set([
        "position",
        "raw"
    ]);
    function m$(e, t, n) {
        return "front-matter" !== e.type && "code" !== e.type && "yaml" !== e.type && "import" !== e.type && "export" !== e.type && "jsx" !== e.type || delete t.value, "list" === e.type && delete t.isAligned, "list" !== e.type && "listItem" !== e.type || (delete t.spread, delete t.loose), "text" === e.type ? null : ("inlineCode" === e.type && (t.value = e.value.replace(/[\t\n ]+/g, " ")), "wikiLink" === e.type && (t.value = e.value.trim().replace(/[\t\n]+/g, " ")), "definition" !== e.type && "linkReference" !== e.type || (t.label = e.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), "definition" !== e.type && "link" !== e.type && "image" !== e.type || !e.title || (t.title = e.title.replace(/\\(["')])/g, "$1")), n && "root" === n.type && n.children.length > 0 && (n.children[0] === e || d$(n.children[0]) && n.children[1] === e) && "html" === e.type && h$(e.value) ? null : void 0);
    }
    m$.ignoredProperties = g$;
    var y$ = m$;
    const { getLast: D$ , getMinNotPresentContinuousCount: E$ , getMaxContinuousCount: C$ , getStringWidth: b$ , isNonEmptyArray: v$  } = dc, { builders: { breakParent: A$ , join: F$ , line: x$ , literalline: S$ , markAsRoot: w$ , hardline: T$ , softline: B$ , ifBreak: N$ , fill: k$ , align: P$ , indent: O$ , group: I$ , hardlineWithoutBreakParent: L$  } , utils: { normalizeDoc: j$ , replaceTextEndOfLine: _$  } , printer: { printDocToString: M$  }  } = Zc, R$ = t$, { insertPragma: V$  } = i$, { locStart: $$ , locEnd: W$  } = LV, q$ = f$, U$ = y$, { getFencedCodeBlockValue: z$ , hasGitDiffFriendlyOrderedList: G$ , splitText: H$ , punctuationPattern: J$ , INLINE_NODE_TYPES: X$ , INLINE_NODE_WRAPPER_TYPES: Y$ , isAutolink: K$  } = HV, Q$ = new Set([
        "importExport"
    ]), Z$ = [
        "heading",
        "tableCell",
        "link",
        "wikiLink"
    ], eW = new Set([
        "listItem",
        "definition",
        "footnoteDefinition"
    ]);
    function tW(e369, t175, n96, r) {
        const o47 = e369.getValue(), i = null === o47.checked ? "" : o47.checked ? "[x] " : "[ ] ";
        return [
            i,
            sW(e369, t175, n96, {
                processor: (e370, o)=>{
                    if (0 === o && "list" !== e370.getValue().type) return P$(" ".repeat(i.length), n96());
                    const u = " ".repeat(function(e, t, n) {
                        return e < t ? t : e > n ? n : e;
                    }(t175.tabWidth - r.length, 0, 3));
                    return [
                        u,
                        P$(u, n96())
                    ];
                }
            })
        ];
    }
    function nW(e371, t176) {
        return (function(e, t, n) {
            let r = -1;
            for (const o of t.children)if (o.type === e.type && n(o) ? r++ : r = -1, o === e) return r;
        })(e371, t176, (t)=>t.ordered === e371.ordered
        );
    }
    function rW(e, t) {
        const n = Array.isArray(t) ? t : [
            t
        ];
        let r, o = -1;
        for(; r = e.getParentNode(++o);)if (n.includes(r.type)) return o;
        return -1;
    }
    function oW(e, t) {
        const n = rW(e, t);
        return -1 === n ? null : e.getParentNode(n);
    }
    function iW(e, t, n) {
        if ("preserve" === n.proseWrap && "\n" === t) return T$;
        const r = "always" === n.proseWrap && !oW(e, Z$);
        return "" !== t ? r ? x$ : " " : r ? B$ : "";
    }
    function uW(e373, t, n) {
        const r = [];
        let o48 = null;
        const { children: i  } = e373.getValue();
        for (const [e372, t177] of i.entries())switch(cW(t177)){
            case "start":
                null === o48 && (o48 = {
                    index: e372,
                    offset: t177.position.end.offset
                });
                break;
            case "end":
                null !== o48 && (r.push({
                    start: o48,
                    end: {
                        index: e372,
                        offset: t177.position.start.offset
                    }
                }), o48 = null);
        }
        return sW(e373, t, n, {
            processor: (e, o)=>{
                if (r.length > 0) {
                    const e = r[0];
                    if (o === e.start.index) return [
                        i[e.start.index].value,
                        t.originalText.slice(e.start.offset, e.end.offset),
                        i[e.end.index].value
                    ];
                    if (e.start.index < o && o < e.end.index) return !1;
                    if (o === e.end.index) return r.shift(), !1;
                }
                return n();
            }
        });
    }
    function sW(e374, t, n97) {
        let r76 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
        };
        const { postprocessor: o49  } = r76, i = r76.processor || (()=>n97()
        ), u = e374.getValue(), s = [];
        let a;
        return e374.each((e, n)=>{
            const r = e.getValue(), o = i(e, n);
            if (!1 !== o) {
                const e = {
                    parts: s,
                    prevNode: a,
                    parentNode: u,
                    options: t
                };
                lW(r, e) && (s.push(T$), a && Q$.has(a.type) || (pW(r, e) || fW(r, e)) && s.push(T$), fW(r, e) && s.push(T$)), s.push(o), a = r;
            }
        }, "children"), o49 ? o49(s) : s;
    }
    function aW(e) {
        let t = e;
        for(; v$(t.children);)t = D$(t.children);
        return t;
    }
    function cW(e) {
        let t;
        if ("html" === e.type) t = e.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
        else {
            let n;
            "esComment" === e.type ? n = e : "paragraph" === e.type && 1 === e.children.length && "esComment" === e.children[0].type && (n = e.children[0]), n && (t = n.value.match(/^prettier-ignore(?:-(start|end))?$/));
        }
        return !!t && (t[1] ? t[1] : "next");
    }
    function lW(e, t) {
        const n = 0 === t.parts.length, r = X$.includes(e.type), o = "html" === e.type && Y$.includes(t.parentNode.type);
        return !n && !r && !o;
    }
    function pW(e, t) {
        const n = (t.prevNode && t.prevNode.type) === e.type && eW.has(e.type), r = "listItem" === t.parentNode.type && !t.parentNode.loose, o = t.prevNode && "listItem" === t.prevNode.type && t.prevNode.loose, i = "next" === cW(t.prevNode), u = "html" === e.type && t.prevNode && "html" === t.prevNode.type && t.prevNode.position.end.line + 1 === e.position.start.line, s = "html" === e.type && "listItem" === t.parentNode.type && t.prevNode && "paragraph" === t.prevNode.type && t.prevNode.position.end.line + 1 === e.position.start.line;
        return o || !(n || r || i || u || s);
    }
    function fW(e, t) {
        const n = t.prevNode && "list" === t.prevNode.type, r = "code" === e.type && e.isIndented;
        return n && r;
    }
    function dW(e375) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
        const n = [
            " ",
            ...Array.isArray(t) ? t : [
                t
            ]
        ];
        return new RegExp(n.map((e)=>"\\".concat(e)
        ).join("|")).test(e375) ? "<".concat(e375, ">") : e375;
    }
    function hW(e, t) {
        let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        if (!e) return "";
        if (n) return " " + hW(e, t, !1);
        if ((e = e.replace(/\\(["')])/g, "$1")).includes('"') && e.includes("'") && !e.includes(")")) return "(".concat(e, ")");
        const r = e.split("'").length - 1, o = e.split('"').length - 1, i = r > o ? '"' : o > r || t.singleQuote ? "'" : '"';
        return e = (e = e.replace(/\\/, "\\\\")).replace(new RegExp("(".concat(i, ")"), "g"), "\\$1"), "".concat(i).concat(e).concat(i);
    }
    var gW = {
        preprocess: q$,
        print: function(e376, t178, n98) {
            const r77 = e376.getValue();
            if ((function(e) {
                const t = oW(e, [
                    "linkReference",
                    "imageReference"
                ]);
                return t && ("linkReference" !== t.type || "full" !== t.referenceType);
            })(e376)) return H$(t178.originalText.slice(r77.position.start.offset, r77.position.end.offset), t178).map((n)=>"word" === n.type ? n.value : "" === n.value ? "" : iW(e376, n.value, t178)
            );
            switch(r77.type){
                case "front-matter":
                    return t178.originalText.slice(r77.position.start.offset, r77.position.end.offset);
                case "root":
                    return 0 === r77.children.length ? "" : [
                        j$(uW(e376, t178, n98)),
                        Q$.has(aW(r77).type) ? "" : T$
                    ];
                case "paragraph":
                    return sW(e376, t178, n98, {
                        postprocessor: k$
                    });
                case "sentence":
                    return sW(e376, t178, n98);
                case "word":
                    {
                        let t179 = r77.value.replace(/\*/g, "\\$&").replace(new RegExp([
                            "(^|".concat(J$, ")(_+)"),
                            "(_+)(".concat(J$, "|$)")
                        ].join("|"), "g"), (e, t, n, r, o)=>(n ? "".concat(t).concat(n) : "".concat(r).concat(o)).replace(/_/g, "\\_")
                        );
                        const n99 = (e, t, n)=>"sentence" === e.type && 0 === n
                        , o50 = (e, t, n)=>K$(e.children[n - 1])
                        ;
                        return t179 !== r77.value && (e376.match(void 0, n99, o50) || e376.match(void 0, n99, (e, t, n)=>"emphasis" === e.type && 0 === n
                        , o50)) && (t179 = t179.replace(/^(\\?[*_])+/, (e)=>e.replace(/\\/g, "")
                        )), t179;
                    }
                case "whitespace":
                    {
                        const n = e376.getParentNode(), o = n.children.indexOf(r77), i = n.children[o + 1], u = i && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(i.value) ? "never" : t178.proseWrap;
                        return iW(e376, r77.value, {
                            proseWrap: u
                        });
                    }
                case "emphasis":
                    {
                        let o;
                        if (K$(r77.children[0])) o = t178.originalText[r77.position.start.offset];
                        else {
                            const t = e376.getParentNode(), n = t.children.indexOf(r77), i = t.children[n - 1], u = t.children[n + 1];
                            o = i && "sentence" === i.type && i.children.length > 0 && "word" === D$(i.children).type && !D$(i.children).hasTrailingPunctuation || u && "sentence" === u.type && u.children.length > 0 && "word" === u.children[0].type && !u.children[0].hasLeadingPunctuation || oW(e376, "emphasis") ? "*" : "_";
                        }
                        return [
                            o,
                            sW(e376, t178, n98),
                            o
                        ];
                    }
                case "strong":
                    return [
                        "**",
                        sW(e376, t178, n98),
                        "**"
                    ];
                case "delete":
                    return [
                        "~~",
                        sW(e376, t178, n98),
                        "~~"
                    ];
                case "inlineCode":
                    {
                        const e = E$(r77.value, "`"), t = "`".repeat(e || 1), n = e && !/^\s/.test(r77.value) ? " " : "";
                        return [
                            t,
                            n,
                            r77.value,
                            n,
                            t
                        ];
                    }
                case "wikiLink":
                    {
                        let e = "";
                        return e = "preserve" === t178.proseWrap ? r77.value : r77.value.replace(/[\t\n]+/g, " "), [
                            "[[",
                            e,
                            "]]"
                        ];
                    }
                case "link":
                    switch(t178.originalText[r77.position.start.offset]){
                        case "<":
                            {
                                const e = "mailto:";
                                return [
                                    "<",
                                    r77.url.startsWith(e) && t178.originalText.slice(r77.position.start.offset + 1, r77.position.start.offset + 1 + e.length) !== e ? r77.url.slice(e.length) : r77.url,
                                    ">"
                                ];
                            }
                        case "[":
                            return [
                                "[",
                                sW(e376, t178, n98),
                                "](",
                                dW(r77.url, ")"),
                                hW(r77.title, t178),
                                ")"
                            ];
                        default:
                            return t178.originalText.slice(r77.position.start.offset, r77.position.end.offset);
                    }
                case "image":
                    return [
                        "![",
                        r77.alt || "",
                        "](",
                        dW(r77.url, ")"),
                        hW(r77.title, t178),
                        ")"
                    ];
                case "blockquote":
                    return [
                        "> ",
                        P$("> ", sW(e376, t178, n98))
                    ];
                case "heading":
                    return [
                        "#".repeat(r77.depth) + " ",
                        sW(e376, t178, n98)
                    ];
                case "code":
                    {
                        if (r77.isIndented) {
                            const e = " ".repeat(4);
                            return P$(e, [
                                e,
                                ..._$(r77.value, T$)
                            ]);
                        }
                        const e = t178.__inJsTemplate ? "~" : "`", n = e.repeat(Math.max(3, C$(r77.value, e) + 1));
                        return [
                            n,
                            r77.lang || "",
                            r77.meta ? " " + r77.meta : "",
                            T$,
                            ..._$(z$(r77, t178.originalText), T$),
                            T$,
                            n
                        ];
                    }
                case "html":
                    {
                        const t = e376.getParentNode(), n = "root" === t.type && D$(t.children) === r77 ? r77.value.trimEnd() : r77.value, o = /^<!--.*-->$/s.test(n);
                        return _$(n, o ? T$ : w$(S$));
                    }
                case "list":
                    {
                        const o = nW(r77, e376.getParentNode()), i = G$(r77, t178);
                        return sW(e376, t178, n98, {
                            processor: (e377, u)=>{
                                const s = function() {
                                    const e378 = r77.ordered ? (0 === u ? r77.start : i ? 1 : r77.start + u) + (o % 2 == 0 ? ". " : ") ") : o % 2 == 0 ? "- " : "* ";
                                    return r77.isAligned || r77.hasIndentedCodeblock ? (function(e, t) {
                                        const n101 = r();
                                        function r() {
                                            const n = e.length % t.tabWidth;
                                            return 0 === n ? 0 : t.tabWidth - n;
                                        }
                                        return e + " ".repeat(n101 >= 4 ? 0 : n101);
                                    })(e378, t178) : e378;
                                }(), a = e377.getValue();
                                return 2 === a.children.length && "html" === a.children[1].type && a.children[0].position.start.column !== a.children[1].position.start.column ? [
                                    s,
                                    tW(e377, t178, n98, s)
                                ] : [
                                    s,
                                    P$(" ".repeat(s.length), tW(e377, t178, n98, s))
                                ];
                            }
                        });
                    }
                case "thematicBreak":
                    {
                        const t = rW(e376, "list");
                        if (-1 === t) return "---";
                        return nW(e376.getParentNode(t), e376.getParentNode(t + 1)) % 2 == 0 ? "***" : "---";
                    }
                case "linkReference":
                    return [
                        "[",
                        sW(e376, t178, n98),
                        "]",
                        "full" === r77.referenceType ? [
                            "[",
                            r77.identifier,
                            "]"
                        ] : "collapsed" === r77.referenceType ? "[]" : ""
                    ];
                case "imageReference":
                    return "full" === r77.referenceType ? [
                        "![",
                        r77.alt || "",
                        "][",
                        r77.identifier,
                        "]"
                    ] : [
                        "![",
                        r77.alt,
                        "]",
                        "collapsed" === r77.referenceType ? "[]" : ""
                    ];
                case "definition":
                    {
                        const e = "always" === t178.proseWrap ? x$ : " ";
                        return I$([
                            "[",
                            r77.identifier,
                            "]:",
                            O$([
                                e,
                                dW(r77.url),
                                null === r77.title ? "" : [
                                    e,
                                    hW(r77.title, t178, !1)
                                ]
                            ])
                        ]);
                    }
                case "footnote":
                    return [
                        "[^",
                        sW(e376, t178, n98),
                        "]"
                    ];
                case "footnoteReference":
                    return [
                        "[^",
                        r77.identifier,
                        "]"
                    ];
                case "footnoteDefinition":
                    {
                        const o = e376.getParentNode().children[e376.getName() + 1], i = 1 === r77.children.length && "paragraph" === r77.children[0].type && ("never" === t178.proseWrap || "preserve" === t178.proseWrap && r77.children[0].position.start.line === r77.children[0].position.end.line);
                        return [
                            "[^",
                            r77.identifier,
                            "]: ",
                            i ? sW(e376, t178, n98) : I$([
                                P$(" ".repeat(4), sW(e376, t178, n98, {
                                    processor: (e, t)=>0 === t ? I$([
                                            B$,
                                            n98()
                                        ]) : n98()
                                })),
                                o && "footnoteDefinition" === o.type ? B$ : ""
                            ])
                        ];
                    }
                case "table":
                    return (function(e379, t181, n102) {
                        const r = e379.getValue(), o52 = [], i28 = e379.map((e)=>e.map((e, r)=>{
                                const i = M$(n102(), t181).formatted, u = b$(i);
                                return o52[r] = Math.max(o52[r] || 3, u), {
                                    text: i,
                                    width: u
                                };
                            }, "children")
                        , "children"), u22 = a10(!1);
                        if ("never" !== t181.proseWrap) return [
                            A$,
                            u22
                        ];
                        const s16 = a10(!0);
                        function a10(e) {
                            const t182 = [
                                l4(i28[0], e),
                                c5(e)
                            ];
                            return i28.length > 1 && t182.push(F$(L$, i28.slice(1).map((t)=>l4(t, e)
                            ))), F$(L$, t182);
                        }
                        function c5(e) {
                            const t183 = o52.map((t, n)=>{
                                const o = r.align[n], i = "center" === o || "left" === o ? ":" : "-", u = "center" === o || "right" === o ? ":" : "-", s = e ? "-" : "-".repeat(t - 2);
                                return "".concat(i).concat(s).concat(u);
                            });
                            return "| ".concat(t183.join(" | "), " |");
                        }
                        function l4(e380, t) {
                            const n = e380.map((e, n)=>{
                                let { text: i , width: u  } = e;
                                if (t) return i;
                                const s = o52[n] - u, a = r.align[n];
                                let c = 0;
                                "right" === a ? c = s : "center" === a && (c = Math.floor(s / 2));
                                const l = s - c;
                                return "".concat(" ".repeat(c)).concat(i).concat(" ".repeat(l));
                            });
                            return "| ".concat(n.join(" | "), " |");
                        }
                        return [
                            A$,
                            I$(N$(s16, u22))
                        ];
                    })(e376, t178, n98);
                case "tableCell":
                    return sW(e376, t178, n98);
                case "break":
                    return /\s/.test(t178.originalText[r77.position.start.offset]) ? [
                        "  ",
                        w$(S$)
                    ] : [
                        "\\",
                        T$
                    ];
                case "liquidNode":
                    return _$(r77.value, T$);
                case "importExport":
                    return [
                        r77.value,
                        T$
                    ];
                case "esComment":
                    return [
                        "{/* ",
                        r77.value,
                        " */}"
                    ];
                case "jsx":
                    return r77.value;
                case "math":
                    return [
                        "$$",
                        T$,
                        r77.value ? [
                            ..._$(r77.value, T$),
                            T$
                        ] : "",
                        "$$"
                    ];
                case "inlineMath":
                    return t178.originalText.slice($$(r77), W$(r77));
                default:
                    throw new Error("Unknown markdown type ".concat(JSON.stringify(r77.type)));
            }
        },
        embed: R$,
        massageAstNode: U$,
        hasPrettierIgnore: function(e) {
            const t = Number(e.getName());
            return 0 !== t && "next" === cW(e.getParentNode().children[t - 1]);
        },
        insertPragma: V$
    };
    var mW = {
        name: "Markdown",
        type: "prose",
        color: "#083fa1",
        aliases: [
            "pandoc"
        ],
        aceMode: "markdown",
        codemirrorMode: "gfm",
        codemirrorMimeType: "text/x-gfm",
        wrap: !0,
        extensions: [
            ".md",
            ".markdown",
            ".mdown",
            ".mdwn",
            ".mdx",
            ".mkd",
            ".mkdn",
            ".mkdown",
            ".ronn",
            ".scd",
            ".workbook"
        ],
        filenames: [
            "contents.lr"
        ],
        tmScope: "source.gfm",
        languageId: 222
    };
    const yW = bE, DW = gW, EW = {
        proseWrap: bj.proseWrap,
        singleQuote: bj.singleQuote
    }, CW = [
        yW(mW, (e381)=>({
                since: "1.8.0",
                parsers: [
                    "markdown"
                ],
                vscodeLanguageIds: [
                    "markdown"
                ],
                filenames: [
                    ...e381.filenames,
                    "README"
                ],
                extensions: e381.extensions.filter((e)=>".mdx" !== e
                )
            })
        ),
        yW(mW, ()=>({
                name: "MDX",
                since: "1.15.0",
                parsers: [
                    "mdx"
                ],
                vscodeLanguageIds: [
                    "mdx"
                ],
                filenames: [],
                extensions: [
                    ".mdx"
                ]
            })
        )
    ];
    var bW = {
        languages: CW,
        options: EW,
        printers: {
            mdast: DW
        },
        parsers: undefined
    };
    const { isFrontMatterNode: vW  } = dc, AW = new Set([
        "sourceSpan",
        "startSourceSpan",
        "endSourceSpan",
        "nameSpan",
        "valueSpan"
    ]);
    function FW(e, t) {
        return "text" === e.type || "comment" === e.type || vW(e) || "yaml" === e.type || "toml" === e.type ? null : ("attribute" === e.type && delete t.value, void ("docType" === e.type && delete t.value));
    }
    FW.ignoredProperties = AW;
    var xW = FW;
    const SW = [
        "a",
        "abbr",
        "acronym",
        "address",
        "applet",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "base",
        "basefont",
        "bdi",
        "bdo",
        "bgsound",
        "big",
        "blink",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "center",
        "cite",
        "code",
        "col",
        "colgroup",
        "command",
        "content",
        "data",
        "datalist",
        "dd",
        "del",
        "details",
        "dfn",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "element",
        "em",
        "embed",
        "fieldset",
        "figcaption",
        "figure",
        "font",
        "footer",
        "form",
        "frame",
        "frameset",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "iframe",
        "image",
        "img",
        "input",
        "ins",
        "isindex",
        "kbd",
        "keygen",
        "label",
        "legend",
        "li",
        "link",
        "listing",
        "main",
        "map",
        "mark",
        "marquee",
        "math",
        "menu",
        "menuitem",
        "meta",
        "meter",
        "multicol",
        "nav",
        "nextid",
        "nobr",
        "noembed",
        "noframes",
        "noscript",
        "object",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "param",
        "picture",
        "plaintext",
        "pre",
        "progress",
        "q",
        "rb",
        "rbc",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "script",
        "section",
        "select",
        "shadow",
        "slot",
        "small",
        "source",
        "spacer",
        "span",
        "strike",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "svg",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "title",
        "tr",
        "track",
        "tt",
        "u",
        "ul",
        "var",
        "video",
        "wbr",
        "xmp"
    ], wW = {
        "*": [
            "accesskey",
            "autocapitalize",
            "autofocus",
            "class",
            "contenteditable",
            "dir",
            "draggable",
            "enterkeyhint",
            "hidden",
            "id",
            "inputmode",
            "is",
            "itemid",
            "itemprop",
            "itemref",
            "itemscope",
            "itemtype",
            "lang",
            "nonce",
            "slot",
            "spellcheck",
            "style",
            "tabindex",
            "title",
            "translate"
        ],
        a: [
            "accesskey",
            "charset",
            "coords",
            "download",
            "href",
            "hreflang",
            "name",
            "ping",
            "referrerpolicy",
            "rel",
            "rev",
            "shape",
            "tabindex",
            "target",
            "type"
        ],
        abbr: [
            "title"
        ],
        applet: [
            "align",
            "alt",
            "archive",
            "code",
            "codebase",
            "height",
            "hspace",
            "name",
            "object",
            "vspace",
            "width"
        ],
        area: [
            "accesskey",
            "alt",
            "coords",
            "download",
            "href",
            "hreflang",
            "nohref",
            "ping",
            "referrerpolicy",
            "rel",
            "shape",
            "tabindex",
            "target",
            "type"
        ],
        audio: [
            "autoplay",
            "controls",
            "crossorigin",
            "loop",
            "muted",
            "preload",
            "src"
        ],
        base: [
            "href",
            "target"
        ],
        basefont: [
            "color",
            "face",
            "size"
        ],
        bdo: [
            "dir"
        ],
        blockquote: [
            "cite"
        ],
        body: [
            "alink",
            "background",
            "bgcolor",
            "link",
            "text",
            "vlink"
        ],
        br: [
            "clear"
        ],
        button: [
            "accesskey",
            "autofocus",
            "disabled",
            "form",
            "formaction",
            "formenctype",
            "formmethod",
            "formnovalidate",
            "formtarget",
            "name",
            "tabindex",
            "type",
            "value"
        ],
        canvas: [
            "height",
            "width"
        ],
        caption: [
            "align"
        ],
        col: [
            "align",
            "char",
            "charoff",
            "span",
            "valign",
            "width"
        ],
        colgroup: [
            "align",
            "char",
            "charoff",
            "span",
            "valign",
            "width"
        ],
        data: [
            "value"
        ],
        del: [
            "cite",
            "datetime"
        ],
        details: [
            "open"
        ],
        dfn: [
            "title"
        ],
        dialog: [
            "open"
        ],
        dir: [
            "compact"
        ],
        div: [
            "align"
        ],
        dl: [
            "compact"
        ],
        embed: [
            "height",
            "src",
            "type",
            "width"
        ],
        fieldset: [
            "disabled",
            "form",
            "name"
        ],
        font: [
            "color",
            "face",
            "size"
        ],
        form: [
            "accept",
            "accept-charset",
            "action",
            "autocomplete",
            "enctype",
            "method",
            "name",
            "novalidate",
            "target"
        ],
        frame: [
            "frameborder",
            "longdesc",
            "marginheight",
            "marginwidth",
            "name",
            "noresize",
            "scrolling",
            "src"
        ],
        frameset: [
            "cols",
            "rows"
        ],
        h1: [
            "align"
        ],
        h2: [
            "align"
        ],
        h3: [
            "align"
        ],
        h4: [
            "align"
        ],
        h5: [
            "align"
        ],
        h6: [
            "align"
        ],
        head: [
            "profile"
        ],
        hr: [
            "align",
            "noshade",
            "size",
            "width"
        ],
        html: [
            "manifest",
            "version"
        ],
        iframe: [
            "align",
            "allow",
            "allowfullscreen",
            "allowpaymentrequest",
            "allowusermedia",
            "frameborder",
            "height",
            "loading",
            "longdesc",
            "marginheight",
            "marginwidth",
            "name",
            "referrerpolicy",
            "sandbox",
            "scrolling",
            "src",
            "srcdoc",
            "width"
        ],
        img: [
            "align",
            "alt",
            "border",
            "crossorigin",
            "decoding",
            "height",
            "hspace",
            "ismap",
            "loading",
            "longdesc",
            "name",
            "referrerpolicy",
            "sizes",
            "src",
            "srcset",
            "usemap",
            "vspace",
            "width"
        ],
        input: [
            "accept",
            "accesskey",
            "align",
            "alt",
            "autocomplete",
            "autofocus",
            "checked",
            "dirname",
            "disabled",
            "form",
            "formaction",
            "formenctype",
            "formmethod",
            "formnovalidate",
            "formtarget",
            "height",
            "ismap",
            "list",
            "max",
            "maxlength",
            "min",
            "minlength",
            "multiple",
            "name",
            "pattern",
            "placeholder",
            "readonly",
            "required",
            "size",
            "src",
            "step",
            "tabindex",
            "title",
            "type",
            "usemap",
            "value",
            "width"
        ],
        ins: [
            "cite",
            "datetime"
        ],
        isindex: [
            "prompt"
        ],
        label: [
            "accesskey",
            "for",
            "form"
        ],
        legend: [
            "accesskey",
            "align"
        ],
        li: [
            "type",
            "value"
        ],
        link: [
            "as",
            "charset",
            "color",
            "crossorigin",
            "disabled",
            "href",
            "hreflang",
            "imagesizes",
            "imagesrcset",
            "integrity",
            "media",
            "nonce",
            "referrerpolicy",
            "rel",
            "rev",
            "sizes",
            "target",
            "title",
            "type"
        ],
        map: [
            "name"
        ],
        menu: [
            "compact"
        ],
        meta: [
            "charset",
            "content",
            "http-equiv",
            "name",
            "scheme"
        ],
        meter: [
            "high",
            "low",
            "max",
            "min",
            "optimum",
            "value"
        ],
        object: [
            "align",
            "archive",
            "border",
            "classid",
            "codebase",
            "codetype",
            "data",
            "declare",
            "form",
            "height",
            "hspace",
            "name",
            "standby",
            "tabindex",
            "type",
            "typemustmatch",
            "usemap",
            "vspace",
            "width"
        ],
        ol: [
            "compact",
            "reversed",
            "start",
            "type"
        ],
        optgroup: [
            "disabled",
            "label"
        ],
        option: [
            "disabled",
            "label",
            "selected",
            "value"
        ],
        output: [
            "for",
            "form",
            "name"
        ],
        p: [
            "align"
        ],
        param: [
            "name",
            "type",
            "value",
            "valuetype"
        ],
        pre: [
            "width"
        ],
        progress: [
            "max",
            "value"
        ],
        q: [
            "cite"
        ],
        script: [
            "async",
            "charset",
            "crossorigin",
            "defer",
            "integrity",
            "language",
            "nomodule",
            "nonce",
            "referrerpolicy",
            "src",
            "type"
        ],
        select: [
            "autocomplete",
            "autofocus",
            "disabled",
            "form",
            "multiple",
            "name",
            "required",
            "size",
            "tabindex"
        ],
        slot: [
            "name"
        ],
        source: [
            "media",
            "sizes",
            "src",
            "srcset",
            "type"
        ],
        style: [
            "media",
            "nonce",
            "title",
            "type"
        ],
        table: [
            "align",
            "bgcolor",
            "border",
            "cellpadding",
            "cellspacing",
            "frame",
            "rules",
            "summary",
            "width"
        ],
        tbody: [
            "align",
            "char",
            "charoff",
            "valign"
        ],
        td: [
            "abbr",
            "align",
            "axis",
            "bgcolor",
            "char",
            "charoff",
            "colspan",
            "headers",
            "height",
            "nowrap",
            "rowspan",
            "scope",
            "valign",
            "width"
        ],
        textarea: [
            "accesskey",
            "autocomplete",
            "autofocus",
            "cols",
            "dirname",
            "disabled",
            "form",
            "maxlength",
            "minlength",
            "name",
            "placeholder",
            "readonly",
            "required",
            "rows",
            "tabindex",
            "wrap"
        ],
        tfoot: [
            "align",
            "char",
            "charoff",
            "valign"
        ],
        th: [
            "abbr",
            "align",
            "axis",
            "bgcolor",
            "char",
            "charoff",
            "colspan",
            "headers",
            "height",
            "nowrap",
            "rowspan",
            "scope",
            "valign",
            "width"
        ],
        thead: [
            "align",
            "char",
            "charoff",
            "valign"
        ],
        time: [
            "datetime"
        ],
        tr: [
            "align",
            "bgcolor",
            "char",
            "charoff",
            "valign"
        ],
        track: [
            "default",
            "kind",
            "label",
            "src",
            "srclang"
        ],
        ul: [
            "compact",
            "type"
        ],
        video: [
            "autoplay",
            "controls",
            "crossorigin",
            "height",
            "loop",
            "muted",
            "playsinline",
            "poster",
            "preload",
            "src",
            "width"
        ]
    }, { inferParserByLanguage: TW , isFrontMatterNode: BW  } = dc, { builders: { line: NW , hardline: kW , join: PW  } , utils: { getDocParts: OW , replaceTextEndOfLine: IW  }  } = Zc, { CSS_DISPLAY_TAGS: LW , CSS_DISPLAY_DEFAULT: jW , CSS_WHITE_SPACE_TAGS: _W , CSS_WHITE_SPACE_DEFAULT: MW  } = {
        CSS_DISPLAY_TAGS: {
            area: "none",
            base: "none",
            basefont: "none",
            datalist: "none",
            head: "none",
            link: "none",
            meta: "none",
            noembed: "none",
            noframes: "none",
            param: "block",
            rp: "none",
            script: "block",
            source: "block",
            style: "none",
            template: "inline",
            track: "block",
            title: "none",
            html: "block",
            body: "block",
            address: "block",
            blockquote: "block",
            center: "block",
            div: "block",
            figure: "block",
            figcaption: "block",
            footer: "block",
            form: "block",
            header: "block",
            hr: "block",
            legend: "block",
            listing: "block",
            main: "block",
            p: "block",
            plaintext: "block",
            pre: "block",
            xmp: "block",
            slot: "contents",
            ruby: "ruby",
            rt: "ruby-text",
            article: "block",
            aside: "block",
            h1: "block",
            h2: "block",
            h3: "block",
            h4: "block",
            h5: "block",
            h6: "block",
            hgroup: "block",
            nav: "block",
            section: "block",
            dir: "block",
            dd: "block",
            dl: "block",
            dt: "block",
            ol: "block",
            ul: "block",
            li: "list-item",
            table: "table",
            caption: "table-caption",
            colgroup: "table-column-group",
            col: "table-column",
            thead: "table-header-group",
            tbody: "table-row-group",
            tfoot: "table-footer-group",
            tr: "table-row",
            td: "table-cell",
            th: "table-cell",
            fieldset: "block",
            button: "inline-block",
            details: "block",
            summary: "block",
            dialog: "block",
            meter: "inline-block",
            progress: "inline-block",
            object: "inline-block",
            video: "inline-block",
            audio: "inline-block",
            select: "inline-block",
            option: "block",
            optgroup: "block"
        },
        CSS_DISPLAY_DEFAULT: "inline",
        CSS_WHITE_SPACE_TAGS: {
            listing: "pre",
            plaintext: "pre",
            pre: "pre",
            xmp: "pre",
            nobr: "nowrap",
            table: "initial",
            textarea: "pre-wrap"
        },
        CSS_WHITE_SPACE_DEFAULT: "normal"
    }, RW = GW(SW), VW = function(e, t) {
        const n = Object.create(null);
        for (const [r, o] of Object.entries(e))n[r] = t(o, r);
        return n;
    }(wW, GW), $W = new Set([
        "\t",
        "\n",
        "\f",
        "\r",
        " "
    ]), WW = (e)=>e.replace(/[\t\n\f\r ]+$/, "")
    , qW = (e382)=>((e)=>e.replace(/^[\t\f\r ]*?\n/g, "")
        )(WW(e382))
    , UW = (e)=>e.split(/[\t\n\f\r ]+/)
    , zW = (e)=>e.match(/^[\t\n\f\r ]*/)[0]
    ;
    function GW(e) {
        const t = Object.create(null);
        for (const n of e)t[n] = !0;
        return t;
    }
    function HW(e) {
        return "element" === e.type && ("script" === e.fullName || "style" === e.fullName || "svg:style" === e.fullName || oq(e) && ("script" === e.name || "style" === e.name));
    }
    function JW(e) {
        return iq(e).startsWith("pre");
    }
    function XW(e) {
        return "element" === e.type && e.children.length > 0 && ([
            "html",
            "head",
            "ul",
            "ol",
            "select"
        ].includes(e.name) || e.cssDisplay.startsWith("table") && "table-cell" !== e.cssDisplay);
    }
    function YW(e) {
        return eq(e) || "element" === e.type && "br" === e.fullName || KW(e);
    }
    function KW(e) {
        return QW(e) && ZW(e);
    }
    function QW(e) {
        return e.hasLeadingSpaces && (e.prev ? e.prev.sourceSpan.end.line < e.sourceSpan.start.line : "root" === e.parent.type || e.parent.startSourceSpan.end.line < e.sourceSpan.start.line);
    }
    function ZW(e) {
        return e.hasTrailingSpaces && (e.next ? e.next.sourceSpan.start.line > e.sourceSpan.end.line : "root" === e.parent.type || e.parent.endSourceSpan && e.parent.endSourceSpan.start.line > e.sourceSpan.end.line);
    }
    function eq(e) {
        switch(e.type){
            case "ieConditionalComment":
            case "comment":
            case "directive":
                return !0;
            case "element":
                return [
                    "script",
                    "select"
                ].includes(e.name);
        }
        return !1;
    }
    function tq(e) {
        const { type: t , lang: n  } = e.attrMap;
        return "module" === t || "text/javascript" === t || "text/babel" === t || "application/javascript" === t || "jsx" === n ? "babel" : "application/x-typescript" === t || "ts" === n || "tsx" === n ? "typescript" : "text/markdown" === t ? "markdown" : "text/html" === t ? "html" : t && (t.endsWith("json") || t.endsWith("importmap")) ? "json" : "text/x-handlebars-template" === t ? "glimmer" : void 0;
    }
    function nq(e) {
        return "block" === e || "list-item" === e || e.startsWith("table");
    }
    function rq(e) {
        return iq(e).startsWith("pre");
    }
    function oq(e) {
        return "element" === e.type && !e.hasExplicitNamespace && ![
            "html",
            "svg"
        ].includes(e.namespace);
    }
    function iq(e) {
        return "element" === e.type && (!e.namespace || oq(e)) && _W[e.name] || MW;
    }
    function uq(e) {
        let t = Number.POSITIVE_INFINITY;
        for (const n of e.split("\n")){
            if (0 === n.length) continue;
            if (!$W.has(n[0])) return 0;
            const e = zW(n).length;
            n.length !== e && e < t && (t = e);
        }
        return t === Number.POSITIVE_INFINITY ? 0 : t;
    }
    function sq(e383) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : uq(e383);
        return 0 === t ? e383 : e383.split("\n").map((e)=>e.slice(t)
        ).join("\n");
    }
    const aq = new Set([
        "template",
        "style",
        "script"
    ]);
    function cq(e, t) {
        return lq(e, t) && !aq.has(e.fullName);
    }
    function lq(e, t) {
        return "vue" === t.parser && "element" === e.type && "root" === e.parent.type && "html" !== e.fullName.toLowerCase();
    }
    function pq(e, t) {
        return lq(e, t) && (cq(e, t) || e.attrMap.lang && "html" !== e.attrMap.lang);
    }
    var fq = {
        HTML_ELEMENT_ATTRIBUTES: VW,
        HTML_TAGS: RW,
        htmlTrim: (e384)=>((e)=>e.replace(/^[\t\n\f\r ]+/, "")
            )(WW(e384))
        ,
        htmlTrimPreserveIndentation: qW,
        hasHtmlWhitespace: (e)=>/[\t\n\f\r ]/.test(e)
        ,
        getLeadingAndTrailingHtmlWhitespace: (e)=>{
            const [, t, n, r] = e.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return {
                leadingWhitespace: t,
                trailingWhitespace: r,
                text: n
            };
        },
        canHaveInterpolation: function(e) {
            return e.children && !HW(e);
        },
        countChars: function(e, t) {
            let n = 0;
            for(let r = 0; r < e.length; r++)e[r] === t && n++;
            return n;
        },
        countParents: function(e, t) {
            let n = 0;
            for(let r = e.stack.length - 1; r >= 0; r--){
                const o = e.stack[r];
                o && "object" == typeof o && !Array.isArray(o) && t(o) && n++;
            }
            return n;
        },
        dedentString: sq,
        forceBreakChildren: XW,
        forceBreakContent: function(e385) {
            return XW(e385) || "element" === e385.type && e385.children.length > 0 && ([
                "body",
                "script",
                "style"
            ].includes(e385.name) || e385.children.some((e386)=>(function(e387) {
                    return e387.children && e387.children.some((e)=>"text" !== e.type
                    );
                })(e386)
            )) || e385.firstChild && e385.firstChild === e385.lastChild && "text" !== e385.firstChild.type && QW(e385.firstChild) && (!e385.lastChild.isTrailingSpaceSensitive || ZW(e385.lastChild));
        },
        forceNextEmptyLine: function(e) {
            return BW(e) || e.next && e.sourceSpan.end && e.sourceSpan.end.line + 1 < e.next.sourceSpan.start.line;
        },
        getLastDescendant: function e(t) {
            return t.lastChild ? e(t.lastChild) : t;
        },
        getNodeCssStyleDisplay: function(e388, t184) {
            if (e388.prev && "comment" === e388.prev.type) {
                const t = e388.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                if (t) return t[1];
            }
            let n103 = !1;
            if ("element" === e388.type && "svg" === e388.namespace) {
                if (!function(e, t) {
                    let n = e;
                    for(; n;){
                        if (t(n)) return !0;
                        n = n.parent;
                    }
                    return !1;
                }(e388, (e)=>"svg:foreignObject" === e.fullName
                )) return "svg" === e388.name ? "inline-block" : "block";
                n103 = !0;
            }
            switch(t184.htmlWhitespaceSensitivity){
                case "strict":
                    return "inline";
                case "ignore":
                    return "block";
                default:
                    return "vue" === t184.parser && e388.parent && "root" === e388.parent.type ? "block" : "element" === e388.type && (!e388.namespace || n103 || oq(e388)) && LW[e388.name] || jW;
            }
        },
        getNodeCssStyleWhiteSpace: iq,
        hasPrettierIgnore: function(e389) {
            return "attribute" !== e389.type && !!e389.parent && "number" == typeof e389.index && 0 !== e389.index && (function(e) {
                return "comment" === e.type && "prettier-ignore" === e.value.trim();
            })(e389.parent.children[e389.index - 1]);
        },
        inferScriptParser: function(e390, t185) {
            return "script" !== e390.name || e390.attrMap.src ? "style" === e390.name ? (function(e) {
                const { lang: t  } = e.attrMap;
                return t && "postcss" !== t && "css" !== t ? "scss" === t ? "scss" : "less" === t ? "less" : void 0 : "css";
            })(e390) : t185 && pq(e390, t185) ? tq(e390) || !("src" in e390.attrMap) && TW(e390.attrMap.lang, t185) : void 0 : e390.attrMap.lang || e390.attrMap.type ? tq(e390) : "babel";
        },
        isVueCustomBlock: cq,
        isVueNonHtmlBlock: pq,
        isVueSlotAttribute: function(e) {
            const t = e.fullName;
            return "#" === t.charAt(0) || "slot-scope" === t || "v-slot" === t || t.startsWith("v-slot:");
        },
        isVueSfcBindingsAttribute: function(e, t) {
            const n = e.parent;
            if (!lq(n, t)) return !1;
            const r = n.fullName, o = e.fullName;
            return "script" === r && "setup" === o || "style" === r && "vars" === o;
        },
        isDanglingSpaceSensitiveNode: function(e) {
            var t;
            return !(t = e.cssDisplay, nq(t) || "inline-block" === t || HW(e));
        },
        isIndentationSensitiveNode: JW,
        isLeadingSpaceSensitiveNode: function(e391, t) {
            const n104 = function() {
                if (BW(e391)) return !1;
                if (("text" === e391.type || "interpolation" === e391.type) && e391.prev && ("text" === e391.prev.type || "interpolation" === e391.prev.type)) return !0;
                if (!e391.parent || "none" === e391.parent.cssDisplay) return !1;
                if (rq(e391.parent)) return !0;
                if (!e391.prev && ("root" === e391.parent.type || rq(e391) && e391.parent || HW(e391.parent) || cq(e391.parent, t) || (n = e391.parent.cssDisplay, nq(n) || "inline-block" === n))) return !1;
                var n;
                if (e391.prev && !function(e) {
                    return !nq(e);
                }(e391.prev.cssDisplay)) return !1;
                return !0;
            }();
            return n104 && !e391.prev && e391.parent && e391.parent.tagDefinition && e391.parent.tagDefinition.ignoreFirstLf ? "interpolation" === e391.type : n104;
        },
        isPreLikeNode: rq,
        isScriptLikeTag: HW,
        isTextLikeNode: function(e) {
            return "text" === e.type || "comment" === e.type;
        },
        isTrailingSpaceSensitiveNode: function(e392, t) {
            var n;
            return !BW(e392) && (!("text" !== e392.type && "interpolation" !== e392.type || !e392.next || "text" !== e392.next.type && "interpolation" !== e392.next.type) || !(!e392.parent || "none" === e392.parent.cssDisplay) && (!!rq(e392.parent) || !(!e392.next && ("root" === e392.parent.type || rq(e392) && e392.parent || HW(e392.parent) || cq(e392.parent, t) || (n = e392.parent.cssDisplay, nq(n) || "inline-block" === n))) && !(e392.next && !function(e) {
                return !nq(e);
            }(e392.next.cssDisplay))));
        },
        isWhitespaceSensitiveNode: function(e) {
            return HW(e) || "interpolation" === e.type || JW(e);
        },
        isUnknownNamespace: oq,
        preferHardlineAsLeadingSpaces: function(e) {
            return eq(e) || e.prev && YW(e.prev) || KW(e);
        },
        preferHardlineAsTrailingSpaces: YW,
        shouldPreserveContent: function(e393, t) {
            return !("ieConditionalComment" !== e393.type || !e393.lastChild || e393.lastChild.isSelfClosing || e393.lastChild.endSourceSpan) || "ieConditionalComment" === e393.type && !e393.complete || !(!rq(e393) || !e393.children.some((e)=>"text" !== e.type && "interpolation" !== e.type
            )) || !(!pq(e393, t) || HW(e393) || "interpolation" === e393.type);
        },
        unescapeQuoteEntities: function(e) {
            return e.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
        },
        getTextValueParts: function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.value;
            return e.parent.isWhitespaceSensitive ? e.parent.isIndentationSensitive ? IW(t) : IW(sq(qW(t)), kW) : OW(PW(NW, UW(t)));
        }
    }, dq = {
    }, hq = {
    };
    !function(e) {
        function t186(t) {
            return e.$0 <= t && t <= e.$9;
        }
        /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */ Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96, e.isWhitespace = function(t) {
            return t >= e.$TAB && t <= e.$SPACE || t == e.$NBSP;
        }, e.isDigit = t186, e.isAsciiLetter = function(t) {
            return t >= e.$a && t <= e.$z || t >= e.$A && t <= e.$Z;
        }, e.isAsciiHexDigit = function(n) {
            return n >= e.$a && n <= e.$f || n >= e.$A && n <= e.$F || t186(n);
        }, e.isNewLine = function(t) {
            return t === e.$LF || t === e.$CR;
        }, e.isOctalDigit = function(t) {
            return e.$0 <= t && t <= e.$7;
        };
    }(hq);
    var gq = {
    }, mq = {
    };
    /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ Object.defineProperty(mq, "__esModule", {
        value: !0
    });
    class yq {
        constructor(e, t, n){
            this.filePath = e, this.name = t, this.members = n;
        }
        assertNoMembers() {
            if (this.members.length) throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
        }
    }
    mq.StaticSymbol = yq;
    mq.StaticSymbolCache = class {
        constructor(){
            this.cache = new Map;
        }
        get(e, t, n) {
            const r = (n = n || []).length ? ".".concat(n.join(".")) : "", o = '"'.concat(e, '".').concat(t).concat(r);
            let i = this.cache.get(o);
            return i || (i = new yq(e, t, n), this.cache.set(o, i)), i;
        }
    };
    var Dq = {
    };
    /**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */ Object.defineProperty(Dq, "__esModule", {
        value: !0
    });
    const Eq = /-+([a-z0-9])/g;
    function Cq(e, t, n) {
        const r = e.indexOf(t);
        return -1 == r ? n : [
            e.slice(0, r).trim(),
            e.slice(r + 1).trim()
        ];
    }
    function bq(e394, t, n) {
        return Array.isArray(e394) ? t.visitArray(e394, n) : (function(e) {
            return "object" == typeof e && null !== e && Object.getPrototypeOf(e) === Fq;
        })(e394) ? t.visitStringMap(e394, n) : null == e394 || "string" == typeof e394 || "number" == typeof e394 || "boolean" == typeof e394 ? t.visitPrimitive(e394, n) : t.visitOther(e394, n);
    }
    Dq.dashCaseToCamelCase = function(e395) {
        return e395.replace(Eq, function() {
            for(var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n];
            return t[1].toUpperCase();
        });
    }, Dq.splitAtColon = function(e, t) {
        return Cq(e, ":", t);
    }, Dq.splitAtPeriod = function(e, t) {
        return Cq(e, ".", t);
    }, Dq.visitValue = bq, Dq.isDefined = function(e) {
        return null != e;
    }, Dq.noUndefined = function(e) {
        return void 0 === e ? null : e;
    };
    Dq.ValueTransformer = class {
        visitArray(e396, t) {
            return e396.map((e)=>bq(e, this, t)
            );
        }
        visitStringMap(e, t) {
            const n = {
            };
            return Object.keys(e).forEach((r)=>{
                n[r] = bq(e[r], this, t);
            }), n;
        }
        visitPrimitive(e, t) {
            return e;
        }
        visitOther(e, t) {
            return e;
        }
    }, Dq.SyncAsync = {
        assertSync: (e)=>{
            if (xq(e)) throw new Error("Illegal state: value cannot be a promise");
            return e;
        },
        then: (e, t)=>xq(e) ? e.then(t) : t(e)
        ,
        all: (e)=>e.some(xq) ? Promise.all(e) : e
    }, Dq.error = function(e) {
        throw new Error("Internal Error: ".concat(e));
    }, Dq.syntaxError = function(e, t) {
        const n = Error(e);
        return n[vq] = !0, t && (n[Aq] = t), n;
    };
    const vq = "ngSyntaxError", Aq = "ngParseErrors";
    Dq.isSyntaxError = function(e) {
        return e[vq];
    }, Dq.getParseErrors = function(e) {
        return e[Aq] || [];
    }, Dq.escapeRegExp = function(e) {
        return e.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    };
    const Fq = Object.getPrototypeOf({
    });
    function xq(e) {
        return !!e && "function" == typeof e.then;
    }
    Dq.utf8Encode = function(e) {
        let t = "";
        for(let n = 0; n < e.length; n++){
            let r = e.charCodeAt(n);
            if (r >= 55296 && r <= 56319 && e.length > n + 1) {
                const t = e.charCodeAt(n + 1);
                t >= 56320 && t <= 57343 && (n++, r = (r - 55296 << 10) + t - 56320 + 65536);
            }
            r <= 127 ? t += String.fromCharCode(r) : r <= 2047 ? t += String.fromCharCode(r >> 6 & 31 | 192, 63 & r | 128) : r <= 65535 ? t += String.fromCharCode(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128) : r <= 2097151 && (t += String.fromCharCode(r >> 18 & 7 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128));
        }
        return t;
    }, Dq.stringify = function e(t) {
        if ("string" == typeof t) return t;
        if (t instanceof Array) return "[" + t.map(e).join(", ") + "]";
        if (null == t) return "" + t;
        if (t.overriddenName) return "".concat(t.overriddenName);
        if (t.name) return "".concat(t.name);
        if (!t.toString) return "object";
        const n = t.toString();
        if (null == n) return "" + n;
        const r = n.indexOf("\n");
        return -1 === r ? n : n.substring(0, r);
    }, Dq.resolveForwardRef = function(e) {
        return "function" == typeof e && e.hasOwnProperty("__forward_ref__") ? e() : e;
    }, Dq.isPromise = xq;
    Dq.Version = class {
        constructor(e){
            this.full = e;
            const t = e.split(".");
            this.major = t[0], this.minor = t[1], this.patch = t.slice(2).join(".");
        }
    };
    const Sq = "undefined" != typeof window && window, wq = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, Tq = void 0 !== e7 && e7 || Sq || wq;
    Dq.global = Tq, (function(e397) {
        /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */ Object.defineProperty(e397, "__esModule", {
            value: !0
        });
        const t187 = mq, n105 = Dq, r78 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
        function o53(e) {
            return e.replace(/\W/g, "_");
        }
        e397.sanitizeIdentifier = o53;
        let i29 = 0;
        function u23(e) {
            if (!e || !e.reference) return null;
            const r = e.reference;
            if (r instanceof t187.StaticSymbol) return r.name;
            if (r.__anonymousType) return r.__anonymousType;
            let u = n105.stringify(r);
            return u.indexOf("(") >= 0 ? (u = "anonymous_".concat(i29++), r.__anonymousType = u) : u = o53(u), u;
        }
        var s17;
        e397.identifierName = u23, e397.identifierModuleUrl = function(e) {
            const r = e.reference;
            return r instanceof t187.StaticSymbol ? r.filePath : "./".concat(n105.stringify(r));
        }, e397.viewClassName = function(e, t) {
            return "View_".concat(u23({
                reference: e
            }), "_").concat(t);
        }, e397.rendererTypeName = function(e) {
            return "RenderType_".concat(u23({
                reference: e
            }));
        }, e397.hostViewClassName = function(e) {
            return "HostView_".concat(u23({
                reference: e
            }));
        }, e397.componentFactoryName = function(e) {
            return "".concat(u23({
                reference: e
            }), "NgFactory");
        }, (function(e) {
            e[e.Pipe = 0] = "Pipe", e[e.Directive = 1] = "Directive", e[e.NgModule = 2] = "NgModule", e[e.Injectable = 3] = "Injectable";
        })(s17 = e397.CompileSummaryKind || (e397.CompileSummaryKind = {
        })), e397.tokenName = function(e) {
            return null != e.value ? o53(e.value) : u23(e.identifier);
        }, e397.tokenReference = function(e) {
            return null != e.identifier ? e.identifier.reference : e.value;
        };
        e397.CompileStylesheetMetadata = class {
            constructor(){
                let { moduleUrl: e , styles: t , styleUrls: n  } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                };
                this.moduleUrl = e || null, this.styles = c6(t), this.styleUrls = c6(n);
            }
        };
        e397.CompileTemplateMetadata = class {
            constructor(e){
                let { encapsulation: t , template: n , templateUrl: r , htmlAst: o , styles: i , styleUrls: u , externalStylesheets: s , animations: a , ngContentSelectors: p , interpolation: f , isInline: d , preserveWhitespaces: h  } = e;
                if (this.encapsulation = t, this.template = n, this.templateUrl = r, this.htmlAst = o, this.styles = c6(i), this.styleUrls = c6(u), this.externalStylesheets = c6(s), this.animations = a ? l5(a) : [], this.ngContentSelectors = p || [], f && 2 != f.length) throw new Error("'interpolation' should have a start and an end symbol.");
                this.interpolation = f, this.isInline = d, this.preserveWhitespaces = h;
            }
            toSummary() {
                return {
                    ngContentSelectors: this.ngContentSelectors,
                    encapsulation: this.encapsulation,
                    styles: this.styles,
                    animations: this.animations
                };
            }
        };
        class a11 {
            static create(e398) {
                let { isHost: t188 , type: o , isComponent: i , selector: u , exportAs: s , changeDetection: c , inputs: l , outputs: p , host: f , providers: d , viewProviders: h , queries: g , guards: m , viewQueries: y , entryComponents: D , template: E , componentViewType: C , rendererType: b , componentFactory: v  } = e398;
                const A = {
                }, F = {
                }, x = {
                };
                null != f && Object.keys(f).forEach((e)=>{
                    const t = f[e], n = e.match(r78);
                    null === n ? x[e] = t : null != n[1] ? F[n[1]] = t : null != n[2] && (A[n[2]] = t);
                });
                const S = {
                };
                null != l && l.forEach((e)=>{
                    const t = n105.splitAtColon(e, [
                        e,
                        e
                    ]);
                    S[t[0]] = t[1];
                });
                const w = {
                };
                return null != p && p.forEach((e)=>{
                    const t = n105.splitAtColon(e, [
                        e,
                        e
                    ]);
                    w[t[0]] = t[1];
                }), new a11({
                    isHost: t188,
                    type: o,
                    isComponent: !!i,
                    selector: u,
                    exportAs: s,
                    changeDetection: c,
                    inputs: S,
                    outputs: w,
                    hostListeners: A,
                    hostProperties: F,
                    hostAttributes: x,
                    providers: d,
                    viewProviders: h,
                    queries: g,
                    guards: m,
                    viewQueries: y,
                    entryComponents: D,
                    template: E,
                    componentViewType: C,
                    rendererType: b,
                    componentFactory: v
                });
            }
            constructor(e){
                let { isHost: t , type: n , isComponent: r , selector: o , exportAs: i , changeDetection: u , inputs: s , outputs: a , hostListeners: l , hostProperties: p , hostAttributes: f , providers: d , viewProviders: h , queries: g , guards: m , viewQueries: y , entryComponents: D , template: E , componentViewType: C , rendererType: b , componentFactory: v  } = e;
                this.isHost = !!t, this.type = n, this.isComponent = r, this.selector = o, this.exportAs = i, this.changeDetection = u, this.inputs = s, this.outputs = a, this.hostListeners = l, this.hostProperties = p, this.hostAttributes = f, this.providers = c6(d), this.viewProviders = c6(h), this.queries = c6(g), this.guards = m, this.viewQueries = c6(y), this.entryComponents = c6(D), this.template = E, this.componentViewType = C, this.rendererType = b, this.componentFactory = v;
            }
            toSummary() {
                return {
                    summaryKind: s17.Directive,
                    type: this.type,
                    isComponent: this.isComponent,
                    selector: this.selector,
                    exportAs: this.exportAs,
                    inputs: this.inputs,
                    outputs: this.outputs,
                    hostListeners: this.hostListeners,
                    hostProperties: this.hostProperties,
                    hostAttributes: this.hostAttributes,
                    providers: this.providers,
                    viewProviders: this.viewProviders,
                    queries: this.queries,
                    guards: this.guards,
                    viewQueries: this.viewQueries,
                    entryComponents: this.entryComponents,
                    changeDetection: this.changeDetection,
                    template: this.template && this.template.toSummary(),
                    componentViewType: this.componentViewType,
                    rendererType: this.rendererType,
                    componentFactory: this.componentFactory
                };
            }
        }
        e397.CompileDirectiveMetadata = a11;
        e397.CompilePipeMetadata = class {
            constructor(e){
                let { type: t , name: n , pure: r  } = e;
                this.type = t, this.name = n, this.pure = !!r;
            }
            toSummary() {
                return {
                    summaryKind: s17.Pipe,
                    type: this.type,
                    name: this.name,
                    pure: this.pure
                };
            }
        };
        e397.CompileShallowModuleMetadata = class {
        };
        e397.CompileNgModuleMetadata = class {
            constructor(e){
                let { type: t , providers: n , declaredDirectives: r , exportedDirectives: o , declaredPipes: i , exportedPipes: u , entryComponents: s , bootstrapComponents: a , importedModules: l , exportedModules: p , schemas: f , transitiveModule: d , id: h  } = e;
                this.type = t || null, this.declaredDirectives = c6(r), this.exportedDirectives = c6(o), this.declaredPipes = c6(i), this.exportedPipes = c6(u), this.providers = c6(n), this.entryComponents = c6(s), this.bootstrapComponents = c6(a), this.importedModules = c6(l), this.exportedModules = c6(p), this.schemas = c6(f), this.id = h || null, this.transitiveModule = d || null;
            }
            toSummary() {
                const e = this.transitiveModule;
                return {
                    summaryKind: s17.NgModule,
                    type: this.type,
                    entryComponents: e.entryComponents,
                    providers: e.providers,
                    modules: e.modules,
                    exportedDirectives: e.exportedDirectives,
                    exportedPipes: e.exportedPipes
                };
            }
        };
        function c6(e) {
            return e || [];
        }
        e397.TransitiveCompileNgModuleMetadata = class {
            constructor(){
                this.directivesSet = new Set, this.directives = [], this.exportedDirectivesSet = new Set, this.exportedDirectives = [], this.pipesSet = new Set, this.pipes = [], this.exportedPipesSet = new Set, this.exportedPipes = [], this.modulesSet = new Set, this.modules = [], this.entryComponentsSet = new Set, this.entryComponents = [], this.providers = [];
            }
            addProvider(e, t) {
                this.providers.push({
                    provider: e,
                    module: t
                });
            }
            addDirective(e) {
                this.directivesSet.has(e.reference) || (this.directivesSet.add(e.reference), this.directives.push(e));
            }
            addExportedDirective(e) {
                this.exportedDirectivesSet.has(e.reference) || (this.exportedDirectivesSet.add(e.reference), this.exportedDirectives.push(e));
            }
            addPipe(e) {
                this.pipesSet.has(e.reference) || (this.pipesSet.add(e.reference), this.pipes.push(e));
            }
            addExportedPipe(e) {
                this.exportedPipesSet.has(e.reference) || (this.exportedPipesSet.add(e.reference), this.exportedPipes.push(e));
            }
            addModule(e) {
                this.modulesSet.has(e.reference) || (this.modulesSet.add(e.reference), this.modules.push(e));
            }
            addEntryComponent(e) {
                this.entryComponentsSet.has(e.componentType) || (this.entryComponentsSet.add(e.componentType), this.entryComponents.push(e));
            }
        };
        function l5(e399) {
            return e399.reduce((e, t)=>{
                const n = Array.isArray(t) ? l5(t) : t;
                return e.concat(n);
            }, []);
        }
        function p6(e) {
            return e.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
        }
        e397.ProviderMeta = class {
            constructor(e, t){
                let { useClass: n , useValue: r , useExisting: o , useFactory: i , deps: u , multi: s  } = t;
                this.token = e, this.useClass = n || null, this.useValue = r, this.useExisting = o, this.useFactory = i || null, this.dependencies = u || null, this.multi = !!s;
            }
        }, e397.flatten = l5, e397.templateSourceUrl = function(e, n, r) {
            let o;
            return o = r.isInline ? n.type.reference instanceof t187.StaticSymbol ? "".concat(n.type.reference.filePath, ".").concat(n.type.reference.name, ".html") : "".concat(u23(e), "/").concat(u23(n.type), ".html") : r.templateUrl, n.type.reference instanceof t187.StaticSymbol ? o : p6(o);
        }, e397.sharedStylesheetJitUrl = function(e, t) {
            const n = e.moduleUrl.split(/\/\\/g), r = n[n.length - 1];
            return p6("css/".concat(t).concat(r, ".ngstyle.js"));
        }, e397.ngModuleJitUrl = function(e) {
            return p6("".concat(u23(e.type), "/module.ngfactory.js"));
        }, e397.templateJitUrl = function(e, t) {
            return p6("".concat(u23(e), "/").concat(u23(t.type), ".ngfactory.js"));
        };
    })(gq), (function(e400) {
        Object.defineProperty(e400, "__esModule", {
            value: !0
        });
        /**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */ const t189 = hq, n106 = gq;
        class r79 {
            constructor(e, t, n, r){
                this.file = e, this.offset = t, this.line = n, this.col = r;
            }
            toString() {
                return null != this.offset ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
            }
            moveBy(e) {
                const n = this.file.content, o = n.length;
                let i = this.offset, u = this.line, s = this.col;
                for(; i > 0 && e < 0;){
                    i--, e++;
                    if (n.charCodeAt(i) == t189.$LF) {
                        u--;
                        const e = n.substr(0, i - 1).lastIndexOf(String.fromCharCode(t189.$LF));
                        s = e > 0 ? i - e : i;
                    } else s--;
                }
                for(; i < o && e > 0;){
                    const r = n.charCodeAt(i);
                    i++, e--, r == t189.$LF ? (u++, s = 0) : s++;
                }
                return new r79(this.file, i, u, s);
            }
            getContext(e, t) {
                const n = this.file.content;
                let r = this.offset;
                if (null != r) {
                    r > n.length - 1 && (r = n.length - 1);
                    let o = r, i = 0, u = 0;
                    for(; i < e && r > 0 && (r--, i++, "\n" != n[r] || ++u != t););
                    for(i = 0, u = 0; i < e && o < n.length - 1 && (o++, i++, "\n" != n[o] || ++u != t););
                    return {
                        before: n.substring(r, this.offset),
                        after: n.substring(this.offset, o + 1)
                    };
                }
                return null;
            }
        }
        e400.ParseLocation = r79;
        class o54 {
            constructor(e, t){
                this.content = e, this.url = t;
            }
        }
        e400.ParseSourceFile = o54;
        class i30 {
            constructor(e, t){
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                this.start = e, this.end = t, this.details = n;
            }
            toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
        }
        var u24;
        e400.ParseSourceSpan = i30, e400.EMPTY_PARSE_LOCATION = new r79(new o54("", ""), 0, 0, 0), e400.EMPTY_SOURCE_SPAN = new i30(e400.EMPTY_PARSE_LOCATION, e400.EMPTY_PARSE_LOCATION), (function(e) {
            e[e.WARNING = 0] = "WARNING", e[e.ERROR = 1] = "ERROR";
        })(u24 = e400.ParseErrorLevel || (e400.ParseErrorLevel = {
        }));
        e400.ParseError = class {
            constructor(e, t){
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : u24.ERROR;
                this.span = e, this.msg = t, this.level = n;
            }
            contextualMessage() {
                const e = this.span.start.getContext(100, 3);
                return e ? "".concat(this.msg, ' ("').concat(e.before, "[").concat(u24[this.level], " ->]").concat(e.after, '")') : this.msg;
            }
            toString() {
                const e = this.span.details ? ", ".concat(this.span.details) : "";
                return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(e);
            }
        }, e400.typeSourceSpan = function(e, t) {
            const u = n106.identifierModuleUrl(t), s = null != u ? "in ".concat(e, " ").concat(n106.identifierName(t), " in ").concat(u) : "in ".concat(e, " ").concat(n106.identifierName(t)), a = new o54("", s);
            return new i30(new r79(a, -1, -1, -1), new r79(a, -1, -1, -1));
        }, e400.r3JitTypeSourceSpan = function(e, t, n) {
            const u = "in ".concat(e, " ").concat(t, " in ").concat(n), s = new o54("", u);
            return new i30(new r79(s, -1, -1, -1), new r79(s, -1, -1, -1));
        };
    })(dq);
    const { ParseSourceSpan: Bq  } = dq, Nq = au, { htmlTrim: kq , getLeadingAndTrailingHtmlWhitespace: Pq , hasHtmlWhitespace: Oq , canHaveInterpolation: Iq , getNodeCssStyleDisplay: Lq , isDanglingSpaceSensitiveNode: jq , isIndentationSensitiveNode: _q , isLeadingSpaceSensitiveNode: Mq , isTrailingSpaceSensitiveNode: Rq , isWhitespaceSensitiveNode: Vq  } = fq, $q = [
        function(e401) {
            e401.walk((e)=>{
                if ("element" === e.type && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && "text" === e.children[0].type && "\n" === e.children[0].value[0]) {
                    const [t, ...n] = e.children;
                    e.setChildren(1 === t.value.length ? n : [
                        t.clone({
                            value: t.value.slice(1)
                        }),
                        ...n
                    ]);
                }
            });
        },
        function(e402) {
            const t190 = (e)=>"element" === e.type && e.prev && "ieConditionalStartComment" === e.prev.type && e.prev.sourceSpan.end.offset === e.startSourceSpan.start.offset && e.firstChild && "ieConditionalEndComment" === e.firstChild.type && e.firstChild.sourceSpan.start.offset === e.startSourceSpan.end.offset
            ;
            e402.walk((e)=>{
                if (e.children) {
                    const n = e.children.map(t190);
                    if (n.some(Boolean)) {
                        const t = [];
                        for(let r = 0; r < e.children.length; r++){
                            const o = e.children[r];
                            if (!n[r + 1]) {
                                if (n[r]) {
                                    const e = o.prev, n = o.firstChild, r = new Bq(e.sourceSpan.start, n.sourceSpan.end), i = new Bq(r.start, o.sourceSpan.end);
                                    t.push(o.clone({
                                        condition: e.condition,
                                        sourceSpan: i,
                                        startSourceSpan: r,
                                        children: o.children.slice(1)
                                    }));
                                } else t.push(o);
                            }
                        }
                        e.setChildren(t);
                    }
                }
            });
        },
        function(e403) {
            return (function(e404, t191, n) {
                e404.walk((e)=>{
                    if (e.children) {
                        const r = e.children.map(t191);
                        if (r.some(Boolean)) {
                            const t = [];
                            for(let o = 0; o < e.children.length; o++){
                                const i = e.children[o];
                                if ("text" !== i.type && !r[o]) {
                                    t.push(i);
                                    continue;
                                }
                                const u = "text" === i.type ? i : i.clone({
                                    type: "text",
                                    value: n(i)
                                });
                                if (0 === t.length || "text" !== Nq(t).type) {
                                    t.push(u);
                                    continue;
                                }
                                const s = t.pop();
                                t.push(s.clone({
                                    value: s.value + u.value,
                                    sourceSpan: new Bq(s.sourceSpan.start, u.sourceSpan.end)
                                }));
                            }
                            e.setChildren(t);
                        }
                    }
                });
            })(e403, (e)=>"cdata" === e.type
            , (e)=>"<![CDATA[".concat(e.value, "]]>")
            );
        },
        function(e405, t192) {
            if ("html" === t192.parser) return;
            const n = /{{(.+?)}}/s;
            e405.walk((e)=>{
                if (!Iq(e)) return;
                const t = [];
                for (const r of e.children){
                    if ("text" !== r.type) {
                        t.push(r);
                        continue;
                    }
                    let e = r.sourceSpan.start, o = null;
                    const i = r.value.split(n);
                    for(let n107 = 0; n107 < i.length; n107++, e = o){
                        const r = i[n107];
                        n107 % 2 != 0 ? (o = e.moveBy(r.length + 4), t.push({
                            type: "interpolation",
                            sourceSpan: new Bq(e, o),
                            children: 0 === r.length ? [] : [
                                {
                                    type: "text",
                                    value: r,
                                    sourceSpan: new Bq(e.moveBy(2), o.moveBy(-2))
                                }
                            ]
                        })) : (o = e.moveBy(r.length), r.length > 0 && t.push({
                            type: "text",
                            value: r,
                            sourceSpan: new Bq(e, o)
                        }));
                    }
                }
                e.setChildren(t);
            });
        },
        function(e406) {
            e406.walk((e407)=>{
                if (!e407.children) return;
                if (0 === e407.children.length || 1 === e407.children.length && "text" === e407.children[0].type && 0 === kq(e407.children[0].value).length) return e407.hasDanglingSpaces = e407.children.length > 0, void (e407.children = []);
                const t = Vq(e407), n109 = _q(e407);
                e407.setChildren(e407.children.flatMap((e)=>{
                    if ("text" !== e.type || t) return e;
                    const n = [], { leadingWhitespace: r , text: o , trailingWhitespace: i  } = Pq(e.value);
                    return r && n.push(Wq), o && n.push({
                        type: "text",
                        value: o,
                        sourceSpan: new Bq(e.sourceSpan.start.moveBy(r.length), e.sourceSpan.end.moveBy(-i.length))
                    }), i && n.push(Wq), n;
                }).map((e, t, n)=>{
                    if (e !== Wq) return Object.assign(Object.assign({
                    }, e), {
                    }, {
                        hasLeadingSpaces: n[t - 1] === Wq,
                        hasTrailingSpaces: n[t + 1] === Wq
                    });
                }).filter(Boolean)), e407.isWhitespaceSensitive = t, e407.isIndentationSensitive = n109;
            });
        },
        function(e408, t) {
            e408.walk((e)=>Object.assign(e, {
                    cssDisplay: Lq(e, t)
                })
            );
        },
        function(e409) {
            e409.walk((e)=>Object.assign(e, {
                    isSelfClosing: !e.children || "element" === e.type && (e.tagDefinition.isVoid || e.startSourceSpan === e.endSourceSpan)
                })
            );
        },
        function(e410, t) {
            e410.walk((e)=>"element" !== e.type ? e : Object.assign(e, {
                    hasHtmComponentClosingTag: e.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t.originalText.slice(e.endSourceSpan.start.offset, e.endSourceSpan.end.offset))
                })
            );
        },
        function(e411, t193) {
            e411.walk((e412)=>{
                e412.children && (0 !== e412.children.length ? e412.setChildren(e412.children.map((e)=>Object.assign(Object.assign({
                    }, e), {
                    }, {
                        isLeadingSpaceSensitive: Mq(e, t193),
                        isTrailingSpaceSensitive: Rq(e, t193)
                    })
                ).map((e, t, n)=>Object.assign(Object.assign({
                    }, e), {
                    }, {
                        isLeadingSpaceSensitive: (0 === t || n[t - 1].isTrailingSpaceSensitive) && e.isLeadingSpaceSensitive,
                        isTrailingSpaceSensitive: (t === n.length - 1 || n[t + 1].isLeadingSpaceSensitive) && e.isTrailingSpaceSensitive
                    })
                )) : e412.isDanglingSpaceSensitive = jq(e412));
            });
        },
        function(e413) {
            const t194 = (e)=>"element" === e.type && 0 === e.attrs.length && 1 === e.children.length && "text" === e.firstChild.type && !Oq(e.children[0].value) && !e.firstChild.hasLeadingSpaces && !e.firstChild.hasTrailingSpaces && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces && e.prev && "text" === e.prev.type && e.next && "text" === e.next.type
            ;
            e413.walk((e)=>{
                if (e.children) {
                    const n = e.children.map(t194);
                    if (n.some(Boolean)) {
                        const t = [];
                        for(let r = 0; r < e.children.length; r++){
                            const o = e.children[r];
                            if (n[r]) {
                                const n = t.pop(), i = e.children[++r], { isTrailingSpaceSensitive: u , hasTrailingSpaces: s  } = i;
                                t.push(n.clone({
                                    value: n.value + "<".concat(o.rawName, ">") + o.firstChild.value + "</".concat(o.rawName, ">") + i.value,
                                    sourceSpan: new Bq(n.sourceSpan.start, i.sourceSpan.end),
                                    isTrailingSpaceSensitive: u,
                                    hasTrailingSpaces: s
                                }));
                            } else t.push(o);
                        }
                        e.setChildren(t);
                    }
                }
            });
        }
    ];
    const Wq = {
        type: "whitespace"
    };
    var qq = function(e415, t) {
        const n = e415.map((e)=>e
        );
        for (const e414 of $q)e414(n, t);
        return n;
    };
    var Uq = {
        hasPragma: function(e) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e);
        },
        insertPragma: function(e) {
            return "\x3c!-- @format --\x3e\n\n" + e.replace(/^\s*\n/, "");
        }
    };
    var zq = {
        locStart: function(e) {
            return e.sourceSpan.start.offset;
        },
        locEnd: function(e) {
            return e.sourceSpan.end.offset;
        }
    };
    const Gq = Ty, { isNonEmptyArray: Hq  } = dc, { builders: { indent: Jq , join: Xq , line: Yq , softline: Kq  } , utils: { replaceTextEndOfLine: Qq  }  } = Zc, { locStart: Zq , locEnd: eU  } = zq, { isTextLikeNode: tU , getLastDescendant: nU , isPreLikeNode: rU , hasPrettierIgnore: oU , shouldPreserveContent: iU  } = fq;
    function uU(e, t) {
        return e.lastChild && gU(e.lastChild) ? "" : [
            aU(e, t),
            lU(e, t)
        ];
    }
    function sU(e, t) {
        return (e.next ? dU(e.next) : hU(e.parent)) ? "" : [
            pU(e, t),
            cU(e, t)
        ];
    }
    function aU(e, t) {
        return hU(e) ? pU(e.lastChild, t) : "";
    }
    function cU(e, t) {
        return gU(e) ? lU(e.parent, t) : mU(e) ? vU(e.next) : "";
    }
    function lU(e, t) {
        if (Gq(!e.isSelfClosing), fU(e, t)) return "";
        switch(e.type){
            case "ieConditionalComment":
                return "<!";
            case "element":
                if (e.hasHtmComponentClosingTag) return "<//";
            default:
                return "</".concat(e.rawName);
        }
    }
    function pU(e, t) {
        if (fU(e, t)) return "";
        switch(e.type){
            case "ieConditionalComment":
            case "ieConditionalEndComment":
                return "[endif]--\x3e";
            case "ieConditionalStartComment":
                return "]>\x3c!--\x3e";
            case "interpolation":
                return "}}";
            case "element":
                if (e.isSelfClosing) return "/>";
            default:
                return ">";
        }
    }
    function fU(e, t) {
        return !e.isSelfClosing && !e.endSourceSpan && (oU(e) || iU(e.parent, t));
    }
    function dU(e) {
        return e.prev && "docType" !== e.prev.type && !tU(e.prev) && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
    }
    function hU(e) {
        return e.lastChild && e.lastChild.isTrailingSpaceSensitive && !e.lastChild.hasTrailingSpaces && !tU(nU(e.lastChild)) && !rU(e);
    }
    function gU(e) {
        return !e.next && !e.hasTrailingSpaces && e.isTrailingSpaceSensitive && tU(nU(e));
    }
    function mU(e) {
        return e.next && !tU(e.next) && tU(e) && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces;
    }
    function yU(e) {
        return !e.prev && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
    }
    function DU(e416, t195, n) {
        const r80 = e416.getValue();
        if (!Hq(r80.attrs)) return r80.isSelfClosing ? " " : "";
        const o = r80.prev && "comment" === r80.prev.type && function(e) {
            const t = e.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return !!t && (!t[1] || t[1].split(/\s+/));
        }(r80.prev.value), i = "boolean" == typeof o ? ()=>o
         : Array.isArray(o) ? (e)=>o.includes(e.rawName)
         : ()=>!1
        , u = e416.map((e)=>{
            const r = e.getValue();
            return i(r) ? Qq(t195.originalText.slice(Zq(r), eU(r))) : n();
        }, "attrs"), s = "element" === r80.type && "script" === r80.fullName && 1 === r80.attrs.length && "src" === r80.attrs[0].fullName && 0 === r80.children.length, a = [
            Jq([
                s ? " " : Yq,
                Xq(Yq, u)
            ])
        ];
        return r80.firstChild && yU(r80.firstChild) || r80.isSelfClosing && hU(r80.parent) || s ? a.push(r80.isSelfClosing ? " " : "") : a.push(t195.bracketSameLine ? r80.isSelfClosing ? " " : "" : r80.isSelfClosing ? Yq : Kq), a;
    }
    function EU(e) {
        return e.firstChild && yU(e.firstChild) ? "" : AU(e);
    }
    function CU(e, t) {
        return e.prev && mU(e.prev) ? "" : [
            bU(e, t),
            vU(e)
        ];
    }
    function bU(e, t) {
        return yU(e) ? AU(e.parent) : dU(e) ? pU(e.prev, t) : "";
    }
    function vU(e) {
        switch(e.type){
            case "ieConditionalComment":
            case "ieConditionalStartComment":
                return "\x3c!--[if ".concat(e.condition);
            case "ieConditionalEndComment":
                return "\x3c!--<!";
            case "interpolation":
                return "{{";
            case "docType":
                return "<!DOCTYPE";
            case "element":
                if (e.condition) return "\x3c!--[if ".concat(e.condition, "]>\x3c!--\x3e<").concat(e.rawName);
            default:
                return "<".concat(e.rawName);
        }
    }
    function AU(e) {
        switch(Gq(!e.isSelfClosing), e.type){
            case "ieConditionalComment":
                return "]>";
            case "element":
                if (e.condition) return ">\x3c!--<![endif]--\x3e";
            default:
                return ">";
        }
    }
    var FU = {
        printClosingTag: function(e, t) {
            return [
                e.isSelfClosing ? "" : uU(e, t),
                sU(e, t)
            ];
        },
        printClosingTagStart: uU,
        printClosingTagStartMarker: lU,
        printClosingTagEndMarker: pU,
        printClosingTagSuffix: cU,
        printClosingTagEnd: sU,
        needsToBorrowLastChildClosingTagEndMarker: hU,
        needsToBorrowParentClosingTagStartMarker: gU,
        needsToBorrowPrevClosingTagEndMarker: dU,
        printOpeningTag: function(e, t, n) {
            const r = e.getValue();
            return [
                CU(r, t),
                DU(e, t, n),
                r.isSelfClosing ? "" : EU(r)
            ];
        },
        printOpeningTagStart: CU,
        printOpeningTagPrefix: bU,
        printOpeningTagStartMarker: vU,
        printOpeningTagEndMarker: AU,
        needsToBorrowNextOpeningTagStartMarker: mU,
        needsToBorrowParentOpeningTagEndMarker: yU
    }, xU = {
        exports: {
        }
    };
    !function(t196) {
        var n110, r81;
        n110 = e7, r81 = function() {
            return function(e417, t197) {
                var n111 = t197 && t197.logger || console;
                function r82(e) {
                    return " " === e || "\t" === e || "\n" === e || "\f" === e || "\r" === e;
                }
                function o55(t) {
                    var n, r = t.exec(e417.substring(y));
                    if (r) return n = r[0], y += n.length, n;
                }
                for(var i, u, s18, a12, c7, l6 = e417.length, p7 = /^[ \t\n\r\u000c]+/, f3 = /^[, \t\n\r\u000c]+/, d4 = /^[^ \t\n\r\u000c]+/, h3 = /[,]+$/, g = /^\d+$/, m = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y = 0, D = [];;){
                    if (o55(f3), y >= l6) return D;
                    i = o55(d4), u = [], "," === i.slice(-1) ? (i = i.replace(h3, ""), C()) : E();
                }
                function E() {
                    for(o55(p7), s18 = "", a12 = "in descriptor";;){
                        if (c7 = e417.charAt(y), "in descriptor" === a12) {
                            if (r82(c7)) s18 && (u.push(s18), s18 = "", a12 = "after descriptor");
                            else {
                                if ("," === c7) return y += 1, s18 && u.push(s18), void C();
                                if ("(" === c7) s18 += c7, a12 = "in parens";
                                else {
                                    if ("" === c7) return s18 && u.push(s18), void C();
                                    s18 += c7;
                                }
                            }
                        } else if ("in parens" === a12) {
                            if (")" === c7) s18 += c7, a12 = "in descriptor";
                            else {
                                if ("" === c7) return u.push(s18), void C();
                                s18 += c7;
                            }
                        } else if ("after descriptor" === a12) {
                            if (r82(c7)) ;
                            else {
                                if ("" === c7) return void C();
                                a12 = "in descriptor", y -= 1;
                            }
                        }
                        y += 1;
                    }
                }
                function C() {
                    var t, r, o, s, a, c, l, p, f, d = !1, h = {
                    };
                    for(s = 0; s < u.length; s++)c = (a = u[s])[a.length - 1], l = a.substring(0, a.length - 1), p = parseInt(l, 10), f = parseFloat(l), g.test(l) && "w" === c ? ((t || r) && (d = !0), 0 === p ? d = !0 : t = p) : m.test(l) && "x" === c ? ((t || r || o) && (d = !0), f < 0 ? d = !0 : r = f) : g.test(l) && "h" === c ? ((o || r) && (d = !0), 0 === p ? d = !0 : o = p) : d = !0;
                    d ? n111 && n111.error && n111.error("Invalid srcset descriptor found in '" + e417 + "' at '" + a + "'.") : (h.url = i, t && (h.w = t), r && (h.d = r), o && (h.h = o), D.push(h));
                }
            };
        }, t196.exports ? t196.exports = r81() : n110.parseSrcset = r81();
    }(xU);
    const SU = xU.exports, { builders: { ifBreak: wU , join: TU , line: BU  }  } = Zc;
    var NU = {
        printImgSrcset: function(e418) {
            const t198 = SU(e418, {
                logger: {
                    error (e) {
                        throw new Error(e);
                    }
                }
            }), n112 = t198.some((e)=>{
                let { w: t  } = e;
                return t;
            }), r83 = t198.some((e)=>{
                let { h: t  } = e;
                return t;
            });
            if (n112 + r83 + t198.some((e)=>{
                let { d: t  } = e;
                return t;
            }) > 1) throw new Error("Mixed descriptor in srcset is not supported");
            const o56 = n112 ? "w" : r83 ? "h" : "d", i = n112 ? "w" : r83 ? "h" : "x", u25 = (e)=>Math.max(...e)
            , s19 = t198.map((e)=>e.url
            ), a = u25(s19.map((e)=>e.length
            )), c = t198.map((e)=>e[o56]
            ).map((e)=>e ? e.toString() : ""
            ), l = c.map((e)=>{
                const t = e.indexOf(".");
                return -1 === t ? e.length : t;
            }), p = u25(l);
            return TU([
                ",",
                BU
            ], s19.map((e, t)=>{
                const n = [
                    e
                ], r = c[t];
                if (r) {
                    const o = a - e.length + 1, u = p - l[t], s = " ".repeat(o + u);
                    n.push(wU(s, " "), r + i);
                }
                return n;
            }));
        },
        printClassNames: function(e) {
            return e.trim().split(/\s+/).join(" ");
        }
    };
    const { builders: { group: kU  }  } = Zc;
    var PU = {
        isVueEventBindingExpression: function(e) {
            const t = e.trim();
            return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t);
        },
        printVueFor: function(e419, t199) {
            const { left: n113 , operator: r84 , right: o57  } = function(e) {
                const t = /(.*?)\s+(in|of)\s+(.*)/s, n = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r = /^\(|\)$/g, o = e.match(t);
                if (!o) return;
                const i = {
                };
                i.for = o[3].trim();
                const u = o[1].trim().replace(r, ""), s = u.match(n);
                s ? (i.alias = u.replace(n, ""), i.iterator1 = s[1].trim(), s[2] && (i.iterator2 = s[2].trim())) : i.alias = u;
                return {
                    left: "".concat([
                        i.alias,
                        i.iterator1,
                        i.iterator2
                    ].filter(Boolean).join(",")),
                    operator: o[2],
                    right: i.for
                };
            }(e419);
            return [
                kU(t199("function _(".concat(n113, ") {}"), {
                    parser: "babel",
                    __isVueForBindingLeft: !0
                })),
                " ",
                r84,
                " ",
                t199(o57, {
                    parser: "__js_expression"
                }, {
                    stripTrailingHardline: !0
                })
            ];
        },
        printVueBindings: function(e, t) {
            return t("function _(".concat(e, ") {}"), {
                parser: "babel",
                __isVueBindings: !0
            });
        }
    };
    const { needsToBorrowParentClosingTagStartMarker: OU , printClosingTagStartMarker: IU , needsToBorrowLastChildClosingTagEndMarker: LU , printClosingTagEndMarker: jU , needsToBorrowParentOpeningTagEndMarker: _U , printOpeningTagEndMarker: MU  } = FU;
    var RU = function(e, t) {
        let n = e.startSourceSpan.end.offset;
        e.firstChild && _U(e.firstChild) && (n -= MU(e).length);
        let r = e.endSourceSpan.start.offset;
        return e.lastChild && OU(e.lastChild) ? r += IU(e, t).length : LU(e) && (r -= jU(e.lastChild, t).length), t.originalText.slice(n, r);
    };
    const { builders: { breakParent: VU , group: $U , hardline: WU , indent: qU , line: UU , fill: zU , softline: GU  } , utils: { mapDoc: HU , replaceTextEndOfLine: JU  }  } = Zc, XU = Wj, { printClosingTag: YU , printClosingTagSuffix: KU , needsToBorrowPrevClosingTagEndMarker: QU , printOpeningTagPrefix: ZU , printOpeningTag: ez  } = FU, { printImgSrcset: tz , printClassNames: nz  } = NU, { printVueFor: rz , printVueBindings: oz , isVueEventBindingExpression: iz  } = PU, { isScriptLikeTag: uz , isVueNonHtmlBlock: sz , inferScriptParser: az , htmlTrimPreserveIndentation: cz , dedentString: lz , unescapeQuoteEntities: pz , isVueSlotAttribute: fz , isVueSfcBindingsAttribute: dz , getTextValueParts: hz  } = fq, gz = RU;
    function mz(e420, t200, n114) {
        const r = (t)=>new RegExp(t.join("|")).test(e420.fullName)
        , o = ()=>pz(e420.value)
        ;
        let i = !1;
        const u = (e, t)=>{
            const n = "NGRoot" === e.type ? "NGMicrosyntax" === e.node.type && 1 === e.node.body.length && "NGMicrosyntaxExpression" === e.node.body[0].type ? e.node.body[0].expression : e.node : "JsExpressionRoot" === e.type ? e.node : e;
            !n || "ObjectExpression" !== n.type && "ArrayExpression" !== n.type && ("__vue_expression" !== t.parser || "TemplateLiteral" !== n.type && "StringLiteral" !== n.type) || (i = !0);
        }, s = function(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            return $U([
                qU([
                    GU,
                    e
                ]),
                t ? GU : ""
            ]);
        }, a = (e421)=>i ? ((e)=>$U(e)
            )(e421) : s(e421)
        , c = (e, n)=>t200(e, Object.assign({
                __onHtmlBindingRoot: u,
                __embeddedInHtml: !0
            }, n), {
                stripTrailingHardline: !0
            })
        ;
        if ("srcset" === e420.fullName && ("img" === e420.parent.fullName || "source" === e420.parent.fullName)) return s(tz(o()));
        if ("class" === e420.fullName && !n114.parentParser) {
            const e = o();
            if (!e.includes("{{")) return nz(e);
        }
        if ("style" === e420.fullName && !n114.parentParser) {
            const e = o();
            if (!e.includes("{{")) return s(c(e, {
                parser: "css",
                __isHTMLStyleAttribute: !0
            }));
        }
        if ("vue" === n114.parser) {
            if ("v-for" === e420.fullName) return rz(o(), c);
            if (fz(e420) || dz(e420, n114)) return oz(o(), c);
            const t = [
                "^:",
                "^v-bind:"
            ], i = [
                "^v-"
            ];
            if (r([
                "^@",
                "^v-on:"
            ])) {
                const e = o();
                return a(c(e, {
                    parser: iz(e) ? "__js_expression" : "__vue_event_binding"
                }));
            }
            if (r(t)) return a(c(o(), {
                parser: "__vue_expression"
            }));
            if (r(i)) return a(c(o(), {
                parser: "__js_expression"
            }));
        }
        if ("angular" === n114.parser) {
            const t201 = (e, t)=>c(e, Object.assign(Object.assign({
                }, t), {
                }, {
                    trailingComma: "none"
                }))
            , n = [
                "^\\*"
            ], i = [
                "^\\[.+\\]$",
                "^bind(on)?-",
                "^ng-(if|show|hide|class|style)$"
            ], u = [
                "^i18n(-.+)?$"
            ];
            if (r([
                "^\\(.+\\)$",
                "^on-"
            ])) return a(t201(o(), {
                parser: "__ng_action"
            }));
            if (r(i)) return a(t201(o(), {
                parser: "__ng_binding"
            }));
            if (r(u)) {
                const t = o().trim();
                return s(zU(hz(e420, t)), !t.includes("@@"));
            }
            if (r(n)) return a(t201(o(), {
                parser: "__ng_directive"
            }));
            const l = /{{(.+?)}}/s, p = o();
            if (l.test(p)) {
                const e = [];
                for (const [n, r] of p.split(l).entries())if (n % 2 == 0) e.push(JU(r));
                else try {
                    e.push($U([
                        "{{",
                        qU([
                            UU,
                            t201(r, {
                                parser: "__ng_interpolation",
                                __isInHtmlInterpolation: !0
                            })
                        ]),
                        UU,
                        "}}"
                    ]));
                } catch  {
                    e.push("{{", JU(r), "}}");
                }
                return $U(e);
            }
        }
        return null;
    }
    var yz = function(e423, t203, n, r) {
        const o = e423.getValue();
        switch(o.type){
            case "element":
                if (uz(o) || "interpolation" === o.type) return;
                if (!o.isSelfClosing && sz(o, r)) {
                    const i = az(o, r);
                    if (!i) return;
                    const u = gz(o, r);
                    let s = /^\s*$/.test(u), a = "";
                    return s || (a = n(cz(u), {
                        parser: i,
                        __embeddedInHtml: !0
                    }, {
                        stripTrailingHardline: !0
                    }), s = "" === a), [
                        ZU(o, r),
                        $U(ez(e423, r, t203)),
                        s ? "" : WU,
                        a,
                        s ? "" : WU,
                        YU(o, r),
                        KU(o, r)
                    ];
                }
                break;
            case "text":
                if (uz(o.parent)) {
                    const e = az(o.parent);
                    if (e) {
                        const t = "markdown" === e ? lz(o.value.replace(/^[^\S\n]*?\n/, "")) : o.value, i = {
                            parser: e,
                            __embeddedInHtml: !0
                        };
                        if ("html" === r.parser && "babel" === e) {
                            let e = "script";
                            const { attrMap: t  } = o.parent;
                            t && ("module" === t.type || "text/babel" === t.type && "module" === t["data-type"]) && (e = "module"), i.__babelSourceType = e;
                        }
                        return [
                            VU,
                            ZU(o, r),
                            n(t, i, {
                                stripTrailingHardline: !0
                            }),
                            KU(o, r)
                        ];
                    }
                } else if ("interpolation" === o.parent.type) {
                    const e = {
                        __isInHtmlInterpolation: !0,
                        __embeddedInHtml: !0
                    };
                    return "angular" === r.parser ? (e.parser = "__ng_interpolation", e.trailingComma = "none") : "vue" === r.parser ? e.parser = "__vue_expression" : e.parser = "__js_expression", [
                        qU([
                            UU,
                            n(o.value, e, {
                                stripTrailingHardline: !0
                            })
                        ]),
                        o.parent.next && QU(o.parent.next) ? " " : UU
                    ];
                }
                break;
            case "attribute":
                {
                    if (!o.value) break;
                    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r.originalText.slice(o.valueSpan.start.offset, o.valueSpan.end.offset))) return [
                        o.rawName,
                        "=",
                        o.value
                    ];
                    if ("lwc" === r.parser) {
                        if (/^{.*}$/s.test(r.originalText.slice(o.valueSpan.start.offset, o.valueSpan.end.offset))) return [
                            o.rawName,
                            "=",
                            o.value
                        ];
                    }
                    const e422 = mz(o, (e, t)=>n(e, Object.assign({
                            __isInHtmlAttribute: !0,
                            __embeddedInHtml: !0
                        }, t), {
                            stripTrailingHardline: !0
                        })
                    , r);
                    if (e422) return [
                        o.rawName,
                        '="',
                        $U(HU(e422, (e)=>"string" == typeof e ? e.replace(/"/g, "&quot;") : e
                        )),
                        '"'
                    ];
                    break;
                }
            case "front-matter":
                return XU(o, n);
        }
    };
    const { builders: { breakParent: Dz , group: Ez , ifBreak: Cz , line: bz , softline: vz , hardline: Az  } , utils: { replaceTextEndOfLine: Fz  }  } = Zc, { locStart: xz , locEnd: Sz  } = zq, { forceBreakChildren: wz , forceNextEmptyLine: Tz , isTextLikeNode: Bz , hasPrettierIgnore: Nz , preferHardlineAsLeadingSpaces: kz  } = fq, { printOpeningTagPrefix: Pz , needsToBorrowNextOpeningTagStartMarker: Oz , printOpeningTagStartMarker: Iz , needsToBorrowPrevClosingTagEndMarker: Lz , printClosingTagEndMarker: jz , printClosingTagSuffix: _z , needsToBorrowParentClosingTagStartMarker: Mz  } = FU;
    function Rz(e, t, n) {
        const r = e.getValue();
        return Nz(r) ? [
            Pz(r, t),
            ...Fz(t.originalText.slice(xz(r) + (r.prev && Oz(r.prev) ? Iz(r).length : 0), Sz(r) - (r.next && Lz(r.next) ? jz(r, t).length : 0))),
            _z(r, t)
        ] : n();
    }
    function Vz(e, t) {
        return Bz(e) && Bz(t) ? e.isTrailingSpaceSensitive ? e.hasTrailingSpaces ? kz(t) ? Az : bz : "" : kz(t) ? Az : vz : Oz(e) && (Nz(t) || t.firstChild || t.isSelfClosing || "element" === t.type && t.attrs.length > 0) || "element" === e.type && e.isSelfClosing && Lz(t) ? "" : !t.isLeadingSpaceSensitive || kz(t) || Lz(t) && e.lastChild && Mz(e.lastChild) && e.lastChild.lastChild && Mz(e.lastChild.lastChild) ? Az : t.hasLeadingSpaces ? bz : vz;
    }
    var $z = {
        printChildren: function(e424, t, n) {
            const r85 = e424.getValue();
            if (wz(r85)) return [
                Dz,
                ...e424.map((e)=>{
                    const r = e.getValue(), o = r.prev ? Vz(r.prev, r) : "";
                    return [
                        o ? [
                            o,
                            Tz(r.prev) ? Az : ""
                        ] : "",
                        Rz(e, t, n)
                    ];
                }, "children")
            ];
            const o58 = r85.children.map(()=>Symbol("")
            );
            return e424.map((e, r)=>{
                const i = e.getValue();
                if (Bz(i)) {
                    if (i.prev && Bz(i.prev)) {
                        const r = Vz(i.prev, i);
                        if (r) return Tz(i.prev) ? [
                            Az,
                            Az,
                            Rz(e, t, n)
                        ] : [
                            r,
                            Rz(e, t, n)
                        ];
                    }
                    return Rz(e, t, n);
                }
                const u = [], s = [], a = [], c = [], l = i.prev ? Vz(i.prev, i) : "", p = i.next ? Vz(i, i.next) : "";
                return l && (Tz(i.prev) ? u.push(Az, Az) : l === Az ? u.push(Az) : Bz(i.prev) ? s.push(l) : s.push(Cz("", vz, {
                    groupId: o58[r - 1]
                }))), p && (Tz(i) ? Bz(i.next) && c.push(Az, Az) : p === Az ? Bz(i.next) && c.push(Az) : a.push(p)), [
                    ...u,
                    Ez([
                        ...s,
                        Ez([
                            Rz(e, t, n),
                            ...a
                        ], {
                            id: o58[r]
                        })
                    ]),
                    ...c
                ];
            }, "children");
        }
    };
    const { builders: { breakParent: Wz , dedentToRoot: qz , group: Uz , ifBreak: zz , indentIfBreak: Gz , indent: Hz , line: Jz , softline: Xz  } , utils: { replaceTextEndOfLine: Yz  }  } = Zc, Kz = RU, { shouldPreserveContent: Qz , isScriptLikeTag: Zz , isVueCustomBlock: eG , countParents: tG , forceBreakContent: nG  } = fq, { printOpeningTagPrefix: rG , printOpeningTag: oG , printClosingTagSuffix: iG , printClosingTag: uG , needsToBorrowPrevClosingTagEndMarker: sG , needsToBorrowLastChildClosingTagEndMarker: aG  } = FU, { printChildren: cG  } = $z;
    var lG = {
        printElement: function(e425, t, n) {
            const r = e425.getValue();
            if (Qz(r, t)) return [
                rG(r, t),
                Uz(oG(e425, t, n)),
                ...Yz(Kz(r, t)),
                ...uG(r, t),
                iG(r, t)
            ];
            const o59 = 1 === r.children.length && "interpolation" === r.firstChild.type && r.firstChild.isLeadingSpaceSensitive && !r.firstChild.hasLeadingSpaces && r.lastChild.isTrailingSpaceSensitive && !r.lastChild.hasTrailingSpaces, i = Symbol("element-attr-group-id"), u = (o)=>Uz([
                    Uz(oG(e425, t, n), {
                        id: i
                    }),
                    o,
                    uG(r, t)
                ])
            ;
            var s;
            return 0 === r.children.length ? u(r.hasDanglingSpaces && r.isDanglingSpaceSensitive ? Jz : "") : u([
                nG(r) ? Wz : "",
                (s = [
                    o59 ? zz(Xz, "", {
                        groupId: i
                    }) : r.firstChild.hasLeadingSpaces && r.firstChild.isLeadingSpaceSensitive ? Jz : "text" === r.firstChild.type && r.isWhitespaceSensitive && r.isIndentationSensitive ? qz(Xz) : Xz,
                    cG(e425, t, n)
                ], o59 ? Gz(s, {
                    groupId: i
                }) : !Zz(r) && !eG(r, t) || "root" !== r.parent.type || "vue" !== t.parser || t.vueIndentScriptAndStyle ? Hz(s) : s),
                (r.next ? sG(r.next) : aG(r.parent)) ? r.lastChild.hasTrailingSpaces && r.lastChild.isTrailingSpaceSensitive ? " " : "" : o59 ? zz(Xz, "", {
                    groupId: i
                }) : r.lastChild.hasTrailingSpaces && r.lastChild.isTrailingSpaceSensitive ? Jz : ("comment" === r.lastChild.type || "text" === r.lastChild.type && r.isWhitespaceSensitive && r.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(t.tabWidth * tG(e425, (e)=>e.parent && "root" !== e.parent.type
                ), "}$")).test(r.lastChild.value) ? "" : Xz
            ]);
        }
    };
    const { builders: { fill: pG , group: fG , hardline: dG , literalline: hG  } , utils: { cleanDoc: gG , getDocParts: mG , isConcat: yG , replaceTextEndOfLine: DG  }  } = Zc, EG = xW, { countChars: CG , unescapeQuoteEntities: bG , getTextValueParts: vG  } = fq, AG = qq, { insertPragma: FG  } = Uq, { locStart: xG , locEnd: SG  } = zq, wG = yz, { printClosingTagSuffix: TG , printClosingTagEnd: BG , printOpeningTagPrefix: NG , printOpeningTagStart: kG  } = FU, { printElement: PG  } = lG, { printChildren: OG  } = $z;
    var IG = {
        preprocess: AG,
        print: function(e, t, n) {
            const r = e.getValue();
            switch(r.type){
                case "front-matter":
                    return DG(r.raw);
                case "root":
                    return t.__onHtmlRoot && t.__onHtmlRoot(r), [
                        fG(OG(e, t, n)),
                        dG
                    ];
                case "element":
                case "ieConditionalComment":
                    return PG(e, t, n);
                case "ieConditionalStartComment":
                case "ieConditionalEndComment":
                    return [
                        kG(r),
                        BG(r)
                    ];
                case "interpolation":
                    return [
                        kG(r, t),
                        ...e.map(n, "children"),
                        BG(r, t)
                    ];
                case "text":
                    {
                        if ("interpolation" === r.parent.type) {
                            const e = /\n[^\S\n]*?$/, t = e.test(r.value), n = t ? r.value.replace(e, "") : r.value;
                            return [
                                ...DG(n),
                                t ? dG : ""
                            ];
                        }
                        const e = gG([
                            NG(r, t),
                            ...vG(r),
                            TG(r, t)
                        ]);
                        return yG(e) || "fill" === e.type ? pG(mG(e)) : e;
                    }
                case "docType":
                    return [
                        fG([
                            kG(r, t),
                            " ",
                            r.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")
                        ]),
                        BG(r, t)
                    ];
                case "comment":
                    return [
                        NG(r, t),
                        ...DG(t.originalText.slice(xG(r), SG(r)), hG),
                        TG(r, t)
                    ];
                case "attribute":
                    {
                        if (null === r.value) return r.rawName;
                        const e = bG(r.value), t = CG(e, "'") < CG(e, '"') ? "'" : '"';
                        return [
                            r.rawName,
                            "=",
                            t,
                            ...DG('"' === t ? e.replace(/"/g, "&quot;") : e.replace(/'/g, "&apos;")),
                            t
                        ];
                    }
                default:
                    throw new Error("Unexpected node type ".concat(r.type));
            }
        },
        insertPragma: FG,
        massageAstNode: EG,
        embed: wG
    };
    const LG = "HTML";
    var jG = {
        name: "HTML",
        type: "markup",
        tmScope: "text.html.basic",
        aceMode: "html",
        codemirrorMode: "htmlmixed",
        codemirrorMimeType: "text/html",
        color: "#e34c26",
        aliases: [
            "xhtml"
        ],
        extensions: [
            ".html",
            ".htm",
            ".html.hl",
            ".inc",
            ".xht",
            ".xhtml"
        ],
        languageId: 146
    }, _G = {
        name: "Vue",
        type: "markup",
        color: "#41b883",
        extensions: [
            ".vue"
        ],
        tmScope: "text.html.vue",
        aceMode: "html",
        languageId: 391
    };
    const MG = bE, RG = IG, VG = {
        bracketSameLine: bj.bracketSameLine,
        htmlWhitespaceSensitivity: {
            since: "1.15.0",
            category: LG,
            type: "choice",
            default: "css",
            description: "How to handle whitespaces in HTML.",
            choices: [
                {
                    value: "css",
                    description: "Respect the default value of CSS display property."
                },
                {
                    value: "strict",
                    description: "Whitespaces are considered sensitive."
                },
                {
                    value: "ignore",
                    description: "Whitespaces are considered insensitive."
                }
            ]
        },
        vueIndentScriptAndStyle: {
            since: "1.19.0",
            category: LG,
            type: "boolean",
            default: !1,
            description: "Indent script and style tags in Vue files."
        }
    }, $G = [
        MG(jG, ()=>({
                name: "Angular",
                since: "1.15.0",
                parsers: [
                    "angular"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: [
                    ".component.html"
                ],
                filenames: []
            })
        ),
        MG(jG, (e)=>({
                since: "1.15.0",
                parsers: [
                    "html"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: [
                    ...e.extensions,
                    ".mjml"
                ]
            })
        ),
        MG(jG, ()=>({
                name: "Lightning Web Components",
                since: "1.17.0",
                parsers: [
                    "lwc"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: [],
                filenames: []
            })
        ),
        MG(_G, ()=>({
                since: "1.10.0",
                parsers: [
                    "vue"
                ],
                vscodeLanguageIds: [
                    "vue"
                ]
            })
        )
    ];
    var WG = {
        languages: $G,
        printers: {
            html: RG
        },
        options: VG,
        parsers: undefined
    };
    var qG = {
        isPragma: function(e) {
            return /^\s*@(?:prettier|format)\s*$/.test(e);
        },
        hasPragma: function(e) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e);
        },
        insertPragma: function(e) {
            return "# @format\n\n".concat(e);
        }
    };
    var UG = {
        locStart: function(e) {
            return e.position.start.offset;
        },
        locEnd: function(e) {
            return e.position.end.offset;
        }
    };
    var zG = function(e, t, n, r) {
        if ("root" === e.getValue().type && r.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r.filepath)) return n(r.originalText, Object.assign(Object.assign({
        }, r), {
        }, {
            parser: "json"
        }));
    };
    const { getLast: GG , isNonEmptyArray: HG  } = dc;
    function JG(e, t) {
        return e && "string" == typeof e.type && (!t || t.includes(e.type));
    }
    function XG(e) {
        return "prettier-ignore" === e.value.trim();
    }
    function YG(e) {
        return e && HG(e.leadingComments);
    }
    function KG(e) {
        return e && HG(e.middleComments);
    }
    function QG(e) {
        return e && e.indicatorComment;
    }
    function ZG(e) {
        return e && e.trailingComment;
    }
    function eH(e) {
        return e && HG(e.endComments);
    }
    function tH(e) {
        const t = [];
        let n;
        for (const r of e.split(/( +)/))" " !== r ? " " === n ? t.push(r) : t.push((t.pop() || "") + r) : void 0 === n && t.unshift(""), n = r;
        return " " === n && t.push((t.pop() || "") + " "), "" === t[0] && (t.shift(), t.unshift(" " + (t.shift() || ""))), t;
    }
    var nH = {
        getLast: GG,
        getAncestorCount: function(e, t) {
            let n = 0;
            const r = e.stack.length - 1;
            for(let o = 0; o < r; o++){
                const r = e.stack[o];
                JG(r) && t(r) && n++;
            }
            return n;
        },
        isNode: JG,
        isEmptyNode: function(e426) {
            return !HG(e426.children) && !function(e) {
                return YG(e) || KG(e) || QG(e) || ZG(e) || eH(e);
            }(e426);
        },
        isInlineNode: function(e) {
            if (!e) return !0;
            switch(e.type){
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                case "alias":
                case "flowMapping":
                case "flowSequence":
                    return !0;
                default:
                    return !1;
            }
        },
        mapNode: function e(t, n, r86) {
            return n("children" in t ? Object.assign(Object.assign({
            }, t), {
            }, {
                children: t.children.map((r)=>e(r, n, t)
                )
            }) : t, r86);
        },
        defineShortcut: function(e, t, n) {
            Object.defineProperty(e, t, {
                get: n,
                enumerable: !1
            });
        },
        isNextLineEmpty: function(e, t) {
            let n = 0;
            const r = t.length;
            for(let o = e.position.end.offset - 1; o < r; o++){
                const e = t[o];
                if ("\n" === e && n++, 1 === n && /\S/.test(e)) return !1;
                if (2 === n) return !0;
            }
            return !1;
        },
        isLastDescendantNode: function(e) {
            switch(e.getValue().type){
                case "tag":
                case "anchor":
                case "comment":
                    return !1;
            }
            const t = e.stack.length;
            for(let n = 1; n < t; n++){
                const t = e.stack[n], r = e.stack[n - 1];
                if (Array.isArray(r) && "number" == typeof t && t !== r.length - 1) return !1;
            }
            return !0;
        },
        getBlockValueLineContents: function(e427, t204) {
            let { parentIndent: n115 , isLastDescendant: r , options: o  } = t204;
            const i = e427.position.start.line === e427.position.end.line ? "" : o.originalText.slice(e427.position.start.offset, e427.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u = null === e427.indent ? ((e)=>e ? e[1].length : Number.POSITIVE_INFINITY
            )(i.match(/^( *)\S/m)) : e427.indent - 1 + n115, s = i.split("\n").map((e)=>e.slice(u)
            );
            function a(t) {
                if ("keep" === e427.chomping) return 0 === GG(t).length ? t.slice(0, -1) : t;
                let n = 0;
                for(let e = t.length - 1; e >= 0 && 0 === t[e].length; e--)n++;
                return 0 === n ? t : n >= 2 && !r ? t.slice(0, -(n - 1)) : t.slice(0, -n);
            }
            return "preserve" === o.proseWrap || "blockLiteral" === e427.type ? a(s.map((e)=>0 === e.length ? [] : [
                    e
                ]
            )) : a(s.map((e)=>0 === e.length ? [] : tH(e)
            ).reduce((e, t, n)=>0 !== n && s[n - 1].length > 0 && t.length > 0 && !/^\s/.test(t[0]) && !/^\s|\s$/.test(GG(e)) ? [
                    ...e.slice(0, -1),
                    [
                        ...GG(e),
                        ...t
                    ]
                ] : [
                    ...e,
                    t
                ]
            , []).map((e428)=>e428.reduce((e, t)=>e.length > 0 && /\s$/.test(GG(e)) ? [
                        ...e.slice(0, -1),
                        GG(e) + " " + t
                    ] : [
                        ...e,
                        t
                    ]
                , [])
            ).map((e)=>"never" === o.proseWrap ? [
                    e.join(" ")
                ] : e
            ));
        },
        getFlowScalarLineContents: function(e429, t205, n116) {
            const r = t205.split("\n").map((e, t, n)=>0 === t && t === n.length - 1 ? e : 0 !== t && t !== n.length - 1 ? e.trim() : 0 === t ? e.trimEnd() : e.trimStart()
            );
            return "preserve" === n116.proseWrap ? r.map((e)=>0 === e.length ? [] : [
                    e
                ]
            ) : r.map((e)=>0 === e.length ? [] : tH(e)
            ).reduce((t, n, o)=>0 !== o && r[o - 1].length > 0 && n.length > 0 && ("quoteDouble" !== e429 || !GG(GG(t)).endsWith("\\")) ? [
                    ...t.slice(0, -1),
                    [
                        ...GG(t),
                        ...n
                    ]
                ] : [
                    ...t,
                    n
                ]
            , []).map((e)=>"never" === n116.proseWrap ? [
                    e.join(" ")
                ] : e
            );
        },
        getLastDescendantNode: function e(t) {
            return HG(t.children) ? e(GG(t.children)) : t;
        },
        hasPrettierIgnore: function(e) {
            const t = e.getValue();
            if ("documentBody" === t.type) {
                const t = e.getParentNode();
                return eH(t.head) && XG(GG(t.head.endComments));
            }
            return YG(t) && XG(GG(t.leadingComments));
        },
        hasLeadingComments: YG,
        hasMiddleComments: KG,
        hasIndicatorComment: QG,
        hasTrailingComment: ZG,
        hasEndComments: eH
    };
    const { defineShortcut: rH , mapNode: oH  } = nH;
    function iH(e) {
        switch(e.type){
            case "document":
                rH(e, "head", ()=>e.children[0]
                ), rH(e, "body", ()=>e.children[1]
                );
                break;
            case "documentBody":
            case "sequenceItem":
            case "flowSequenceItem":
            case "mappingKey":
            case "mappingValue":
                rH(e, "content", ()=>e.children[0]
                );
                break;
            case "mappingItem":
            case "flowMappingItem":
                rH(e, "key", ()=>e.children[0]
                ), rH(e, "value", ()=>e.children[1]
                );
        }
        return e;
    }
    var uH = function(e) {
        return oH(e, iH);
    };
    const { builders: { softline: sH , align: aH  }  } = Zc, { hasEndComments: cH , isNextLineEmpty: lH , isNode: pH  } = nH, fH = new WeakMap;
    function dH(e) {
        return cH(e) && !pH(e, [
            "documentHead",
            "documentBody",
            "flowMapping",
            "flowSequence"
        ]);
    }
    var hH = {
        alignWithSpaces: function(e, t) {
            return aH(" ".repeat(e), t);
        },
        shouldPrintEndComments: dH,
        printNextEmptyLine: function(e, t) {
            const n = e.getValue(), r = e.stack[0];
            let o;
            return fH.has(r) ? o = fH.get(r) : (o = new Set, fH.set(r, o)), o.has(n.position.end.line) || (o.add(n.position.end.line), !lH(n, t) || dH(e.getParentNode())) ? "" : sH;
        }
    };
    const { builders: { ifBreak: gH , line: mH , softline: yH , hardline: DH , join: EH  }  } = Zc, { isEmptyNode: CH , getLast: bH , hasEndComments: vH  } = nH, { printNextEmptyLine: AH , alignWithSpaces: FH  } = hH;
    function xH(e, t, n) {
        const r = e.getValue(), o = "flowMapping" === r.type, i = o ? "{" : "[", u = o ? "}" : "]";
        let s = yH;
        o && r.children.length > 0 && n.bracketSpacing && (s = mH);
        const a = bH(r.children), c = a && "flowMappingItem" === a.type && CH(a.key) && CH(a.value);
        return [
            i,
            FH(n.tabWidth, [
                s,
                SH(e, t, n),
                "none" === n.trailingComma ? "" : gH(","),
                vH(r) ? [
                    DH,
                    EH(DH, e.map(t, "endComments"))
                ] : ""
            ]),
            c ? "" : s,
            u
        ];
    }
    function SH(e430, t, n) {
        const r = e430.getValue();
        return e430.map((e, o)=>[
                t(),
                o === r.children.length - 1 ? "" : [
                    ",",
                    mH,
                    r.children[o].position.start.line !== r.children[o + 1].position.start.line ? AH(e, n.originalText) : ""
                ]
            ]
        , "children");
    }
    var wH = {
        printFlowMapping: xH,
        printFlowSequence: xH
    };
    const { builders: { conditionalGroup: TH , group: BH , hardline: NH , ifBreak: kH , join: PH , line: OH  }  } = Zc, { hasLeadingComments: IH , hasMiddleComments: LH , hasTrailingComment: jH , hasEndComments: _H , isNode: MH , isEmptyNode: RH , isInlineNode: VH  } = nH, { alignWithSpaces: $H  } = hH;
    function WH(e, t) {
        if (!e) return !0;
        switch(e.type){
            case "plain":
            case "quoteSingle":
            case "quoteDouble":
                break;
            case "alias":
                return !0;
            default:
                return !1;
        }
        if ("preserve" === t.proseWrap) return e.position.start.line === e.position.end.line;
        if (/\\$/m.test(t.originalText.slice(e.position.start.offset, e.position.end.offset))) return !1;
        switch(t.proseWrap){
            case "never":
                return !e.value.includes("\n");
            case "always":
                return !/[\n ]/.test(e.value);
            default:
                return !1;
        }
    }
    var qH = function(e431, t, n, r, o) {
        const { key: i , value: u  } = e431, s = RH(i), a = RH(u);
        if (s && a) return ": ";
        const c = r("key"), l = function(e) {
            return e.key.content && "alias" === e.key.content.type;
        }(e431) ? " " : "";
        if (a) return "flowMappingItem" === e431.type && "flowMapping" === t.type ? c : "mappingItem" !== e431.type || !WH(i.content, o) || jH(i.content) || t.tag && "tag:yaml.org,2002:set" === t.tag.value ? [
            "? ",
            $H(2, c)
        ] : [
            c,
            l,
            ":"
        ];
        const p = r("value");
        if (s) return [
            ": ",
            $H(2, p)
        ];
        if (IH(u) || !VH(i.content)) return [
            "? ",
            $H(2, c),
            NH,
            PH("", n.map(r, "value", "leadingComments").map((e)=>[
                    e,
                    NH
                ]
            )),
            ": ",
            $H(2, p)
        ];
        if ((function(e) {
            if (!e) return !0;
            switch(e.type){
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                    return e.position.start.line === e.position.end.line;
                case "alias":
                    return !0;
                default:
                    return !1;
            }
        })(i.content) && !IH(i.content) && !LH(i.content) && !jH(i.content) && !_H(i) && !IH(u.content) && !LH(u.content) && !_H(u) && WH(u.content, o)) return [
            c,
            l,
            ": ",
            p
        ];
        const f = Symbol("mappingKey"), d = BH([
            kH("? "),
            BH($H(2, c), {
                id: f
            })
        ]), h = [
            NH,
            ": ",
            $H(2, p)
        ], g = [
            l,
            ":"
        ];
        IH(u.content) || _H(u) && u.content && !MH(u.content, [
            "mapping",
            "sequence"
        ]) || "mapping" === t.type && jH(i.content) && VH(u.content) || MH(u.content, [
            "mapping",
            "sequence"
        ]) && null === u.content.tag && null === u.content.anchor ? g.push(NH) : u.content && g.push(OH), g.push(p);
        const m = $H(o.tabWidth, g);
        return !WH(i.content, o) || IH(i.content) || LH(i.content) || _H(i) ? TH([
            [
                d,
                kH(h, m, {
                    groupId: f
                })
            ]
        ]) : TH([
            [
                c,
                m
            ]
        ]);
    };
    const { builders: { dedent: UH , dedentToRoot: zH , fill: GH , hardline: HH , join: JH , line: XH , literalline: YH , markAsRoot: KH  } , utils: { getDocParts: QH  }  } = Zc, { getAncestorCount: ZH , getBlockValueLineContents: eJ , hasIndicatorComment: tJ , isLastDescendantNode: nJ , isNode: rJ  } = nH, { alignWithSpaces: oJ  } = hH;
    var iJ = function(e433, t, n) {
        const r = e433.getValue(), o = ZH(e433, (e)=>rJ(e, [
                "sequence",
                "mapping"
            ])
        ), i = nJ(e433), u = [
            "blockFolded" === r.type ? ">" : "|"
        ];
        null !== r.indent && u.push(r.indent.toString()), "clip" !== r.chomping && u.push("keep" === r.chomping ? "+" : "-"), tJ(r) && u.push(" ", t("indicatorComment"));
        const s = eJ(r, {
            parentIndent: o,
            isLastDescendant: i,
            options: n
        }), a = [];
        for (const [e432, t206] of s.entries())0 === e432 && a.push(HH), a.push(GH(QH(JH(XH, t206)))), e432 !== s.length - 1 ? a.push(0 === t206.length ? HH : KH(YH)) : "keep" === r.chomping && i && a.push(zH(0 === t206.length ? HH : YH));
        return null === r.indent ? u.push(UH(oJ(n.tabWidth, a))) : u.push(zH(oJ(r.indent - 1 + o, a))), u;
    };
    const { builders: { breakParent: uJ , fill: sJ , group: aJ , hardline: cJ , join: lJ , line: pJ , lineSuffix: fJ , literalline: dJ  } , utils: { getDocParts: hJ , replaceTextEndOfLine: gJ  }  } = Zc, { isPreviousLineEmpty: mJ  } = dc, { insertPragma: yJ , isPragma: DJ  } = qG, { locStart: EJ  } = UG, CJ = zG, { getFlowScalarLineContents: bJ , getLastDescendantNode: vJ , hasLeadingComments: AJ , hasMiddleComments: FJ , hasTrailingComment: xJ , hasEndComments: SJ , hasPrettierIgnore: wJ , isLastDescendantNode: TJ , isNode: BJ , isInlineNode: NJ  } = nH, kJ = uH, { alignWithSpaces: PJ , printNextEmptyLine: OJ , shouldPrintEndComments: IJ  } = hH, { printFlowMapping: LJ , printFlowSequence: jJ  } = wH, _J = qH, MJ = iJ;
    function RJ(e, t) {
        return xJ(e) || t && (t.head.children.length > 0 || SJ(t.head));
    }
    function VJ(e434, t, n) {
        const r = bJ(e434, t, n);
        return lJ(cJ, r.map((e)=>sJ(hJ(lJ(pJ, e)))
        ));
    }
    var $J = {
        preprocess: kJ,
        embed: CJ,
        print: function(e435, t207, n117) {
            const r87 = e435.getValue(), o60 = [];
            "mappingValue" !== r87.type && AJ(r87) && o60.push([
                lJ(cJ, e435.map(n117, "leadingComments")),
                cJ
            ]);
            const { tag: i31 , anchor: u26  } = r87;
            i31 && o60.push(n117("tag")), i31 && u26 && o60.push(" "), u26 && o60.push(n117("anchor"));
            let s = "";
            BJ(r87, [
                "mapping",
                "sequence",
                "comment",
                "directive",
                "mappingItem",
                "sequenceItem"
            ]) && !TJ(e435) && (s = OJ(e435, t207.originalText)), (i31 || u26) && (BJ(r87, [
                "sequence",
                "mapping"
            ]) && !FJ(r87) ? o60.push(cJ) : o60.push(" ")), FJ(r87) && o60.push([
                1 === r87.middleComments.length ? "" : cJ,
                lJ(cJ, e435.map(n117, "middleComments")),
                cJ
            ]);
            const a = e435.getParentNode();
            return wJ(e435) ? o60.push(gJ(t207.originalText.slice(r87.position.start.offset, r87.position.end.offset).trimEnd(), dJ)) : o60.push(aJ(function(e436, t208, n118, r88, o) {
                switch(e436.type){
                    case "root":
                        {
                            const { children: t  } = e436, r = [];
                            n118.each((e, n)=>{
                                const i = t[n], u = t[n + 1];
                                0 !== n && r.push(cJ), r.push(o()), RJ(i, u) ? (r.push(cJ, "..."), xJ(i) && r.push(" ", o("trailingComment"))) : u && !xJ(u.head) && r.push(cJ, "---");
                            }, "children");
                            const i32 = vJ(e436);
                            return BJ(i32, [
                                "blockLiteral",
                                "blockFolded"
                            ]) && "keep" === i32.chomping || r.push(cJ), r;
                        }
                    case "document":
                        {
                            const i = [];
                            return "head" === (function(e, t, n, r) {
                                if (n.children[0] === e && /---(?:\s|$)/.test(r.originalText.slice(EJ(e), EJ(e) + 4)) || e.head.children.length > 0 || SJ(e.head) || xJ(e.head)) return "head";
                                if (RJ(e, t)) return !1;
                                return !!t && "root";
                            })(e436, t208.children[n118.getName() + 1], t208, r88) && ((e436.head.children.length > 0 || e436.head.endComments.length > 0) && i.push(o("head")), xJ(e436.head) ? i.push([
                                "---",
                                " ",
                                o([
                                    "head",
                                    "trailingComment"
                                ])
                            ]) : i.push("---")), (function(e) {
                                return e.body.children.length > 0 || SJ(e.body);
                            })(e436) && i.push(o("body")), lJ(cJ, i);
                        }
                    case "documentHead":
                        return lJ(cJ, [
                            ...n118.map(o, "children"),
                            ...n118.map(o, "endComments")
                        ]);
                    case "documentBody":
                        {
                            const { children: t , endComments: r  } = e436;
                            let i = "";
                            if (t.length > 0 && r.length > 0) {
                                const t = vJ(e436);
                                BJ(t, [
                                    "blockFolded",
                                    "blockLiteral"
                                ]) ? "keep" !== t.chomping && (i = [
                                    cJ,
                                    cJ
                                ]) : i = cJ;
                            }
                            return [
                                lJ(cJ, n118.map(o, "children")),
                                i,
                                lJ(cJ, n118.map(o, "endComments"))
                            ];
                        }
                    case "directive":
                        return [
                            "%",
                            lJ(" ", [
                                e436.name,
                                ...e436.parameters
                            ])
                        ];
                    case "comment":
                        return [
                            "#",
                            e436.value
                        ];
                    case "alias":
                        return [
                            "*",
                            e436.value
                        ];
                    case "tag":
                        return r88.originalText.slice(e436.position.start.offset, e436.position.end.offset);
                    case "anchor":
                        return [
                            "&",
                            e436.value
                        ];
                    case "plain":
                        return VJ(e436.type, r88.originalText.slice(e436.position.start.offset, e436.position.end.offset), r88);
                    case "quoteDouble":
                    case "quoteSingle":
                        {
                            const t = "'", n = '"', o = r88.originalText.slice(e436.position.start.offset + 1, e436.position.end.offset - 1);
                            if ("quoteSingle" === e436.type && o.includes("\\") || "quoteDouble" === e436.type && /\\[^"]/.test(o)) {
                                const i = "quoteDouble" === e436.type ? n : t;
                                return [
                                    i,
                                    VJ(e436.type, o, r88),
                                    i
                                ];
                            }
                            if (o.includes(n)) return [
                                t,
                                VJ(e436.type, "quoteDouble" === e436.type ? o.replace(/\\"/g, n).replace(/'/g, t.repeat(2)) : o, r88),
                                t
                            ];
                            if (o.includes(t)) return [
                                n,
                                VJ(e436.type, "quoteSingle" === e436.type ? o.replace(/''/g, t) : o, r88),
                                n
                            ];
                            const i = r88.singleQuote ? t : n;
                            return [
                                i,
                                VJ(e436.type, o, r88),
                                i
                            ];
                        }
                    case "blockFolded":
                    case "blockLiteral":
                        return MJ(n118, o, r88);
                    case "mapping":
                    case "sequence":
                        return lJ(cJ, n118.map(o, "children"));
                    case "sequenceItem":
                        return [
                            "- ",
                            PJ(2, e436.content ? o("content") : "")
                        ];
                    case "mappingKey":
                    case "mappingValue":
                        return e436.content ? o("content") : "";
                    case "mappingItem":
                    case "flowMappingItem":
                        return _J(e436, t208, n118, o, r88);
                    case "flowMapping":
                        return LJ(n118, o, r88);
                    case "flowSequence":
                        return jJ(n118, o, r88);
                    case "flowSequenceItem":
                        return o("content");
                    default:
                        throw new Error("Unexpected node type ".concat(e436.type));
                }
            }(r87, a, e435, t207, n117))), xJ(r87) && !BJ(r87, [
                "document",
                "documentHead"
            ]) && o60.push(fJ([
                "mappingValue" !== r87.type || r87.content ? " " : "",
                "mappingKey" === a.type && "mapping" === e435.getParentNode(2).type && NJ(r87) ? "" : uJ,
                n117("trailingComment")
            ])), IJ(r87) && o60.push(PJ("sequenceItem" === r87.type ? 2 : 0, [
                cJ,
                lJ(cJ, e435.map((e)=>[
                        mJ(t207.originalText, e.getValue(), EJ) ? cJ : "",
                        n117()
                    ]
                , "endComments"))
            ])), o60.push(s), o60;
        },
        massageAstNode: function(e, t) {
            if (BJ(t)) switch(delete t.position, t.type){
                case "comment":
                    if (DJ(t.value)) return null;
                    break;
                case "quoteDouble":
                case "quoteSingle":
                    t.type = "quote";
            }
        },
        insertPragma: yJ
    };
    const WJ = $J, qJ = {
        bracketSpacing: bj.bracketSpacing,
        singleQuote: bj.singleQuote,
        proseWrap: bj.proseWrap
    }, UJ = [
        bE({
            name: "YAML",
            type: "data",
            color: "#cb171e",
            tmScope: "source.yaml",
            aliases: [
                "yml"
            ],
            extensions: [
                ".yml",
                ".mir",
                ".reek",
                ".rviz",
                ".sublime-syntax",
                ".syntax",
                ".yaml",
                ".yaml-tmlanguage",
                ".yaml.sed",
                ".yml.mysql"
            ],
            filenames: [
                ".clang-format",
                ".clang-tidy",
                ".gemrc",
                "glide.lock",
                "yarn.lock"
            ],
            aceMode: "yaml",
            codemirrorMode: "yaml",
            codemirrorMimeType: "text/x-yaml",
            languageId: 407
        }, (e437)=>({
                since: "1.14.0",
                parsers: [
                    "yaml"
                ],
                vscodeLanguageIds: [
                    "yaml",
                    "ansible",
                    "home-assistant"
                ],
                filenames: [
                    ...e437.filenames.filter((e)=>"yarn.lock" !== e
                    ),
                    ".prettierrc",
                    ".stylelintrc"
                ]
            })
        )
    ];
    var zJ = [
        Ij,
        QM,
        fV,
        IV,
        bW,
        WG,
        {
            languages: UJ,
            printers: {
                yaml: WJ
            },
            options: qJ,
            parsers: undefined
        }
    ];
    const { version: GJ  } = n2, HJ = XD, { getSupportInfo: JJ  } = za, XJ = EE, YJ = zJ, KJ = Zc;
    function QJ(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        return function() {
            for(var n = arguments.length, r = new Array(n), o = 0; o < n; o++)r[o] = arguments[o];
            const i = r[t] || {
            }, u = i.plugins || [];
            return r[t] = Object.assign(Object.assign({
            }, i), {
            }, {
                plugins: [
                    ...YJ,
                    ...Array.isArray(u) ? u : Object.values(u)
                ]
            }), e(...r);
        };
    }
    const ZJ = QJ(HJ.formatWithCursor);
    var eX = {
        formatWithCursor: ZJ,
        format: (e, t)=>ZJ(e, t).formatted
        ,
        check (e, t) {
            const { formatted: n  } = ZJ(e, t);
            return n === e;
        },
        doc: KJ,
        getSupportInfo: QJ(JJ, 0),
        version: GJ,
        util: XJ,
        __debug: {
            parse: QJ(HJ.parse),
            formatAST: QJ(HJ.formatAST),
            formatDoc: QJ(HJ.formatDoc),
            printToDoc: QJ(HJ.printToDoc),
            printDocToString: QJ(HJ.printDocToString)
        }
    };
    return eX;
});

},{}],"kpwva":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showTasks", ()=>showTasks
);
var _selector = require("./selector");
const date = document.querySelector('.deadline');
let localItems = {
}, currentValue = null;
const createTask = (e)=>{
    e.preventDefault();
    if (_selector.taskName.value === '') return alert('Please, write your task');
    if (date.value === '') return alert('Please, write deadline');
    let groupList = document.querySelectorAll('.group-list');
    groupList.forEach((el, ind)=>{
        if (el.selected) currentValue = ind;
    });
    taskObj = {
        text: _selector.taskName.value,
        status: 'new',
        date: transformDate(date.value)
    };
    addItemsToLocalstorage(taskObj);
    showTasks();
};
const addItemsToLocalstorage = (taskObj)=>{
    let localItems1 = JSON.parse(localStorage.getItem('local')) || {
    };
    localItems1[currentValue].tasks.push(taskObj);
    localStorage.setItem('local', JSON.stringify(localItems1));
};
const showTasks = ()=>{
    let groupItems = document.querySelectorAll('.group__items'), localItems2 = JSON.parse(localStorage.getItem('local')) || {
    };
    groupItems.forEach((el, i)=>{
        tasks = localItems2[i].tasks;
        for(let task in tasks)el.innerHTML += `
      <div class="group__task">
        <div class="group__task-name">
            ${task.name}
        </div>
        <div class="group__task-status"> 
        <fieldset class="legend">
            <legend>Status</legend>
            <select class="group__task-select">
                <option value="">New</option>
                <option value="">In progress</option>
                <option value="">Done</option>
            </select>
        </fieldset>
        </div>
        <div class="group__task-deadline"> ${task.date}</div>
      </div>
    `;
    });
    _selector.taskName.value = '';
    date.value = '';
    _selector.modalTask.style.display = 'none';
};
const transformDate = (date1)=>{
    return date1.split('-').reverse().join('.');
};
exports.default = createTask;

},{"./selector":"cjxTH","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}]},["kI3VP","7BQdY"], "7BQdY", "parcelRequire5af9")

//# sourceMappingURL=index.38661719.js.map
